/**
 * Shared helpers for building and executing monitor UPDATE queries.
 *
 * @remarks
 * Extracted from {@link MonitorRepository} to keep the repository class focused
 * on transactional orchestration rather than dynamic SQL plumbing.
 */

import type { Site } from "@shared/types";
import type { Database } from "node-sqlite3-wasm";
import type { UnknownRecord } from "type-fest";

import { isDev } from "../../electronUtils";
import { logger } from "../../utils/logger";
import {
    convertToDbValue,
    type DbValue,
} from "./utils/converters/valueConverters";

/**
 * Result of computing a dynamic UPDATE statement fragment.
 */
export interface BuildUpdateFieldsAndValuesResult {
    readonly updateFields: string[];
    readonly updateValues: DbValue[];
}

// eslint-disable-next-line sonarjs/function-return-type -- Intentional: returns DbValue when storable, otherwise `undefined` to skip binding.
function convertValueForDatabase(
    key: string,
    value: unknown
): DbValue | undefined {
    const converted = convertToDbValue(value);
    if (converted !== undefined) {
        return converted;
    }

    if (isDev()) {
        logger.warn(
            `[MonitorRepository] Skipping non-primitive field ${key} with value:`,
            value
        );
    }

    return undefined;
}

/**
 * Quotes and validates a SQLite identifier (column name).
 *
 * @remarks
 * Identifiers cannot be bound as SQL parameters, so they must be validated.
 * This function enforces a conservative identifier grammar and then applies
 * defensive quoting.
 */
export function escapeSqlIdentifier(identifier: string): string {
    const isSafe = /^[A-Za-z_]\w*$/u.test(identifier);
    if (!isSafe) {
        throw new Error(
            `[MonitorRepository] Unsafe SQL identifier rejected: '${identifier}'`
        );
    }

    // Quote defensively.
    return `"${identifier.replaceAll('"', '""')}"`;
}

/**
 * Checks if monitoring-related fields should be skipped during update.
 */
function shouldSkipMonitoringFields(
    key: string,
    monitor: Partial<Site["monitors"][0]>
): boolean {
    if (
        key === "enabled" &&
        !("monitoring" in monitor) &&
        !("enabled" in monitor)
    ) {
        if (isDev()) {
            logger.debug(
                "[MonitorRepository] Skipping 'enabled' field - monitoring state not provided in update"
            );
        }
        return true;
    }

    return false;
}

/**
 * Builds the update fields and values for a monitor UPDATE query.
 *
 * @remarks
 * - Only primitive values that SQLite can handle are included.
 * - Monitoring fields may be skipped per domain logic.
 */
export function buildUpdateFieldsAndValues(args: {
    readonly monitor: Partial<Site["monitors"][0]>;
    readonly row: UnknownRecord;
}): BuildUpdateFieldsAndValuesResult {
    const updateFields: string[] = [];
    const updateValues: DbValue[] = [];

    // Only update fields that are actually provided and are primitive types.
    for (const [key, value] of Object.entries(args.row)) {
        const shouldProcess =
            value !== undefined &&
            !shouldSkipMonitoringFields(key, args.monitor);

        if (shouldProcess) {
            const fieldValue = convertValueForDatabase(key, value);
            if (fieldValue !== undefined) {
                updateFields.push(`${escapeSqlIdentifier(key)} = ?`);
                updateValues.push(fieldValue);
            }
        }
    }

    return { updateFields, updateValues };
}

/**
 * Executes a monitor UPDATE query.
 *
 * @remarks
 * `updateFields` must be generated by application code (not user input). All
 * runtime values are still bound as SQL parameters.
 */
export function executeUpdateQuery(args: {
    readonly db: Database;
    readonly monitorId: string;
    readonly updateFields: string[];
    readonly updateValues: DbValue[];
}): void {
    const boundValues: DbValue[] = [...args.updateValues, args.monitorId];

    // eslint-disable-next-line sql-template/no-unsafe-query -- Safe: updateFields is generated by application code, user values passed as parameters
    const sql = `UPDATE monitors SET ${args.updateFields.join(", ")} WHERE id = ?`;

    if (isDev()) {
        logger.debug(
            `[MonitorRepository] Executing SQL: ${sql} with values:`,
            boundValues
        );
    }

    args.db.run(sql, boundValues);

    if (isDev()) {
        logger.debug(
            `[MonitorRepository] Updated monitor with id: ${args.monitorId} (internal)`
        );
    }
}
