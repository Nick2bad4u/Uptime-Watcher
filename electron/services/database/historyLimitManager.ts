/**
 * Utility for managing history limits in the database.
 *
 * @remarks
 * Provides functions for setting and getting history retention limits with
 * proper database consistency and validation. Handles limit enforcement,
 * pruning of older entries, and integration with settings storage.
 *
 * @packageDocumentation
 */

import type { HistoryLimitRules } from "@shared/constants/history";
import type { Logger } from "@shared/utils/logger/interfaces";
import type { Promisable } from "type-fest";

import { normalizeHistoryLimit } from "@shared/constants/history";

import type { DatabaseService } from "./DatabaseService";
import type {
    HistoryRepository,
    HistoryRepositoryTransactionAdapter,
} from "./HistoryRepository";
import type {
    SettingsRepository,
    SettingsRepositoryTransactionAdapter,
} from "./SettingsRepository";

import { withDatabaseOperation } from "../../utils/operationalHooks";
import { createHistorySettingsTransactionAdapters } from "./transactionAdapters";

/**
 * Parameters for setting history limit
 */
interface SetHistoryLimitParams {
    /**
     * Database service for transactions
     */
    databaseService: DatabaseService;

    /**
     * The limit to set
     */
    limit: number;

    /**
     * Logger instance
     */
    logger?: Logger;

    /**
     * Repository instances
     */
    repositories: {
        history: HistoryRepository;
        settings: SettingsRepository;
    };

    /**
     * History retention business rules to apply when normalizing the limit.
     */
    rules: HistoryLimitRules;

    /**
     * Callback to update the internal history limit
     *
     * @remarks
     * This callback updates the in-memory history limit value immediately,
     * providing synchronous access for other components while the database
     * update happens asynchronously. Should be called before database
     * operations to ensure consistency between memory and database state.
     */
    setHistoryLimit: (limit: number) => void;
}

/**
 * Get the current history limit.
 *
 * Simple getter function that provides access to the history limit. This
 * indirection enables dependency injection and testability.
 *
 * @param getHistoryLimitFn - Function to retrieve the current history limit
 *
 * @returns The current history limit
 */
export function getHistoryLimit(getHistoryLimitFn: () => number): number {
    return getHistoryLimitFn();
}

/**
 * Executes a transaction with history and settings repository adapters.
 *
 * @param databaseService - Database service coordinating the transaction.
 * @param repositories - History and settings repositories to source adapters
 *   from.
 * @param operation - Callback supplied with adapters scoped to the active
 *   transaction.
 *
 * @returns Result generated by the provided operation.
 */
async function withHistorySettingsAdapters<T>(
    databaseService: DatabaseService,
    repositories: {
        history: HistoryRepository;
        settings: SettingsRepository;
    },
    operation: (adapters: {
        historyTx: HistoryRepositoryTransactionAdapter;
        settingsTx: SettingsRepositoryTransactionAdapter;
    }) => Promisable<T>
): Promise<T> {
    return databaseService.executeTransaction(async (db) =>
        operation(createHistorySettingsTransactionAdapters(db, repositories))
    );
}

/**
 * Set the history retention limit and prune older history entries if needed.
 *
 * Limit behavior:
 *
 * - 0 or negative: Disables history retention (unlimited)
 * - Positive values below the configured minimum: raised to the rules-driven
 *   minimum (25 by default)
 * - Positive values within the configured range: used as provided
 *
 * @param params - Parameters for setting history limit
 *
 * @throws Error when database operations fail
 */
export async function setHistoryLimit(
    params: SetHistoryLimitParams
): Promise<void> {
    const {
        databaseService,
        limit,
        logger,
        repositories,
        rules,
        setHistoryLimit: updateHistoryLimit,
    } = params;

    const finalLimit = normalizeHistoryLimit(limit, rules);

    // Update the internal limit
    updateHistoryLimit(finalLimit);

    // Use single transaction for atomicity - either both operations succeed or
    // both fail
    await withDatabaseOperation(
        async () =>
            withHistorySettingsAdapters(
                databaseService,
                repositories,
                ({ historyTx, settingsTx }) => {
                    settingsTx.set("historyLimit", finalLimit.toString());

                    if (finalLimit > 0) {
                        historyTx.pruneAllHistory(finalLimit);
                    }
                }
            ),
        "history-limit-manager-set",
        undefined,
        { limit: finalLimit }
    );

    if (logger) {
        logger.debug(`History limit set to ${finalLimit}`);
        if (finalLimit > 0) {
            logger.debug(`Pruned history to ${finalLimit} entries per monitor`);
        }
    }
}

/**
 * Executes a transaction with history and settings repository adapters.
 *
 * @param databaseService - Database service coordinating the transaction.
 * @param repositories - History and settings repositories to source adapters
 *   from.
 * @param operation - Callback supplied with adapters scoped to the active
 *   transaction.
 *
 * @returns Result generated by the provided operation.
 */
