This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.
The content has been processed where empty lines have been removed, content has been compressed (code blocks are separated by ⋮---- delimiter).

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: src/**, electron/**
- Files matching these patterns are excluded: **/test/**
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Empty lines have been removed from all files
- Content has been compressed - code blocks are separated by ⋮---- delimiter
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
electron/constants.ts
electron/electronUtils.ts
electron/events/eventTypes.ts
electron/events/index.ts
electron/events/middleware.ts
electron/events/TypedEventBus.ts
electron/index.ts
electron/main.ts
electron/managers/ConfigurationManager.ts
electron/managers/DatabaseManager.ts
electron/managers/index.ts
electron/managers/MonitorManager.ts
electron/managers/SiteManager.ts
electron/managers/validators/index.ts
electron/managers/validators/MonitorValidator.ts
electron/managers/validators/SiteValidator.ts
electron/preload.ts
electron/services/application/ApplicationService.ts
electron/services/application/index.ts
electron/services/database/DatabaseService.ts
electron/services/database/HistoryRepository.ts
electron/services/database/index.ts
electron/services/database/MonitorRepository.ts
electron/services/database/SettingsRepository.ts
electron/services/database/SiteRepository.ts
electron/services/database/utils/databaseBackup.ts
electron/services/database/utils/databaseSchema.ts
electron/services/database/utils/dynamicSchema.ts
electron/services/database/utils/historyManipulation.ts
electron/services/database/utils/historyMapper.ts
electron/services/database/utils/historyQuery.ts
electron/services/database/utils/index.ts
electron/services/database/utils/monitorMapper.ts
electron/services/database/utils/valueConverters.ts
electron/services/index.ts
electron/services/ipc/index.ts
electron/services/ipc/IpcService.ts
electron/services/monitoring/AdvancedValidationEngine.ts
electron/services/monitoring/DatabaseSchemaMigrator.ts
electron/services/monitoring/EnhancedTypeGuards.ts
electron/services/monitoring/HttpMonitor.ts
electron/services/monitoring/index.ts
electron/services/monitoring/MigrationSystem.ts
electron/services/monitoring/MonitorFactory.ts
electron/services/monitoring/MonitorScheduler.ts
electron/services/monitoring/MonitorTypeRegistry.ts
electron/services/monitoring/PortMonitor.ts
electron/services/monitoring/types.ts
electron/services/monitoring/utils/errorHandling.ts
electron/services/monitoring/utils/httpClient.ts
electron/services/monitoring/utils/httpStatusUtils.ts
electron/services/monitoring/utils/index.ts
electron/services/monitoring/utils/portChecker.ts
electron/services/monitoring/utils/portErrorHandling.ts
electron/services/monitoring/utils/portRetry.ts
electron/services/notifications/index.ts
electron/services/notifications/NotificationService.ts
electron/services/ServiceContainer.ts
electron/services/updater/AutoUpdaterService.ts
electron/services/updater/index.ts
electron/services/window/index.ts
electron/services/window/WindowService.ts
electron/types.ts
electron/UptimeOrchestrator.ts
electron/utils/correlation.ts
electron/utils/database/DataBackupService.ts
electron/utils/database/databaseInitializer.ts
electron/utils/database/DataImportExportService.ts
electron/utils/database/historyLimitManager.ts
electron/utils/database/index.ts
electron/utils/database/interfaces.ts
electron/utils/database/serviceFactory.ts
electron/utils/database/SiteRepositoryService.ts
electron/utils/database/SiteWriterService.ts
electron/utils/database/StateSyncService.ts
electron/utils/errorHandling.ts
electron/utils/index.ts
electron/utils/logger.ts
electron/utils/monitoring/autoMonitorManager.ts
electron/utils/monitoring/index.ts
electron/utils/monitoring/intervalManager.ts
electron/utils/monitoring/monitorLifecycle.ts
electron/utils/monitoring/monitorStatusChecker.ts
electron/utils/monitoring/monitorValidator.ts
electron/utils/operationalHooks.ts
electron/utils/retry.ts
electron/utils/siteStatus.ts
src/App.tsx
src/components/AddSiteForm/AddSiteForm.tsx
src/components/AddSiteForm/DynamicMonitorFields.tsx
src/components/AddSiteForm/FormFields.tsx
src/components/AddSiteForm/index.ts
src/components/AddSiteForm/Submit.tsx
src/components/common/HistoryChart.tsx
src/components/common/index.ts
src/components/common/StatusBadge.tsx
src/components/Dashboard/index.ts
src/components/Dashboard/SiteCard/components/ActionButtonGroup.tsx
src/components/Dashboard/SiteCard/components/index.ts
src/components/Dashboard/SiteCard/components/MetricCard.tsx
src/components/Dashboard/SiteCard/components/MonitorSelector.tsx
src/components/Dashboard/SiteCard/index.tsx
src/components/Dashboard/SiteCard/SiteCardFooter.tsx
src/components/Dashboard/SiteCard/SiteCardHeader.tsx
src/components/Dashboard/SiteCard/SiteCardHistory.tsx
src/components/Dashboard/SiteCard/SiteCardMetrics.tsx
src/components/Dashboard/SiteCard/SiteCardStatus.tsx
src/components/Dashboard/SiteList/EmptyState.tsx
src/components/Dashboard/SiteList/index.tsx
src/components/dynamic-monitor-ui.tsx
src/components/Header/Header.css
src/components/Header/Header.tsx
src/components/Header/index.ts
src/components/index.ts
src/components/Settings/index.ts
src/components/Settings/Settings.tsx
src/components/SiteDetails/index.ts
src/components/SiteDetails/ScreenshotThumbnail.tsx
src/components/SiteDetails/SiteDetails.css
src/components/SiteDetails/SiteDetails.tsx
src/components/SiteDetails/SiteDetailsHeader.tsx
src/components/SiteDetails/SiteDetailsNavigation.tsx
src/components/SiteDetails/tabs/AnalyticsTab.tsx
src/components/SiteDetails/tabs/HistoryTab.tsx
src/components/SiteDetails/tabs/index.ts
src/components/SiteDetails/tabs/OverviewTab.tsx
src/components/SiteDetails/tabs/SettingsTab.tsx
src/components/SiteDetails/tabs/SiteOverviewTab.tsx
src/components/SiteDetails/useAddSiteForm.ts
src/constants.ts
src/hooks/index.ts
src/hooks/site/index.ts
src/hooks/site/useSite.ts
src/hooks/site/useSiteActions.ts
src/hooks/site/useSiteAnalytics.ts
src/hooks/site/useSiteDetails.ts
src/hooks/site/useSiteMonitor.ts
src/hooks/site/useSiteStats.ts
src/hooks/useBackendFocusSync.ts
src/hooks/useMonitorFields.ts
src/hooks/useMonitorTypes.ts
src/hooks/useSelectedSite.ts
src/hooks/useStateSynchronization.ts
src/hooks/useThemeStyles.ts
src/index.css
src/index.ts
src/main.tsx
src/services/chartConfig.ts
src/services/index.ts
src/services/logger.ts
src/stores/error/ErrorBoundary.tsx
src/stores/error/types.ts
src/stores/error/useErrorStore.ts
src/stores/index.ts
src/stores/settings/types.ts
src/stores/settings/useSettingsStore.ts
src/stores/sites/services/index.ts
src/stores/sites/services/MonitoringService.ts
src/stores/sites/services/SiteService.ts
src/stores/sites/types.ts
src/stores/sites/useSiteMonitoring.ts
src/stores/sites/useSiteOperations.ts
src/stores/sites/useSitesState.ts
src/stores/sites/useSitesStore.ts
src/stores/sites/useSiteSync.ts
src/stores/sites/utils/fileDownload.ts
src/stores/sites/utils/index.ts
src/stores/sites/utils/monitorOperations.ts
src/stores/sites/utils/statusUpdateHandler.ts
src/stores/stats/types.ts
src/stores/stats/useStatsStore.ts
src/stores/types.ts
src/stores/ui/types.ts
src/stores/ui/useUiStore.ts
src/stores/updates/types.ts
src/stores/updates/useUpdatesStore.ts
src/stores/utils.ts
src/theme/components.css
src/theme/components.tsx
src/theme/index.ts
src/theme/ThemeManager.ts
src/theme/themes.ts
src/theme/types.ts
src/theme/useTheme.ts
src/types.ts
src/utils/data/generateUuid.ts
src/utils/duration.ts
src/utils/dynamicMonitorUi.ts
src/utils/index.ts
src/utils/monitorTitleFormatters.ts
src/utils/monitorTypeHelper.ts
src/utils/monitorValidation.ts
src/utils/siteStatus.ts
src/utils/status.ts
src/utils/time.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="electron/events/index.ts">
/**
 * Type-Safe Event Bus with Middleware support.
 * Provides enhanced EventEmitter functionality with compile-time type safety.
 */
⋮----
// Export the full event types with complete type safety
⋮----
// Constants for event names - maintain backward compatibility
⋮----
// Export the full middleware system
</file>

<file path="electron/managers/index.ts">
/**
 * Barrel export for manager classes.
 * Provides a single entry point for importing manager classes.
 */
⋮----
// Export validators
</file>

<file path="electron/managers/validators/index.ts">
/**
 * Barrel export for validator classes.
 * Provides convenient access to all validation functionality.
 */
</file>

<file path="electron/services/application/index.ts">
/**
 * Application services barrel export.
 * Provides access to the main application orchestration service.
 */
</file>

<file path="electron/services/database/index.ts">
/**
 * Database services barrel export.
 * Provides access to all database services and repositories for data persistence.
 */
</file>

<file path="electron/services/database/utils/databaseBackup.ts">
import { logger } from "../../../utils/index";
/**
 * Database backup utilities.
 */
/**
 * Download database backup as buffer.
 */
export async function createDatabaseBackup(dbPath: string): Promise<
</file>

<file path="electron/services/database/utils/historyQuery.ts">
import { Database } from "node-sqlite3-wasm";
import { StatusHistory } from "../../../types";
import { logger } from "../../../utils/index";
import { rowToHistoryEntry } from "./historyMapper";
/**
 * Utility functions for querying history data from the database.
 */
/**
 * Find all history entries for a specific monitor.
 */
export function findHistoryByMonitorId(db: Database, monitorId: string): StatusHistory[]
/**
 * Get the count of history entries for a monitor.
 */
export function getHistoryCount(db: Database, monitorId: string): number
/**
 * Get the most recent history entry for a monitor.
 */
export function getLatestHistoryEntry(db: Database, monitorId: string): StatusHistory | undefined
</file>

<file path="electron/services/database/utils/valueConverters.ts">
/**
 * Database value conversion utilities.
 * Provides type-safe conversions between application types and database values.
 */
/**
 * Type for database parameter values.
 */
export type DbValue = string | number | null;
/**
 * Safely convert a value to number or return undefined.
 */
export function safeNumberConvert(value: unknown): number | undefined
/**
 * Convert a date-like value to ISO string or null for database storage.
 */
export function convertDateForDb(value: Date | string | null | undefined): string | null
/**
 * Add a string field to update arrays if the value is defined.
 */
export function addStringField(
    fieldName: string,
    value: string | undefined,
    updateFields: string[],
    updateValues: DbValue[]
): void
/**
 * Add a number field to update arrays if the value is defined.
 */
export function addNumberField(
    fieldName: string,
    value: number | undefined,
    updateFields: string[],
    updateValues: DbValue[]
): void
/**
 * Add a boolean field to update arrays if the value is defined.
 */
export function addBooleanField(
    fieldName: string,
    value: boolean | undefined,
    updateFields: string[],
    updateValues: DbValue[]
): void
</file>

<file path="electron/services/ipc/index.ts">
/**
 * IPC (Inter-Process Communication) services barrel export.
 * Provides access to communication between main and renderer processes.
 */
</file>

<file path="electron/services/monitoring/AdvancedValidationEngine.ts">
/**
 * Advanced validation rule composition system with async validation
 * and cross-field validation dependencies.
 */
/* eslint-disable security/detect-object-injection */
// ^ Dynamic object access is required for flexible validation rule composition
// This is a controlled environment where property names come from validated sources
import { z } from "zod";
import validator from "validator";
import { logger } from "../../utils/logger";
import type { MonitorType } from "../../types";
/**
 * Validation context for cross-field validation
 */
export interface ValidationContext {
    /** Current field being validated */
    currentField: string;
    /** All field values */
    allFields: Record<string, unknown>;
    /** Monitor type */
    monitorType: MonitorType;
    /** Previous validation results */
    previousResults: ValidationResult[];
    /** Additional context data */
    context?: Record<string, unknown>;
}
⋮----
/** Current field being validated */
⋮----
/** All field values */
⋮----
/** Monitor type */
⋮----
/** Previous validation results */
⋮----
/** Additional context data */
⋮----
/**
 * Validation result with detailed information
 */
export interface ValidationResult {
    /** Field name */
    field: string;
    /** Validation success */
    success: boolean;
    /** Error messages */
    errors: string[];
    /** Warnings (non-blocking) */
    warnings: string[];
    /** Validation metadata */
    metadata?: Record<string, unknown>;
    /** Execution time in milliseconds */
    executionTime?: number;
}
⋮----
/** Field name */
⋮----
/** Validation success */
⋮----
/** Error messages */
⋮----
/** Warnings (non-blocking) */
⋮----
/** Validation metadata */
⋮----
/** Execution time in milliseconds */
⋮----
/**
 * Async validation function type
 */
export type AsyncValidationFunction = (
    value: unknown,
    context: ValidationContext
) => Promise<{
    success: boolean;
    errors: string[];
    warnings: string[];
    metadata?: Record<string, unknown>;
}>;
/**
 * Cross-field validation rule
 */
export interface CrossFieldValidationRule {
    /** Rule name */
    name: string;
    /** Fields this rule depends on */
    dependsOn: string[];
    /** Validation function */
    validate: AsyncValidationFunction;
    /** Rule priority (lower = higher priority) */
    priority: number;
    /** Whether this rule is async */
    isAsync: boolean;
}
⋮----
/** Rule name */
⋮----
/** Fields this rule depends on */
⋮----
/** Validation function */
⋮----
/** Rule priority (lower = higher priority) */
⋮----
/** Whether this rule is async */
⋮----
/**
 * Validation rule composition
 */
export interface ValidationRuleComposition {
    /** Field-specific rules */
    fieldRules: Record<string, z.ZodSchema[]>;
    /** Cross-field validation rules */
    crossFieldRules: CrossFieldValidationRule[];
    /** Async validation rules */
    asyncRules: AsyncValidationFunction[];
    /** Rule dependencies */
    dependencies: Record<string, string[]>;
}
⋮----
/** Field-specific rules */
⋮----
/** Cross-field validation rules */
⋮----
/** Async validation rules */
⋮----
/** Rule dependencies */
⋮----
/**
 * Validation rule builder for fluent API
 */
export class ValidationRuleBuilder {
⋮----
/**
     * Add field validation rule
     */
addFieldRule(fieldName: string, rule: z.ZodSchema): this
/**
     * Add cross-field validation rule
     */
addCrossFieldRule(rule: CrossFieldValidationRule): this
⋮----
// Update dependencies
⋮----
/**
     * Add async validation rule
     */
addAsyncRule(rule: AsyncValidationFunction): this
/**
     * Add dependency between fields
     */
addDependency(field: string, dependsOn: string[]): this
/**
     * Build the validation composition
     */
build(): ValidationRuleComposition
⋮----
/**
 * Advanced validation engine with async and cross-field support
 */
export class AdvancedValidationEngine {
⋮----
/**
     * Register validation rules for a monitor type
     */
registerRules(monitorType: MonitorType, composition: ValidationRuleComposition): void
/**
     * Validate monitor data with comprehensive validation
     */
async validateMonitorData(
        monitorType: MonitorType,
        data: Record<string, unknown>
): Promise<
⋮----
// 1. Field-level validation
⋮----
// 2. Cross-field validation
⋮----
// 3. Async validation
⋮----
// Collect all errors and warnings
⋮----
/**
     * Validate individual fields
     */
private validateFields(
        _monitorType: MonitorType,
        data: Record<string, unknown>,
        composition: ValidationRuleComposition
): ValidationResult[]
/**
     * Validate cross-field dependencies
     */
private async validateCrossFields(
        monitorType: MonitorType,
        data: Record<string, unknown>,
        composition: ValidationRuleComposition
): Promise<ValidationResult[]>
⋮----
// Sort rules by priority
⋮----
/**
     * Validate with async rules
     */
private async validateAsync(
        monitorType: MonitorType,
        data: Record<string, unknown>,
        composition: ValidationRuleComposition
): Promise<ValidationResult[]>
/**
     * Clear validation cache
     */
clearCache(): void
/**
     * Get validation rules for a monitor type
     */
getRules(monitorType: MonitorType): ValidationRuleComposition | undefined
⋮----
/**
 * Pre-built validation rules for common scenarios
 */
⋮----
/**
     * URL validation with detailed error reporting
     */
⋮----
// Use validator.js for robust URL validation
⋮----
// Additional check for HTTPS vs HTTP
⋮----
/**
     * Port range validation
     */
⋮----
// Check for well-known ports
⋮----
/**
     * Host validation with detailed error reporting
     */
⋮----
// Use validator.js for robust host validation
⋮----
// Check for valid FQDN
⋮----
// Check for localhost (special case)
⋮----
// Export singleton instance
</file>

<file path="electron/services/monitoring/DatabaseSchemaMigrator.ts">
/**
 * Sophisticated database schema migration system for monitor types.
 * Handles version tracking, field type coercion, and migration strategies.
 */
/* eslint-disable security/detect-object-injection */
// ^ Dynamic object access is required for flexible schema migration
// Property names come from validated migration configurations
import { logger } from "../../utils/logger";
import type { BaseMonitorConfig } from "./MonitorTypeRegistry";
/**
 * Database field type definitions with proper coercion
 */
⋮----
JSON: "TEXT", // JSON stored as TEXT
TIMESTAMP: "INTEGER", // Unix timestamp
⋮----
export type DatabaseFieldType = (typeof DatabaseFieldTypes)[keyof typeof DatabaseFieldTypes];
/**
 * Field migration strategy options
 */
export interface FieldMigrationStrategy {
    /** Strategy type */
    type: "add" | "remove" | "rename" | "transform";
    /** Old field name (for rename/transform) */
    oldName?: string;
    /** New field name */
    newName: string;
    /** Field type */
    fieldType: DatabaseFieldType;
    /** Default value for new fields */
    defaultValue?: unknown;
    /** Transformation function for complex migrations */
    transform?: (oldValue: unknown) => unknown;
    /** Validation function for new values */
    validate?: (value: unknown) => boolean;
}
⋮----
/** Strategy type */
⋮----
/** Old field name (for rename/transform) */
⋮----
/** New field name */
⋮----
/** Field type */
⋮----
/** Default value for new fields */
⋮----
/** Transformation function for complex migrations */
⋮----
/** Validation function for new values */
⋮----
/**
 * Monitor type version configuration
 */
export interface MonitorTypeVersion {
    /** Version number (semantic versioning) */
    version: string;
    /** Migration strategies for this version */
    migrations: FieldMigrationStrategy[];
    /** Breaking changes flag */
    isBreaking: boolean;
    /** Description of changes */
    description?: string;
}
⋮----
/** Version number (semantic versioning) */
⋮----
/** Migration strategies for this version */
⋮----
/** Breaking changes flag */
⋮----
/** Description of changes */
⋮----
/**
 * Migration log entry
 */
export interface MigrationLogEntry {
    version: string;
    type: string;
    timestamp: number;
    success: boolean;
    error?: string;
}
/**
 * Enhanced monitor type configuration with versioning
 */
export interface VersionedMonitorConfig extends BaseMonitorConfig {
    /** Version history for migrations */
    versionHistory: MonitorTypeVersion[];
    /** Current version */
    currentVersion: string;
    /** Schema evolution strategy */
    evolutionStrategy: "backward-compatible" | "breaking-changes-allowed";
}
⋮----
/** Version history for migrations */
⋮----
/** Current version */
⋮----
/** Schema evolution strategy */
⋮----
/**
 * Parse semantic version string
 */
function parseVersion(version: string): number[]
/**
 * Database schema migration manager
 */
export class DatabaseSchemaMigrator {
⋮----
/**
     * Apply migrations for a monitor type
     */
async applyMigrations(
        config: VersionedMonitorConfig,
        currentVersion: string,
        targetVersion: string
): Promise<
/**
     * Get migrations to apply between versions
     */
private getMigrationsToApply(
        versionHistory: MonitorTypeVersion[],
        currentVersion: string,
        targetVersion: string
): MonitorTypeVersion[]
⋮----
// Sort versions chronologically
⋮----
// No migrations needed or downgrade (not supported)
⋮----
// Return migrations to apply (exclusive of current, inclusive of target)
⋮----
/**
     * Apply a single migration
     */
private async applyMigration(monitorType: string, migration: MonitorTypeVersion): Promise<void>
/**
     * Map field type to SQL type
     */
private mapFieldTypeToSQL(fieldType: DatabaseFieldType): string
⋮----
return "INTEGER"; // SQLite stores booleans as integers
⋮----
/**
     * Add a new field to monitors
     */
private async addField(monitorType: string, strategy: FieldMigrationStrategy): Promise<void>
⋮----
// Get the database service (we'll need to inject it)
⋮----
// 1. Alter the database table to add the column
⋮----
// 2. Update existing records with the default value if provided
⋮----
// 3. Note: Monitor type schema updates would happen in the registry
⋮----
/**
     * Remove a field from monitors
     */
private async removeField(monitorType: string, strategy: FieldMigrationStrategy): Promise<void>
⋮----
// Get the database service
⋮----
// SQLite doesn't support DROP COLUMN directly, so we need to:
// 1. Create a new table without the column
// 2. Copy data from old table to new table
// 3. Drop old table and rename new table
⋮----
// Get current table schema
⋮----
// Filter out the column we want to remove
⋮----
// Create new table schema
⋮----
// Copy data to new table
⋮----
// Drop old table and rename new table
⋮----
/**
     * Rename a field in monitors
     */
private renameField(monitorType: string, strategy: FieldMigrationStrategy): Promise<void>
⋮----
// In a real implementation, this would:
// 1. Create new column with new name
// 2. Copy data from old column to new column
// 3. Remove old column
// 4. Update schema
⋮----
/**
     * Transform field values in monitors
     */
private transformField(monitorType: string, strategy: FieldMigrationStrategy): Promise<void>
⋮----
// In a real implementation, this would:
// 1. Read all existing values
// 2. Apply transformation function
// 3. Update with new values
// 4. Validate results
⋮----
/**
     * Compare semantic versions
     */
private compareVersions(a: string, b: string): number
/**
     * Get migration log
     */
getMigrationLog(): MigrationLogEntry[]
/**
     * Check if migration is applied
     */
isMigrationApplied(migrationId: string): boolean
⋮----
/**
 * Enhanced field type coercion with better error handling
 */
⋮----
/**
     * Coerce value to target type with comprehensive error handling
     */
coerceValue(
        value: unknown,
        targetType: DatabaseFieldType,
        fieldName: string
):
/**
     * Coerce to string with null/undefined handling
     */
coerceToString(value: unknown, fieldName: string)
/**
     * Coerce to number with range validation
     */
coerceToNumber(value: unknown, fieldName: string)
/**
     * Coerce to real number
     */
coerceToReal(value: unknown, fieldName: string)
/**
     * Coerce to boolean with comprehensive interpretation
     */
coerceToBoolean(value: unknown, fieldName: string)
/**
     * Coerce to JSON with validation
     */
coerceToJSON(value: unknown, fieldName: string)
⋮----
JSON.parse(value); // Validate JSON
⋮----
/**
     * Coerce to timestamp
     */
coerceToTimestamp(value: unknown, fieldName: string)
⋮----
// Export singleton instance
</file>

<file path="electron/services/monitoring/EnhancedTypeGuards.ts">
/**
 * Enhanced runtime type guards with better error messages
 * and improved generic type inference for dynamic fields.
 */
/* eslint-disable security/detect-object-injection */
// ^ Dynamic object access is required for flexible type validation
// Property names come from validated monitor configurations
import { z } from "zod";
import validator from "validator";
import { logger } from "../../utils/logger";
import type { MonitorType } from "../../types";
import type { BaseMonitorConfig } from "./MonitorTypeRegistry";
/**
 * Type guard result with detailed error information
 */
export interface TypeGuardResult<T = unknown> {
    success: boolean;
    value?: T;
    error?: string;
    details?: {
        expectedType: string;
        actualType: string;
        path?: string[];
        suggestions?: string[];
    };
}
/**
 * Runtime type validation context
 */
export interface RuntimeValidationContext {
    path: string[];
    fieldName: string;
    expectedType: string;
    actualValue: unknown;
    suggestions: string[];
}
/**
 * Enhanced runtime type guards with better error messages
 */
⋮----
/**
     * Validate monitor type with detailed error reporting
     */
validateMonitorType(value: unknown): TypeGuardResult<MonitorType>
⋮----
// Check against known monitor types
⋮----
/**
     * Validate URL with comprehensive error reporting
     */
validateURL(value: unknown): TypeGuardResult<string>
⋮----
// Use validator.js for proper URL validation
⋮----
/**
     * Validate hostname with detailed error reporting
     */
validateHostname(value: unknown): TypeGuardResult<string>
⋮----
// Check for valid IP address first
⋮----
// Check for valid FQDN (domain name)
⋮----
// Additional check for localhost
⋮----
/**
     * Validate port number with range checking
     */
validatePort(value: unknown): TypeGuardResult<number>
⋮----
// Use validator.js for port validation
⋮----
/**
     * Validate boolean value with flexible interpretation
     */
validateBoolean(value: unknown): TypeGuardResult<boolean>
⋮----
/**
 * Generic type inference helper for dynamic fields
 */
⋮----
/**
     * Infer field type from monitor configuration
     */
inferFieldType<T extends BaseMonitorConfig>(
        config: T,
        fieldName: string
):
/**
     * Create typed field accessor with runtime validation
     */
createTypedAccessor<T extends BaseMonitorConfig>(
        config: T,
        fieldName: string
):
⋮----
/**
 * Type-safe monitor data interface with runtime validation
 */
export interface TypeSafeMonitorData<T extends MonitorType> {
    type: T;
    [K: string]: unknown;
}
/**
 * Enhanced monitor data builder with type safety
 */
export class TypeSafeMonitorBuilder<T extends MonitorType> {
⋮----
constructor(monitorType: T)
/**
     * Set field value with runtime validation
     */
setField<K extends string>(fieldName: K, value: unknown): TypeSafeMonitorBuilder<T>
⋮----
// Validate field based on monitor type
⋮----
/**
     * Get field value with type checking
     */
getField<K extends string>(fieldName: K): TypeGuardResult<unknown>
/**
     * Build the monitor data with validation
     */
build(): TypeGuardResult<TypeSafeMonitorData<T>>
/**
     * Validate individual field
     */
private validateField(fieldName: string, value: unknown): TypeGuardResult<unknown>
⋮----
// Basic validation based on monitor type
⋮----
// Default validation for common fields
⋮----
// Allow any other fields
⋮----
/**
 * Type-safe monitor factory with enhanced error reporting
 */
⋮----
/**
     * Create a typed monitor builder
     */
create<T extends MonitorType>(monitorType: T): TypeSafeMonitorBuilder<T>
/**
     * Validate existing monitor data
     */
validate<T extends MonitorType>(data: unknown): TypeGuardResult<TypeSafeMonitorData<T>>
</file>

<file path="electron/services/monitoring/index.ts">
/**
 * Monitoring services barrel export.
 * Provides access to all monitoring-related services, factories, and types.
 */
</file>

<file path="electron/services/monitoring/MigrationSystem.ts">
/**
 * Basic migration system for monitor types.
 * Simple, functional implementation without over-complexity.
 */
import { logger } from "../../utils/logger";
export interface MigrationRule {
    fromVersion: string;
    toVersion: string;
    description: string;
    isBreaking: boolean;
    transform: (data: Record<string, unknown>) => Promise<Record<string, unknown>>;
}
export interface VersionInfo {
    version: string;
    timestamp: number;
    applied: boolean;
}
/**
 * Simple migration registry
 */
class MigrationRegistry {
⋮----
/**
     * Register a migration for a monitor type
     */
registerMigration(monitorType: string, rule: MigrationRule): void
⋮----
// Sort by version
⋮----
/**
     * Get migration path from one version to another
     */
getMigrationPath(monitorType: string, fromVersion: string, toVersion: string): MigrationRule[]
/**
     * Check if migration is possible
     */
canMigrate(monitorType: string, fromVersion: string, toVersion: string): boolean
/**
     * Compare semantic versions
     */
private compareVersions(a: string, b: string): number
⋮----
// eslint-disable-next-line security/detect-object-injection
⋮----
// eslint-disable-next-line security/detect-object-injection
⋮----
/**
 * Simple version manager
 */
class VersionManager {
⋮----
/**
     * Set version for a monitor type
     */
setVersion(monitorType: string, version: string): void
/**
     * Get version for a monitor type
     */
getVersion(monitorType: string): string | undefined
/**
     * Check if version is applied
     */
isVersionApplied(monitorType: string, version: string): boolean
/**
     * Get all versions
     */
getAllVersions(): Map<string, VersionInfo>
⋮----
/**
 * Basic migration orchestrator
 */
class MigrationOrchestrator {
⋮----
constructor(
/**
     * Migrate monitor data from one version to another
     */
async migrateMonitorData(
        monitorType: string,
        data: Record<string, unknown>,
        fromVersion: string,
        toVersion: string
): Promise<
⋮----
// Check if migration is needed
⋮----
// Get migration path
⋮----
// Apply migrations in sequence
⋮----
// Update version if all migrations succeeded
⋮----
// Export singleton instances
⋮----
// Export factory function for orchestrator
export function createMigrationOrchestrator(): MigrationOrchestrator
// Export example migrations for reference
⋮----
// Example: HTTP monitor adding timeout field
⋮----
timeout: (data.timeout as number | undefined) ?? 30_000, // Default 30 seconds
⋮----
// Example: Port monitor converting port to number
</file>

<file path="electron/services/monitoring/utils/errorHandling.ts">
/**
 * HTTP monitoring error handling utilities.
 * Provides standardized error processing for HTTP monitors.
 */
import axios, { AxiosError } from "axios";
import { isDev } from "../../../electronUtils";
import { logger } from "../../../utils/index";
import { MonitorCheckResult } from "../types";
/**
 * Create a standard error result.
 */
export function createErrorResult(error: string, responseTime: number): MonitorCheckResult
/**
 * Handle errors that occur during health checks.
 */
export function handleCheckError(error: unknown, url: string): MonitorCheckResult
⋮----
// Non-Axios errors (shouldn't happen, but just in case)
⋮----
/**
 * Handle Axios-specific errors.
 */
export function handleAxiosError(error: AxiosError, url: string, responseTime: number): MonitorCheckResult
⋮----
// With validateStatus: () => true, we should only get network errors here
// HTTP response errors are handled in the success path
// Network errors, timeouts, DNS failures, etc.
</file>

<file path="electron/services/monitoring/utils/httpClient.ts">
/**
 * Axios configuration utilities for HTTP monitoring.
 * Provides standardized HTTP client setup and interceptors.
 */
import axios, { AxiosInstance } from "axios";
⋮----
import { MonitorConfig } from "../types";
/**
 * Create a configured Axios instance for HTTP monitoring.
 */
export function createHttpClient(config: MonitorConfig): AxiosInstance
⋮----
// Connection pooling for better performance
⋮----
maxBodyLength: 1024, // 1KB request limit (monitoring shouldn't send much data)
maxContentLength: 10 * 1024 * 1024, // 10MB response limit
⋮----
responseType: "text", // We only need status codes, not parsed data
// Custom status validation - all HTTP responses (including errors) are "successful" for axios
// This allows us to handle status code logic manually in our monitoring logic
⋮----
// Always treat as successful so we get response in success path, not error path
// We'll manually determine up/down status based on status codes
⋮----
// Set up interceptors for timing measurement
⋮----
/**
 * Set up request and response interceptors for timing measurement.
 */
export function setupTimingInterceptors(axiosInstance: AxiosInstance): void
⋮----
// Add request interceptor to record start time
⋮----
// Use a more precise timing method
⋮----
// Add response interceptor to calculate duration
⋮----
// Also calculate timing for error responses
</file>

<file path="electron/services/monitoring/utils/httpStatusUtils.ts">
/**
 * HTTP status code utilities for monitoring.
 * Provides logic for determining monitor status based on HTTP response codes.
 */
/**
 * Determine monitor status based on HTTP status code.
 *
 * Business rules:
 * - 2xx = success (up)
 * - 4xx = client error but site is responding (up)
 * - 5xx = server error (down)
 * - 3xx redirects or other unexpected codes (up - site is responding)
 */
export function determineMonitorStatus(httpStatus: number): "up" | "down"
⋮----
// 2xx = success (up)
⋮----
// 4xx = client error but site is responding (up)
⋮----
// 5xx = server error (down)
⋮----
// 3xx redirects or other unexpected codes (up - site is responding)
</file>

<file path="electron/services/monitoring/utils/index.ts">
/**
 * Monitoring utilities index file.
 * Exports all monitoring utility functions for easy importing.
 */
// HTTP monitoring utilities
⋮----
// Port monitoring utilities
</file>

<file path="electron/services/monitoring/utils/portChecker.ts">
import isPortReachable from "is-port-reachable";
import { isDev } from "../../../electronUtils";
import { logger } from "../../../utils/index";
import { MonitorCheckResult } from "../types";
import { PORT_NOT_REACHABLE, PortCheckError } from "./portErrorHandling";
/**
 * Utility functions for performing port connectivity checks.
 */
/**
 * Perform a single port check attempt without retry logic.
 */
export async function performSinglePortCheck(host: string, port: number, timeout: number): Promise<MonitorCheckResult>
⋮----
// Port not reachable - throw error with response time to trigger retry
</file>

<file path="electron/services/monitoring/utils/portErrorHandling.ts">
/**
 * Port monitoring error classes and constants.
 */
import { isDev } from "../../../electronUtils";
import { logger } from "../../../utils/index";
/**
 * Constants for port monitor error messages.
 */
⋮----
/**
 * Custom error class that preserves response time information from failed port checks.
 */
export class PortCheckError extends Error {
⋮----
constructor(message: string, responseTime: number)
⋮----
/**
 * Handle errors that occur during port checks.
 */
export function handlePortCheckError(
    error: unknown,
    host: string,
    port: number
):
⋮----
// Extract response time from custom error if available
⋮----
// Log debug information in development mode
</file>

<file path="electron/services/monitoring/utils/portRetry.ts">
import { RETRY_BACKOFF } from "../../../constants";
import { isDev } from "../../../electronUtils";
import { logger, withRetry } from "../../../utils/index";
import { MonitorCheckResult } from "../types";
import { performSinglePortCheck } from "./portChecker";
import { handlePortCheckError } from "./portErrorHandling";
/**
 * Utility functions for performing port checks with retry logic.
 */
/**
 * Perform port check with retry logic.
 */
export async function performPortCheckWithRetry(
    host: string,
    port: number,
    timeout: number,
    maxRetries: number
): Promise<MonitorCheckResult>
⋮----
// Convert maxRetries (additional attempts) to totalAttempts for withRetry utility
</file>

<file path="electron/services/notifications/index.ts">
/**
 * Notification services barrel export.
 * Provides access to system notification management and configuration.
 */
</file>

<file path="electron/services/updater/AutoUpdaterService.ts">
/**
 * Auto-updater service for the Uptime Watcher application.
 * Handles automatic application updates using electron-updater.
 */
import { autoUpdater } from "electron-updater";
import { logger } from "../../utils/index";
/**
 * Status of the application update process.
 */
export type UpdateStatus = "idle" | "checking" | "available" | "downloading" | "downloaded" | "error";
/**
 * Data structure for update status information.
 */
export interface UpdateStatusData {
    status: UpdateStatus;
    error?: string;
}
/**
 * Service responsible for handling application auto-updates.
 * Manages update checking, downloading, and installation.
 */
export class AutoUpdaterService {
⋮----
/**
     * Set the callback for update status changes.
     */
public setStatusCallback(callback: (statusData: UpdateStatusData) => void): void
/**
     * Initialize the auto-updater with event listeners.
     */
public initialize(): void
/**
     * Check for updates and notify if available.
     */
public async checkForUpdates(): Promise<void>
/**
     * Quit the application and install the update.
     */
public quitAndInstall(): void
/**
     * Notify status change callback if set.
     */
private notifyStatusChange(statusData: UpdateStatusData): void
</file>

<file path="electron/services/updater/index.ts">
/**
 * Auto-updater services barrel export.
 * Provides access to application update management and status tracking.
 */
</file>

<file path="electron/services/window/index.ts">
/**
 * Window management services barrel export.
 * Provides access to electron window creation and management utilities.
 */
</file>

<file path="electron/utils/correlation.ts">
/**
 * Correlation ID utilities for tracking operations across the application.
 * Provides unique identifiers for request/operation tracking and debugging.
 */
import { randomBytes } from "node:crypto";
/**
 * Generate a unique correlation ID for tracking operations.
 * Uses crypto.randomBytes for cryptographically secure random values.
 *
 * @returns A unique correlation ID string
 */
export function generateCorrelationId(): string
/**
 * Validation error class for business rule violations.
 * Extends Error with additional validation context.
 */
export class ValidationError extends Error {
⋮----
constructor(public errors: string[])
</file>

<file path="electron/utils/monitoring/autoMonitorManager.ts">
/**
 * Auto-monitor management utilities.
 * Handles automatic monitoring startup for sites and monitors.
 */
import type { Site } from "../../types";
interface Logger {
    debug: (message: string, ...args: unknown[]) => void;
    error: (message: string, error?: unknown, ...args: unknown[]) => void;
    info: (message: string, ...args: unknown[]) => void;
    warn: (message: string, ...args: unknown[]) => void;
}
/**
 * Automatically starts monitoring for all monitors in a site.
 * This utility function starts monitoring for new monitors that have been added.
 *
 * @param site - Site object with monitors to start
 * @param startMonitoringCallback - Callback function to start monitoring
 * @param logger - Logger instance for debug/info messages
 * @param isDev - Function to check if in development mode
 */
export async function autoStartMonitoring(
    site: Site,
    startMonitoringCallback: (siteIdentifier: string, monitorId?: string) => Promise<unknown>,
    logger: Logger,
    isDev: () => boolean
): Promise<void>
</file>

<file path="electron/utils/monitoring/index.ts">
/**
 * Monitoring utilities index file.
 * Exports all monitoring utility functions for easy importing.
 */
// Monitor lifecycle management - consolidated
⋮----
// Monitor validation and checks
⋮----
// Monitor status checking
⋮----
// Auto-monitoring management
⋮----
// Interval management
</file>

<file path="electron/utils/monitoring/intervalManager.ts">
/**
 * Interval management utilities for monitors.
 * Handles setting and managing monitor check intervals.
 */
import type { Site } from "../../types";
interface Logger {
    debug: (message: string, ...args: unknown[]) => void;
    error: (message: string, error?: unknown, ...args: unknown[]) => void;
    info: (message: string, ...args: unknown[]) => void;
    warn: (message: string, ...args: unknown[]) => void;
}
/**
 * Sets default check intervals for monitors that don't have one specified.
 * This utility function ensures all monitors have a check interval set.
 *
 * @param site - Site object with monitors to process
 * @param defaultInterval - Default interval to apply in milliseconds
 * @param updateMonitorCallback - Callback to update monitor in database
 * @param logger - Logger instance for debug/info messages
 */
export async function setDefaultMonitorIntervals(
    site: Site,
    defaultInterval: number,
    updateMonitorCallback: (monitorId: string, updates: { checkInterval: number }) => Promise<void>,
    logger: Logger
): Promise<void>
</file>

<file path="electron/utils/monitoring/monitorValidator.ts">
/**
 * Monitor validation utilities.
 * Handles initial monitor checks and validation operations.
 */
import type { Site } from "../../types";
interface Logger {
    debug: (message: string, ...args: unknown[]) => void;
    error: (message: string, error?: unknown, ...args: unknown[]) => void;
    info: (message: string, ...args: unknown[]) => void;
    warn: (message: string, ...args: unknown[]) => void;
}
/**
 * Performs initial monitor checks for all monitors in a site.
 * This utility function runs an initial check on all monitors when a site is added.
 *
 * @param site - Site object with monitors to check
 * @param checkMonitorCallback - Callback function to perform monitor checks
 * @param logger - Logger instance for debug/info messages
 */
export async function performInitialMonitorChecks(
    site: Site,
    checkMonitorCallback: (site: Site, monitorId: string) => Promise<unknown>,
    logger: Logger
): Promise<void>
</file>

<file path="src/components/AddSiteForm/FormFields.tsx">
/**
 * Form field components for the AddSiteForm.
 * Provides reusable, accessible form inputs with consistent styling and validation.
 * Includes text inputs, select dropdowns, and radio groups.
 */
import React from "react";
import { ThemedInput, ThemedSelect, ThemedText } from "../../theme";
/** Suffix for required field accessibility labels */
⋮----
/**
 * Create accessible aria-label with required indicator.
 * @param label - Base label text
 * @param required - Whether field is required
 * @returns Formatted aria-label string
 */
const createAriaLabel = (label: string, required: boolean): string => `$
/**
 * Determine the appropriate aria-describedby value based on error and help text.
 * @param id - The field ID for generating the describedby value
 * @param error - Error message if present
 * @param helpText - Help text if present
 * @returns The aria-describedby value or undefined
 */
const getAriaDescribedBy = (id: string, error?: string, helpText?: string): string | undefined =>
/** Props for the base FormField wrapper component */
export interface FormFieldProperties {
    /** Form input element(s) to wrap */
    children: React.ReactNode;
    /** Error message to display */
    error?: string;
    /** Help text to show below the field */
    helpText?: string;
    /** Unique ID for the form field */
    id: string;
    /** Label text to display */
    label: string;
    /** Whether the field is required */
    required?: boolean;
}
⋮----
/** Form input element(s) to wrap */
⋮----
/** Error message to display */
⋮----
/** Help text to show below the field */
⋮----
/** Unique ID for the form field */
⋮----
/** Label text to display */
⋮----
/** Whether the field is required */
⋮----
/**
 * Reusable form field wrapper with label, error handling, and accessibility features.
 * Provides consistent styling and behavior for all form inputs.
 *
 * @param props - FormField component props
 * @returns JSX element containing labeled form field with error/help text
 */
⋮----
/** Props for the TextField component */
⋮----
/** Whether the field is disabled */
⋮----
/** Error message to display */
⋮----
/** Help text to show below the field */
⋮----
/** Unique ID for the input field */
⋮----
/** Label text to display */
⋮----
/** Maximum value for number inputs */
⋮----
/** Minimum value for number inputs */
⋮----
/** Callback when value changes */
⋮----
/** Placeholder text for the input */
⋮----
/** Whether the field is required */
⋮----
/** Input type (text, url, or number) */
⋮----
/** Current field value */
⋮----
/**
 * Text input field component with proper accessibility and validation.
 * Supports different input types and provides consistent styling.
 *
 * @param props - TextField component props
 * @returns JSX element containing accessible text input field
 */
⋮----
/** Option interface for SelectField dropdown items */
export interface SelectOption {
    /** Display text for the option */
    label: string;
    /** Value to be selected */
    value: string | number;
}
⋮----
/** Display text for the option */
⋮----
/** Value to be selected */
⋮----
/** Props for the SelectField component */
export interface SelectFieldProperties {
    /** Whether the field is disabled */
    disabled?: boolean;
    /** Error message to display */
    error?: string;
    /** Help text to show below the field */
    helpText?: string;
    /** Unique ID for the select field */
    id: string;
    /** Label text to display */
    label: string;
    /** Callback when selection changes */
    onChange: (value: string) => void;
    /** Array of options to display in dropdown */
    options: SelectOption[];
    /** Placeholder text for empty selection */
    placeholder?: string;
    required?: boolean;
    value: string | number;
}
⋮----
/** Whether the field is disabled */
⋮----
/** Error message to display */
⋮----
/** Help text to show below the field */
⋮----
/** Unique ID for the select field */
⋮----
/** Label text to display */
⋮----
/** Callback when selection changes */
⋮----
/** Array of options to display in dropdown */
⋮----
/** Placeholder text for empty selection */
⋮----
onChange=
⋮----
/** Option interface for RadioGroup items */
⋮----
/** Display text for the radio option */
⋮----
/** Value to be selected */
⋮----
/** Props for the RadioGroup component */
⋮----
/** Whether the radio group is disabled */
⋮----
/** Error message to display */
⋮----
/** Help text to show below the field */
⋮----
/** Unique ID for the radio group */
⋮----
/** Label text to display */
⋮----
/** Name attribute for radio inputs (should be unique) */
⋮----
/** Callback when selection changes */
⋮----
/** Array of radio options to display */
⋮----
/** Whether a selection is required */
⋮----
/** Currently selected value */
⋮----
/**
 * RadioGroup component for selecting one option from multiple choices.
 * Provides an accessible radio button group with proper ARIA attributes and keyboard navigation.
 *
 * @example
 * ```tsx
 * <RadioGroup
 *   id="protocol"
 *   label="Protocol"
 *   name="protocol"
 *   value={formData.protocol}
 *   onChange={(value) => setFormData(prev => ({ ...prev, protocol: value }))}
 *   options={[
 *     { label: 'HTTP', value: 'http' },
 *     { label: 'HTTPS', value: 'https' }
 *   ]}
 *   required
 * />
 * ```
 */
</file>

<file path="src/components/common/index.ts">
/**
 * Common reusable components module exports.
 * Provides centralized access to shared UI components used throughout the application.
 */
// Export all common reusable components
</file>

<file path="src/components/common/StatusBadge.tsx">
/**
 * StatusBadge component for displaying status with optional icon and customizable styling.
 * Provides consistent status display throughout the application.
 */
import React from "react";
import { StatusIndicator, ThemedText } from "../../theme";
/** Props for the StatusBadge component */
interface StatusBadgeProperties {
    /** Label text to display */
    label: string;
    /** Current status to display */
    status: "up" | "down" | "pending" | "paused";
    /** Text size (affects both text and icon sizing) */
    size?: "xs" | "sm" | "base" | "lg" | "xl" | "2xl" | "3xl" | "4xl";
    /** Whether to show the status icon */
    showIcon?: boolean;
    /** Additional CSS classes */
    className?: string;
}
⋮----
/** Label text to display */
⋮----
/** Current status to display */
⋮----
/** Text size (affects both text and icon sizing) */
⋮----
/** Whether to show the status icon */
⋮----
/** Additional CSS classes */
⋮----
/**
 * Reusable status badge component that combines status indicator with text.
 * Can be used throughout the app for consistent status display.
 * Memoized for performance optimization.
 *
 * @param props - StatusBadge component props
 * @returns JSX element containing status indicator and text
 */
⋮----
/**
     * Maps text sizes to appropriate indicator sizes.
     * Ensures visual consistency between text and icon.
     *
     * @param textSize - The text size to map
     * @returns Corresponding indicator size
     */
const getIndicatorSize = (textSize: typeof size): "sm" | "md" | "lg" =>
</file>

<file path="src/components/Dashboard/index.ts">
/**
 * Dashboard components barrel export.
 * Provides centralized access to all dashboard-related components.
 */
// Main dashboard components
⋮----
// SiteCard sub-components
⋮----
// SiteList sub-components
⋮----
// SiteCard utility components
</file>

<file path="src/components/Dashboard/SiteCard/components/ActionButtonGroup.tsx">
/**
 * Action button group component for site monitoring operations.
 * Provides a unified interface for site check, start/stop monitoring actions.
 */
import React, { useCallback } from "react";
import { ThemedButton } from "../../../../theme";
/**
 * Props for the ActionButtonGroup component.
 */
interface ActionButtonGroupProperties {
    /** Callback function to trigger immediate site check */
    onCheckNow: () => void;
    /** Callback function to start monitoring */
    onStartMonitoring: () => void;
    /** Callback function to stop monitoring */
    onStopMonitoring: () => void;
    /** Whether any operation is currently loading */
    isLoading: boolean;
    /** Whether monitoring is currently active */
    isMonitoring: boolean;
    /** Whether all buttons should be disabled */
    disabled: boolean;
}
⋮----
/** Callback function to trigger immediate site check */
⋮----
/** Callback function to start monitoring */
⋮----
/** Callback function to stop monitoring */
⋮----
/** Whether any operation is currently loading */
⋮----
/** Whether monitoring is currently active */
⋮----
/** Whether all buttons should be disabled */
⋮----
/**
 * Reusable action button group component for site monitoring operations.
 *
 * Features:
 * - Unified interface for check now, start/stop monitoring actions
 * - Proper event handling with stopPropagation on individual buttons to prevent card click conflicts
 * - Optimized with React.memo and useCallback to prevent unnecessary re-renders
 * - Accessibility support with proper ARIA labels and native button elements
 * - Visual feedback for loading and disabled states
 *
 * @param props - Component props
 * @returns JSX element containing action buttons
 *
 * @example
 * ```tsx
 * <ActionButtonGroup
 *   onCheckNow={handleCheckNow}
 *   onStartMonitoring={handleStart}
 *   onStopMonitoring={handleStop}
 *   isLoading={false}
 *   isMonitoring={true}
 *   disabled={false}
 * />
 * ```
 */
⋮----
// Create individual wrapped handlers for each button with event propagation control
</file>

<file path="src/components/Dashboard/SiteCard/components/index.ts">
/**
 * SiteCard components barrel export.
 * Provides access to reusable components used within site cards.
 */
</file>

<file path="src/components/Dashboard/SiteCard/components/MetricCard.tsx">
/**
 * Reusable metric display card component.
 * Provides consistent formatting for displaying key performance metrics.
 */
import React from "react";
import { ThemedText } from "../../../../theme";
/**
 * Props for the MetricCard component.
 */
interface MetricCardProperties {
    /** Label text describing the metric */
    label: string;
    /** Value to display (string or number) */
    value: string | number;
    /** Optional CSS classes for custom styling */
    className?: string;
}
⋮----
/** Label text describing the metric */
⋮----
/** Value to display (string or number) */
⋮----
/** Optional CSS classes for custom styling */
⋮----
/**
 * Metric display card component for showing labeled values.
 *
 * Features:
 * - Consistent vertical layout with label above value
 * - Themed text components for unified styling
 * - Flexible value types (string or number)
 * - Optimized with React.memo to prevent unnecessary re-renders
 * - Customizable styling through className prop
 *
 * @param props - Component props
 * @returns JSX element containing the metric display
 *
 * @example
 * ```tsx
 * <MetricCard
 *   label="Uptime"
 *   value="98.5%"
 *   className="border-r"
 * />
 * ```
 */
</file>

<file path="src/components/Dashboard/SiteCard/components/MonitorSelector.tsx">
/**
 * Monitor selection dropdown component.
 * Provides interface for selecting between multiple monitors for a site.
 */
import React, { useCallback } from "react";
import { ThemedSelect } from "../../../../theme";
import { Monitor } from "../../../../types";
/**
 * Props for the MonitorSelector component.
 */
interface MonitorSelectorProperties {
    /** Array of available monitors to choose from */
    monitors: Monitor[];
    /** ID of the currently selected monitor */
    selectedMonitorId: string;
    /** Callback function for selection change events */
    onChange: (event: React.ChangeEvent<HTMLSelectElement>) => void;
    /** Optional CSS classes for custom styling */
    className?: string;
}
⋮----
/** Array of available monitors to choose from */
⋮----
/** ID of the currently selected monitor */
⋮----
/** Callback function for selection change events */
⋮----
/** Optional CSS classes for custom styling */
⋮----
/**
 * Monitor selection dropdown component for switching between site monitors.
 *
 * Features:
 * - Dynamic option formatting based on monitor type and configuration
 * - Event propagation control to prevent card click conflicts
 * - Optimized with React.memo and useCallback for performance
 * - Themed select component integration
 * - Supports HTTP and port monitor types with descriptive labels
 *
 * @param props - Component props
 * @returns JSX element containing the monitor selector dropdown
 *
 * @example
 * ```tsx
 * <MonitorSelector
 *   monitors={site.monitors}
 *   selectedMonitorId="monitor-1"
 *   onChange={handleMonitorChange}
 *   className="w-32"
 * />
 * ```
 */
⋮----
// Memoize event handlers to prevent recreation on every render
⋮----
// Memoize the option formatting to avoid recalculation
⋮----
const getDetail = () =>
</file>

<file path="src/components/Dashboard/SiteCard/SiteCardFooter.tsx">
/**
 * Site card footer component.
 * Provides visual hint for card interaction and navigation.
 */
import React from "react";
import { ThemedText } from "../../../theme";
/**
 * Footer section component for site cards with interactive hint text.
 *
 * Features:
 * - Hover-triggered opacity animation for subtle user guidance
 * - Consistent styling with top border separator
 * - Static content optimized with React.memo
 * - Responsive design with themed text components
 *
 * @returns JSX element containing the footer with interaction hint
 *
 * @example
 * ```tsx
 * <SiteCardFooter />
 * ```
 */
</file>

<file path="src/components/Dashboard/SiteCard/SiteCardHistory.tsx">
/**
 * Site card history visualization component.
 * Displays monitor history data using a chart component.
 */
import React, { useMemo } from "react";
import { Monitor, StatusHistory } from "../../../types";
import { HistoryChart } from "../../common/HistoryChart";
import { useMonitorTypes } from "../../../hooks/useMonitorTypes";
import { formatTitleSuffix } from "../../../utils/monitorTitleFormatters";
/**
 * Props for the SiteCardHistory component.
 */
interface SiteCardHistoryProperties {
    /** Monitor data containing type and configuration */
    monitor: Monitor | undefined;
    /** Filtered history data for visualization */
    filteredHistory: StatusHistory[];
}
⋮----
/** Monitor data containing type and configuration */
⋮----
/** Filtered history data for visualization */
⋮----
/**
 * History visualization component for site cards displaying monitor status over time.
 *
 * Features:
 * - Dynamic title generation based on monitor type and configuration
 * - Optimized with React.memo and custom comparison for performance
 * - Automatic updates when monitor history changes in store
 * - Supports up to 60 history items for visualization
 * - Handles HTTP and port monitor types with specific title formatting
 *
 * Data flow: Store → useSiteMonitor → useSite → SiteCard → SiteCardHistory
 *
 * @param props - Component props
 * @returns JSX element containing the history chart
 *
 * @example
 * ```tsx
 * <SiteCardHistory
 *   monitor={selectedMonitor}
 *   filteredHistory={recentHistory}
 * />
 * ```
 */
⋮----
// Get monitor type configurations
⋮----
// Memoize the history title calculation
⋮----
// Get display name from monitor type options
⋮----
// Get type-specific suffix using dynamic formatter
⋮----
// Custom comparison function to ensure proper re-renders
// Compare by history array length and last timestamp to detect changes
⋮----
// Fix: History is sorted DESC (newest first), so latest is at index 0, not length-1
⋮----
// Return true if nothing important changed (skip re-render)
</file>

<file path="src/components/Dashboard/SiteCard/SiteCardMetrics.tsx">
/**
 * Site card metrics display component.
 * Provides visual representation of key site monitoring statistics.
 */
import React, { useMemo } from "react";
import { MetricCard } from "./components/MetricCard";
/**
 * Props for the SiteCardMetrics component.
 */
interface SiteCardMetricsProperties {
    /** Current status of the site */
    status: string;
    /** Uptime percentage (0-100) */
    uptime: number;
    /** Average response time in milliseconds */
    responseTime?: number;
    /** Total number of checks performed */
    checkCount: number;
}
⋮----
/** Current status of the site */
⋮----
/** Uptime percentage (0-100) */
⋮----
/** Average response time in milliseconds */
⋮----
/** Total number of checks performed */
⋮----
/**
 * Metrics grid component displaying key site monitoring statistics.
 *
 * Features:
 * - Four-column grid layout for status, uptime, response time, and check count
 * - Optimized with React.memo and useMemo to prevent unnecessary re-renders
 * - Consistent metric card formatting
 * - Handles undefined response times gracefully
 *
 * @param props - Component props
 * @returns JSX element containing the metrics grid
 *
 * @example
 * ```tsx
 * <SiteCardMetrics
 *   status="up"
 *   uptime={98.5}
 *   responseTime={250}
 *   checkCount={144}
 * />
 * ```
 */
⋮----
// Memoize the computed values to avoid recalculation on every render
</file>

<file path="src/components/Dashboard/SiteCard/SiteCardStatus.tsx">
/**
 * Site card status display component.
 * Provides visual status indicator for site monitoring state.
 */
import React from "react";
import { StatusBadge } from "../../common/StatusBadge";
/**
 * Props for the SiteCardStatus component.
 */
interface SiteCardStatusProperties {
    /** ID of the currently selected monitor */
    selectedMonitorId: string;
    /** Current status of the monitor */
    status: "up" | "down" | "pending" | "paused";
}
⋮----
/** ID of the currently selected monitor */
⋮----
/** Current status of the monitor */
⋮----
/**
 * Status section component for site card displaying current monitor status.
 *
 * Features:
 * - Visual status indicator using StatusBadge component
 * - Monitor type identification in status label
 * - Optimized with React.memo to prevent unnecessary re-renders
 * - Consistent styling with theme system
 *
 * @param props - Component props
 * @returns JSX element containing the status badge
 *
 * @example
 * ```tsx
 * <SiteCardStatus
 *   selectedMonitorId="http"
 *   status="up"
 * />
 * ```
 */
</file>

<file path="src/components/Dashboard/SiteList/EmptyState.tsx">
/**
 * Empty state component for the site list dashboard
 *
 * Displays a friendly message and icon when no sites have been added yet,
 * encouraging users to add their first website to monitor.
 */
import { ThemedBox, ThemedText } from "../../../theme";
/**
 * Empty state component displayed when no sites are configured for monitoring.
 *
 * Shows a centered message with an icon to guide users towards adding their
 * first site. Uses themed components for consistent styling.
 *
 * @returns JSX element containing the empty state UI
 *
 * @example
 * ```tsx
 * function SiteList({ sites }) {
 *   if (sites.length === 0) {
 *     return <EmptyState />;
 *   }
 *   // Render site list items
 *   return <div>{sites.map(site => <SiteCard key={site.id} site={site} />)}</div>;
 * }
 * ```
 */
export function EmptyState()
</file>

<file path="src/components/Dashboard/SiteList/index.tsx">
/**
 * Site list component for the dashboard
 *
 * Displays a list of all configured sites as cards, or shows an empty state
 * when no sites have been added. Applies theme-aware styling with dividers.
 */
import { useSitesStore } from "../../../stores";
import { useTheme } from "../../../theme";
import { SiteCard } from "../SiteCard";
import { EmptyState } from "./EmptyState";
/**
 * Main site list component that displays all monitored sites.
 *
 * Renders either a list of SiteCard components (one per site) with dividers,
 * or an EmptyState component when no sites are configured. Automatically
 * applies theme-appropriate styling.
 *
 * @returns JSX element containing the site list or empty state
 *
 * @example
 * ```tsx
 * function Dashboard() {
 *   return (
 *     <div>
 *       <Header />
 *       <SiteList />
 *     </div>
 *   );
 * }
 * ```
 */
</file>

<file path="src/components/Header/index.ts">
/**
 * Header component barrel export.
 * Provides centralized access to header-related components.
 */
</file>

<file path="src/components/index.ts">
/**
 * Components barrel export.
 * Provides centralized access to all application components.
 */
// Common reusable components
⋮----
// Main application components
⋮----
// Site management components
⋮----
// Site details components
⋮----
// Dashboard components
</file>

<file path="src/components/Settings/index.ts">
/**
 * Settings component barrel export.
 * Provides centralized access to settings-related components.
 */
</file>

<file path="src/components/Settings/Settings.tsx">
/**
 * Application settings component
 *
 * Provides a comprehensive settings interface for configuring application
 * behavior, theme preferences, monitoring settings, and data management.
 * Includes data synchronization and SQLite backup functionality.
 */
import { useState, useEffect, useCallback } from "react";
import { HISTORY_LIMIT_OPTIONS, UI_DELAYS } from "../../constants";
import { logger } from "../../services";
import { useErrorStore, useSettingsStore, useSitesStore } from "../../stores";
import {
    ThemedBox,
    ThemedText,
    ThemedButton,
    StatusIndicator,
    ThemedSelect,
    ThemedCheckbox,
    ThemeName,
    useTheme,
} from "../../theme";
/** Props for the Settings component */
interface SettingsProperties {
    /** Callback function to close the settings modal/view */
    onClose: () => void;
}
⋮----
/** Callback function to close the settings modal/view */
⋮----
/**
 * Settings component providing comprehensive application configuration.
 *
 * Actual features available:
 * - Theme selection (light/dark/system)
 * - History retention limits (25-unlimited records)
 * - Desktop notifications (on/off)
 * - Sound alerts (on/off)
 * - Auto-start with system (on/off)
 * - Minimize to system tray (on/off)
 * - Data synchronization from SQLite backend
 * - SQLite database backup export
 * - Reset all settings to defaults
 *
 * @param props - Component props
 * @returns JSX element containing the settings interface
 */
⋮----
// Delayed loading state for button spinners (100ms delay)
⋮----
// Local state for sync success message
⋮----
return () => {}; // Return empty cleanup function for consistency
⋮----
// Only allow keys that are part of AppSettings
⋮----
const handleSettingChange = (key: keyof typeof settings, value: unknown) =>
⋮----
// eslint-disable-next-line security/detect-object-injection
⋮----
const handleHistoryLimitChange = async (limit: number) =>
⋮----
// Error is already handled by the store action
⋮----
const handleReset = () =>
⋮----
clearError(); // Clear any errors when resetting
⋮----
const handleThemeChange = (themeName: string) =>
// Manual Sync Now handler (moved from Header)
⋮----
const handleDownloadSQLite = async () =>
⋮----
{/* Header */}
⋮----
{/* Error Display */}
⋮----
{/* Sync Success Display */}
⋮----
{/* Content */}
⋮----
{/* Monitoring Settings */}
⋮----
{/* Notification Settings */}
⋮----
{/* Application Settings */}
⋮----
{/* Data Management */}
⋮----
{/* Sync Data Button */}
⋮----
{/* SQLite direct download */}
⋮----
{/* Footer */}
</file>

<file path="src/components/SiteDetails/index.ts">
/**
 * SiteDetails components barrel export.
 * Provides access to all site details-related components and utilities.
 */
⋮----
// Export tabs
</file>

<file path="src/components/SiteDetails/ScreenshotThumbnail.tsx">
/**
 * Screenshot thumbnail component with hover preview
 *
 * Displays a small thumbnail of a website screenshot that expands into a larger
 * preview on hover/focus. Uses Microlink API for screenshot generation and
 * React portals for the overlay positioning.
 */
import React, { useState, useRef, useEffect, useCallback } from "react";
import { createPortal } from "react-dom";
import { logger } from "../../services";
import { useTheme } from "../../theme";
/** Props for the ScreenshotThumbnail component */
interface ScreenshotThumbnailProperties {
    /** The URL to capture a screenshot of */
    readonly url: string;
    /** The site name for accessibility and alt text */
    readonly siteName: string;
}
⋮----
/** The URL to capture a screenshot of */
⋮----
/** The site name for accessibility and alt text */
⋮----
/**
 * Type guard to check if the window.electronAPI has openExternal method
 * @param api - The API object to check
 * @returns True if the API has openExternal method
 */
function hasOpenExternal(api: unknown): api is
/**
 * Screenshot thumbnail component with hover preview overlay.
 *
 * Generates a thumbnail using Microlink API and displays a larger preview
 * when hovered. Handles external URL opening and proper positioning of
 * the preview overlay within viewport bounds.
 *
 * @param props - Component props
 * @returns JSX element containing the thumbnail and optional preview overlay
 */
export function ScreenshotThumbnail(
⋮----
// Clean up portal overlay on unmount and state changes
⋮----
// Clear any pending timeouts
⋮----
// Clean up any portal element that might still be in the DOM
⋮----
function handleClick(event: React.MouseEvent)
⋮----
const maxImgW = Math.min(viewportW * 0.9, 900); // 90vw or 900px max
const maxImgH = Math.min(viewportH * 0.9, 700); // 90vh or 700px max
⋮----
let top = rect.top - overlayH - 16; // 16px gap above
⋮----
// Clear any pending timeouts when hiding overlay
⋮----
// Debounced hover handlers to prevent rapid state changes
⋮----
// Clear any existing timeout
⋮----
// Clear any existing timeout
⋮----
// Add a small delay to prevent flickering on rapid mouse movements
⋮----
// Clear any existing timeout
⋮----
// Clear any existing timeout
⋮----
// Generate accessible aria-label, handling empty URLs
</file>

<file path="src/components/SiteDetails/SiteDetailsNavigation.tsx">
/**
 * Site details navigation component for managing monitoring controls and tabs.
 * Provides a comprehensive interface for controlling site monitoring, managing intervals,
 * and navigating between different detail views.
 */
import React from "react";
import { logger } from "../../services";
import { ThemedBox, ThemedButton, ThemedSelect, ThemedText } from "../../theme";
import { Site } from "../../types";
/**
 * Props for the SiteDetailsNavigation component.
 * Contains all necessary handlers and state for monitoring control.
 */
interface SiteDetailsNavigationProperties {
    /** Currently active tab in the site details view */
    readonly activeSiteDetailsTab: string;
    /** The site object being displayed */
    readonly currentSite: Site;
    /** Handler for monitor selection changes */
    readonly handleMonitorIdChange: (event: React.ChangeEvent<HTMLSelectElement>) => void;
    /** Handler for starting monitoring */
    readonly handleStartMonitoring: () => Promise<void>;
    /** Handler for starting site-level monitoring */
    readonly handleStartSiteMonitoring: () => Promise<void>;
    /** Handler for stopping monitoring */
    readonly handleStopMonitoring: () => Promise<void>;
    /** Handler for stopping site-level monitoring */
    readonly handleStopSiteMonitoring: () => Promise<void>;
    /** Whether any async operation is in progress */
    readonly isLoading: boolean;
    /** Whether monitoring is currently active */
    readonly isMonitoring: boolean;
    /** Currently selected monitor ID */
    readonly selectedMonitorId: string;
    /** Function to set the active tab */
    readonly setActiveSiteDetailsTab: (tab: string) => void;
}
⋮----
/** Currently active tab in the site details view */
⋮----
/** The site object being displayed */
⋮----
/** Handler for monitor selection changes */
⋮----
/** Handler for starting monitoring */
⋮----
/** Handler for starting site-level monitoring */
⋮----
/** Handler for stopping monitoring */
⋮----
/** Handler for stopping site-level monitoring */
⋮----
/** Whether any async operation is in progress */
⋮----
/** Whether monitoring is currently active */
⋮----
/** Currently selected monitor ID */
⋮----
/** Function to set the active tab */
⋮----
/**
 * Navigation and control component for site details page.
 *
 * Features:
 * - Tab navigation for different views (Overview, History, Analytics, Settings)
 * - Monitor control buttons (Start/Stop monitoring, Check now)
 * - Monitor selection dropdown
 * - Check interval configuration
 * - Time range selection for charts
 *
 * @param props - Component props for navigation and control
 * @returns JSX element containing navigation controls
 */
⋮----
const logTabChange = (tab: string, additionalData?: Record<string, unknown>) =>
// Site-level monitoring state calculation
⋮----
// Button variant constants
⋮----
{/* Tab Navigation and Monitor Selection */}
⋮----
{/* Tab navigation buttons (left) */}
⋮----
{/* Render analytics tab for selected monitor type only */}
⋮----
{/* Monitor Selection and Site-level Controls (right) */}
⋮----
{/* Site-level monitoring controls */}
⋮----
{/* Individual monitor controls */}
⋮----
{/* Monitor Selection */}
</file>

<file path="src/components/SiteDetails/tabs/index.ts">
/**
 * SiteDetails tab components barrel export.
 * Provides unified access to all site detail tab components.
 */
</file>

<file path="src/constants.ts">
/**
 * Centralized constants for the Uptime Watcher application.
 * Contains configuration values, UI constants, and type definitions.
 */
/** Status types for site monitoring */
export type StatusType = "up" | "down" | "pending" | "unknown" | "paused" | "mixed";
/** Font family constants for theme reuse */
⋮----
/** Interface for interval options used in dropdowns */
export interface IntervalOption {
    value: number;
    label: string;
}
/**
 * Available check intervals for site monitoring.
 * Ranges from 5 seconds to 30 days with sensible progressions.
 */
⋮----
// Seconds
⋮----
// Minutes
⋮----
// Hours
⋮----
/** Default check interval (5 minutes) */
⋮----
/** Default request timeout (10 seconds) */
⋮----
/** Default request timeout in seconds for UI display (10 seconds) */
⋮----
/** Default history limit (500 records) */
⋮----
/** History limit options for controlling data retention */
⋮----
/** Request timeout constraints for HTTP monitoring */
⋮----
MAX: 300, // 300 seconds maximum (displayed to user)
MIN: 1, // 1 second minimum (displayed to user)
STEP: 1, // 1 second increments (displayed to user)
⋮----
/** Internal timeout constraints in milliseconds (for backend) */
⋮----
MAX: 300_000, // 300 seconds maximum
MIN: 1000, // 1 second minimum
STEP: 1000, // 1 second increments
⋮----
/** Retry attempt constraints for per-monitor retry configuration */
⋮----
DEFAULT: 0, // Default retry attempts (disabled)
MAX: 10, // 10 retry attempts maximum
MIN: 0, // 0 retries minimum (immediate failure)
STEP: 1, // 1 retry increment
⋮----
/** UI delays and timing to prevent flashing and improve UX */
⋮----
LOADING_BUTTON: 100, // Delay before showing loading spinners (ms)
LOADING_OVERLAY: 100, // Delay before showing loading overlay (ms)
⋮----
/** Chart time periods for analytics components (in milliseconds) */
⋮----
/** Common ARIA attribute constants for accessibility */
⋮----
/** Standard transition timing for smooth animations */
</file>

<file path="src/hooks/index.ts">
/**
 * Hooks barrel export.
 * Provides centralized access to all custom React hooks.
 */
// Site-related hooks
⋮----
// Application hooks
</file>

<file path="src/hooks/site/index.ts">
/**
 * Site-related hooks module exports.
 * Provides centralized access to all site monitoring and management hooks.
 */
// Export all site-related hooks
</file>

<file path="src/hooks/site/useSite.ts">
import { useErrorStore } from "../../stores";
import { Site } from "../../types";
import { useSiteActions } from "./useSiteActions";
import { useSiteMonitor } from "./useSiteMonitor";
import { useSiteStats } from "./useSiteStats";
/**
 * A comprehensive hook that combines site monitoring, actions, statistics, and UI state
 *
 * @param site - The site to work with
 * @returns Combined data and functionality from all site-related hooks
 */
export function useSite(site: Site)
⋮----
// Get monitor data
⋮----
// Get site statistics
⋮----
// Get action handlers
⋮----
// Get UI state from store for consistency
⋮----
// Return everything together
</file>

<file path="src/hooks/site/useSiteAnalytics.ts">
/**
 * Custom hook for calculating comprehensive site analytics and metrics
 *
 * Provides detailed analytics for a monitor including uptime percentages,
 * response time statistics, downtime analysis, and reliability metrics.
 * All calculations are memoized for performance optimization.
 */
import { useMemo } from "react";
import type { Theme } from "../../theme";
import { CHART_TIME_PERIODS } from "../../constants";
import { Monitor, StatusHistory } from "../../types";
import { type TimePeriod, TIME_PERIOD_LABELS } from "../../utils/time";
/** Represents a period of downtime with start, end, and duration */
export interface DowntimePeriod {
    /** Timestamp when downtime started */
    start: number;
    /** Timestamp when downtime ended */
    end: number;
    /** Duration of downtime in milliseconds */
    duration: number;
}
⋮----
/** Timestamp when downtime started */
⋮----
/** Timestamp when downtime ended */
⋮----
/** Duration of downtime in milliseconds */
⋮----
/** Comprehensive analytics data for a site monitor */
export interface SiteAnalytics {
    /** Total number of checks performed */
    totalChecks: number;
    /** Number of successful checks */
    upCount: number;
    /** Number of failed checks */
    downCount: number;
    /** Uptime percentage as formatted string */
    uptime: string;
    /** Average response time in milliseconds */
    avgResponseTime: number;
    /** Fastest response time recorded */
    fastestResponse: number;
    /** Slowest response time recorded */
    slowestResponse: number;
    /** 50th percentile response time */
    p50: number;
    /** 95th percentile response time */
    p95: number;
    /** 99th percentile response time */
    p99: number;
    /** Array of downtime periods */
    downtimePeriods: DowntimePeriod[];
    /** Total downtime in milliseconds */
    totalDowntime: number;
    /** Mean Time To Recovery in milliseconds */
    mttr: number;
    /** Number of separate downtime incidents */
    incidentCount: number;
    /** Status history filtered by time range */
    filteredHistory: StatusHistory[];
}
⋮----
/** Total number of checks performed */
⋮----
/** Number of successful checks */
⋮----
/** Number of failed checks */
⋮----
/** Uptime percentage as formatted string */
⋮----
/** Average response time in milliseconds */
⋮----
/** Fastest response time recorded */
⋮----
/** Slowest response time recorded */
⋮----
/** 50th percentile response time */
⋮----
/** 95th percentile response time */
⋮----
/** 99th percentile response time */
⋮----
/** Array of downtime periods */
⋮----
/** Total downtime in milliseconds */
⋮----
/** Mean Time To Recovery in milliseconds */
⋮----
/** Number of separate downtime incidents */
⋮----
/** Status history filtered by time range */
⋮----
/**
 * Hook for calculating comprehensive site analytics and metrics.
 *
 * Performs complex calculations on monitor data to provide detailed insights
 * including uptime statistics, response time analysis, and downtime patterns.
 * All calculations are memoized for optimal performance.
 *
 * @param monitor - The monitor to analyze (can be undefined)
 * @param timeRange - Time period to analyze (defaults to "24h")
 * @returns Comprehensive analytics object with all calculated metrics
 *
 * @example
 * ```tsx
 * function AnalyticsView({ monitor }) {
 *   const analytics = useSiteAnalytics(monitor, "7d");
 *
 *   return (
 *     <div>
 *       <p>Uptime: {analytics.uptime}</p>
 *       <p>Avg Response: {analytics.avgResponseTime}ms</p>
 *       <p>Incidents: {analytics.incidentCount}</p>
 *     </div>
 *   );
 * }
 * ```
 */
export function useSiteAnalytics(monitor: Monitor | undefined, timeRange: TimePeriod = "24h"): SiteAnalytics
⋮----
// Defensive: handle undefined monitor
⋮----
// Filter history based on time range
⋮----
// Sanitize timeRange to prevent object injection
⋮----
// eslint-disable-next-line security/detect-object-injection -- false positive: safeTimeRange is validated against allowedTimeRanges
⋮----
// Basic metrics
⋮----
// Performance metrics
⋮----
// Calculate percentiles
⋮----
const getPercentile = (p: number): number =>
⋮----
// Ensure p is between 0 and 1
⋮----
// eslint-disable-next-line security/detect-object-injection -- safeIdx is validated and sanitized
⋮----
// Calculate downtime periods
⋮----
// Process in reverse chronological order for proper downtime calculation
⋮----
// Handle ongoing downtime
⋮----
/**
 * Hook for generating chart data
 * Separates data preparation from component logic
 */
export function useChartData(monitor: Monitor, theme: Theme)
/**
 * Utility functions for common calculations
 */
⋮----
/**
     * Calculate SLA compliance
     */
calculateSLA(
        uptime: number,
        targetSLA = 99.9
):
/**
     * Get availability status based on uptime percentage
     */
getAvailabilityStatus(uptime: number): "excellent" | "good" | "warning" | "critical"
/**
     * Get performance status based on response time
     */
getPerformanceStatus(responseTime: number): "excellent" | "good" | "warning" | "critical"
</file>

<file path="src/hooks/site/useSiteMonitor.ts">
/**
 * Custom hook for managing site monitor selection and data.
 * Provides monitor state, statistics, and selection handling for sites.
 */
import { useMemo, useCallback } from "react";
import { useSitesStore } from "../../stores";
import { Monitor, Site, StatusHistory } from "../../types";
/**
 * Result interface for the useSiteMonitor hook.
 */
interface SiteMonitorResult {
    // Current state
    /** Most up-to-date site data from store */
    latestSite: Site;
    /** ID of the currently selected monitor */
    selectedMonitorId: string;
    /** Currently selected monitor object */
    monitor: Monitor | undefined;
    /** Current status of the selected monitor */
    status: "up" | "down" | "pending" | "paused";
    /** Response time of the selected monitor */
    responseTime: number | undefined;
    /** Whether the selected monitor is actively being monitored */
    isMonitoring: boolean;
    // Helpers
    /** Array of all monitor IDs for this site */
    monitorIds: string[];
    /** Filtered history for the selected monitor */
    filteredHistory: StatusHistory[];
    // Actions
    /** Handler for monitor selection changes */
    handleMonitorIdChange: (e: React.ChangeEvent<HTMLSelectElement>) => void;
}
⋮----
// Current state
/** Most up-to-date site data from store */
⋮----
/** ID of the currently selected monitor */
⋮----
/** Currently selected monitor object */
⋮----
/** Current status of the selected monitor */
⋮----
/** Response time of the selected monitor */
⋮----
/** Whether the selected monitor is actively being monitored */
⋮----
// Helpers
/** Array of all monitor IDs for this site */
⋮----
/** Filtered history for the selected monitor */
⋮----
// Actions
/** Handler for monitor selection changes */
⋮----
/**
 * Hook to manage monitor selection and state for a specific site
 *
 * @param site - The site object to monitor
 * @returns Monitor data and helper functions
 */
export function useSiteMonitor(site: Site): SiteMonitorResult
⋮----
// Always select the latest site from the store by id to ensure we have the most updated data
⋮----
// Get monitor selection info
⋮----
// Get the currently selected monitor
⋮----
// Extract monitor state information
⋮----
// Fix: Use history length and last timestamp as dependencies for proper memoization
⋮----
const isMonitoring = monitor?.monitoring !== false; // default to true if undefined
// Handler for changing the monitor - memoized to prevent recreation
</file>

<file path="src/hooks/site/useSiteStats.ts">
/**
 * Site statistics calculation hook.
 * Provides utilities for computing uptime, response time averages,
 * and check counts from monitor history data.
 */
import { useMemo } from "react";
import { StatusHistory } from "../../types";
interface SiteStats {
    averageResponseTime: number;
    checkCount: number;
    uptime: number;
}
/**
 * Custom hook to calculate statistics based on a monitor's history
 *
 * @param history - Array of status history records
 * @returns Object containing calculated statistics (uptime, checkCount, averageResponseTime)
 */
export function useSiteStats(history: StatusHistory[]): SiteStats
⋮----
// Memoize the calculations to avoid recalculating on every render
⋮----
// Calculate uptime percentage
⋮----
// Calculate average response time (only for successful "up" checks)
</file>

<file path="src/hooks/useThemeStyles.ts">
/**
 * Custom hook for theme-aware CSS-in-JS styles
 * Provides consistent styling that respects user's theme preference
 */
import { useMemo } from "react";
interface ThemeStyles {
    headerStyle: React.CSSProperties;
    contentStyle: React.CSSProperties;
    overlayStyle: React.CSSProperties;
    collapseButtonStyle: React.CSSProperties;
    titleStyle: React.CSSProperties;
    urlStyle: React.CSSProperties;
    metaStyle: React.CSSProperties;
}
export function useThemeStyles(isCollapsed = false): ThemeStyles
</file>

<file path="src/index.ts">
/**
 * Root barrel export for Uptime Watcher application.
 * Provides centralized access to all major application modules.
 */
// Application types (export these explicitly to avoid conflicts)
⋮----
// Core constants
⋮----
// Components
⋮----
// Custom hooks
⋮----
// State management stores (stores re-export types, so we avoid conflict by being explicit above)
⋮----
// Utility functions
⋮----
// Theme system
⋮----
// Services
</file>

<file path="src/main.tsx">
/**
 * Main entry point for the Uptime Watcher React application.
 * Sets up React root and renders the main App component with strict mode enabled.
 */
import React from "react";
import ReactDOM from "react-dom/client";
import App from "./App";
⋮----
/**
 * Initialize and render the React application.
 * Creates the React root and renders the App component with StrictMode for development benefits.
 */
</file>

<file path="src/services/index.ts">
/**
 * Services module barrel export.
 * Provides centralized access to all application services.
 */
// Logger service
⋮----
// Chart configuration
</file>

<file path="src/stores/error/ErrorBoundary.tsx">
/**
 * Error boundary component for store-related errors.
 * Provides fallback UI when store operations fail.
 */
import React from "react";
interface ErrorBoundaryState {
    hasError: boolean;
    error?: Error;
    errorInfo?: React.ErrorInfo;
}
interface ErrorBoundaryProperties {
    children: React.ReactNode;
    fallback?: React.ComponentType<{ error?: Error; retry: () => void }>;
    onError?: (error: Error, errorInfo: React.ErrorInfo) => void;
}
/**
 * Default fallback component for error boundary
 */
const DefaultErrorFallback: React.FC<{ error?: Error; retry: () => void }> = ({ error, retry }) => (
    <div className="flex flex-col items-center justify-center p-8 border border-red-200 rounded-lg bg-red-50">
        <div className="mb-4 text-red-600">
            <h2 className="mb-2 text-lg font-semibold">Something went wrong</h2>
            <p className="text-sm">
                {error?.message.trim() ? error.message : "An unexpected error occurred while loading this section."}
            </p>
        </div>
        <button onClick={retry} className="px-4 py-2 text-white transition-colors bg-red-600 rounded hover:bg-red-700">
            Try Again
        </button>
    </div>
);
/**
 * Error boundary component for wrapping store-connected components
 */
export class ErrorBoundary extends React.Component<ErrorBoundaryProperties, ErrorBoundaryState> {
⋮----
constructor(properties: ErrorBoundaryProperties)
static getDerivedStateFromError(error: Error): ErrorBoundaryState
override componentDidCatch(error: Error, errorInfo: React.ErrorInfo)
⋮----
// Call the onError prop if provided
⋮----
override render()
⋮----
/**
 * Higher-order component for wrapping components with error boundary
 */
export const withErrorBoundary = <P extends object>(
    Component: React.ComponentType<P>,
    fallback?: React.ComponentType<{ error?: Error; retry: () => void }>
) =>
⋮----
const WrappedComponent = (properties: P) => (
        <ErrorBoundary {...(fallback ? { fallback } : {})}>
            <Component {...properties} />
        </ErrorBoundary>
    );
</file>

<file path="src/stores/error/types.ts">
/**
 * Error store types and interfaces.
 */
export interface ErrorState {
    /** Last error message to display */
    lastError: string | undefined;
    /** Global loading state */
    isLoading: boolean;
    /** Store-specific error states */
    storeErrors: Record<string, string | undefined>;
    /** Loading states for specific operations */
    operationLoading: Record<string, boolean>;
}
⋮----
/** Last error message to display */
⋮----
/** Global loading state */
⋮----
/** Store-specific error states */
⋮----
/** Loading states for specific operations */
⋮----
export interface ErrorActions {
    /** Set global error message */
    setError: (error: string | undefined) => void;
    /** Set global loading state */
    setLoading: (loading: boolean) => void;
    /** Clear global error */
    clearError: () => void;
    /** Set error for specific store */
    setStoreError: (store: string, error: string | undefined) => void;
    /** Clear error for specific store */
    clearStoreError: (store: string) => void;
    /** Set loading state for specific operation */
    setOperationLoading: (operation: string, loading: boolean) => void;
    /** Clear all errors */
    clearAllErrors: () => void;
    /** Get error for specific store */
    getStoreError: (store: string) => string | undefined;
    /** Get loading state for specific operation */
    getOperationLoading: (operation: string) => boolean;
}
⋮----
/** Set global error message */
⋮----
/** Set global loading state */
⋮----
/** Clear global error */
⋮----
/** Set error for specific store */
⋮----
/** Clear error for specific store */
⋮----
/** Set loading state for specific operation */
⋮----
/** Clear all errors */
⋮----
/** Get error for specific store */
⋮----
/** Get loading state for specific operation */
⋮----
export type ErrorStore = ErrorState & ErrorActions;
</file>

<file path="src/stores/settings/types.ts">
/**
 * Settings store types and interfaces.
 * Manages application preferences and configuration.
 */
import type { AppSettings } from "../types";
/**
 * Settings store interface.
 * Manages user preferences and application configuration.
 */
export interface SettingsStore {
    // State
    /** Application settings */
    settings: AppSettings;
    // Actions
    /** Update multiple settings at once */
    updateSettings: (settings: Partial<AppSettings>) => void;
    /** Reset all settings to default values */
    resetSettings: () => void;
    /** Update history limit with backend sync */
    updateHistoryLimitValue: (limit: number) => Promise<void>;
    /** Initialize settings from backend */
    initializeSettings: () => Promise<{ success: boolean; settingsLoaded: boolean; message: string }>;
}
⋮----
// State
/** Application settings */
⋮----
// Actions
/** Update multiple settings at once */
⋮----
/** Reset all settings to default values */
⋮----
/** Update history limit with backend sync */
⋮----
/** Initialize settings from backend */
</file>

<file path="src/stores/settings/useSettingsStore.ts">
/**
 * Settings store for managing application preferences and configuration.
 * Handles user settings, theme preferences, and backend synchronization.
 */
import { create } from "zustand";
import { persist } from "zustand/middleware";
import type { AppSettings } from "../types";
import type { SettingsStore } from "./types";
import { DEFAULT_HISTORY_LIMIT } from "../../constants";
import { useErrorStore } from "../error/useErrorStore";
import { logStoreAction, withErrorHandling } from "../utils";
⋮----
// Actions
⋮----
// State
⋮----
// Call backend to update and prune history
⋮----
// Reload the value from backend to ensure sync
</file>

<file path="src/stores/sites/services/index.ts">
/**
 * Index file for sites store services.
 * Provides centralized exports for all services.
 */
</file>

<file path="src/stores/sites/services/MonitoringService.ts">
/**
 * Monitoring service layer for handling all monitoring-related operations.
 * Provides a clean abstraction over electron API calls.
 */
import { waitForElectronAPI } from "../../utils";
⋮----
/**
     * Initialize the service by ensuring electron API is available
     */
async initialize(): Promise<void>
/**
     * Start monitoring for a site
     */
async startMonitoring(siteId: string, monitorId: string): Promise<void>
/**
     * Start monitoring for all monitors of a site
     */
async startSiteMonitoring(siteId: string): Promise<void>
/**
     * Stop monitoring for a site
     */
async stopMonitoring(siteId: string, monitorId: string): Promise<void>
/**
     * Stop monitoring for all monitors of a site
     */
async stopSiteMonitoring(siteId: string): Promise<void>
</file>

<file path="src/stores/sites/services/SiteService.ts">
/**
 * Site service layer for handling all site-related operations.
 * Provides a clean abstraction over electron API calls.
 */
import type { Site } from "../../types";
import { waitForElectronAPI } from "../../utils";
⋮----
/**
     * Add a new site
     */
async addSite(site: Site): Promise<Site>
/**
     * Check a site now
     */
async checkSiteNow(siteId: string, monitorId: string): Promise<void>
/**
     * Download SQLite backup
     */
async downloadSQLiteBackup(): Promise<
/**
     * Get all sites from the backend
     */
async getSites(): Promise<Site[]>
/**
     * Initialize the service by ensuring electron API is available
     */
async initialize(): Promise<void>
/**
     * Remove a monitor from a site
     */
async removeMonitor(siteIdentifier: string, monitorId: string): Promise<void>
/**
     * Remove a site
     */
async removeSite(identifier: string): Promise<void>
/**
     * Update an existing site
     */
async updateSite(identifier: string, updates: Partial<Site>): Promise<void>
</file>

<file path="src/stores/sites/utils/index.ts">
/**
 * Index file for sites store utilities.
 * Provides centralized exports for all utilities and services.
 */
</file>

<file path="src/stores/stats/types.ts">
/**
 * Stats store types and interfaces.
 * Manages application statistics and computed metrics.
 */
import type { Site } from "../../types";
/**
 * Stats store interface.
 * Manages computed statistics and metrics.
 */
export interface StatsStore {
    // State
    /** Total uptime across all sites */
    totalUptime: number;
    /** Total downtime across all sites */
    totalDowntime: number;
    // Actions
    /** Update total uptime */
    setTotalUptime: (uptime: number) => void;
    /** Update total downtime */
    setTotalDowntime: (downtime: number) => void;
    /** Compute stats from sites data - accepts sites parameter to avoid cross-store dependencies */
    computeStats: (sites?: Site[]) => void;
    /** Reset all stats */
    resetStats: () => void;
}
⋮----
// State
/** Total uptime across all sites */
⋮----
/** Total downtime across all sites */
⋮----
// Actions
/** Update total uptime */
⋮----
/** Update total downtime */
⋮----
/** Compute stats from sites data - accepts sites parameter to avoid cross-store dependencies */
⋮----
/** Reset all stats */
</file>

<file path="src/stores/stats/useStatsStore.ts">
/**
 * Stats store for managing application statistics and computed metrics.
 * Handles uptime/downtime calculations and performance metrics.
 */
import { create } from "zustand";
import { persist } from "zustand/middleware";
import type { Site } from "../../types";
import type { StatsStore } from "./types";
import { logStoreAction } from "../utils";
⋮----
// Actions
⋮----
// Accept sites as parameter to avoid cross-store dependency
// If not provided, return early - components should pass the sites data
⋮----
// Calculate stats from site data
⋮----
// State
</file>

<file path="src/stores/ui/types.ts">
/**
 * UI store types and interfaces.
 * Manages UI state, modal visibility, and user interface interactions.
 */
import type { ChartTimeRange, Site } from "../types";
/**
 * UI store interface.
 * Manages user interface state and interactions.
 */
export interface UIStore {
    // State
    /** Whether settings modal is open */
    showSettings: boolean;
    /** Currently selected site identifier */
    selectedSiteId: string | undefined;
    /** Whether site details modal is open */
    showSiteDetails: boolean;
    /** Active tab in site details modal */
    activeSiteDetailsTab: string;
    /** Selected time range for charts */
    siteDetailsChartTimeRange: ChartTimeRange;
    /** Whether to show advanced metrics */
    showAdvancedMetrics: boolean;
    // Actions
    /** Set settings modal visibility */
    setShowSettings: (show: boolean) => void;
    /** Set selected site */
    setSelectedSite: (site: Site | undefined) => void;
    /** Set site details modal visibility */
    setShowSiteDetails: (show: boolean) => void;
    /** Set active tab in site details modal */
    setActiveSiteDetailsTab: (tab: string) => void;
    /** Set chart time range */
    setSiteDetailsChartTimeRange: (range: ChartTimeRange) => void;
    /** Set advanced metrics visibility */
    setShowAdvancedMetrics: (show: boolean) => void;
    // NOTE: getSelectedSite removed - use useSelectedSite hook instead
}
⋮----
// State
/** Whether settings modal is open */
⋮----
/** Currently selected site identifier */
⋮----
/** Whether site details modal is open */
⋮----
/** Active tab in site details modal */
⋮----
/** Selected time range for charts */
⋮----
/** Whether to show advanced metrics */
⋮----
// Actions
/** Set settings modal visibility */
⋮----
/** Set selected site */
⋮----
/** Set site details modal visibility */
⋮----
/** Set active tab in site details modal */
⋮----
/** Set chart time range */
⋮----
/** Set advanced metrics visibility */
⋮----
// NOTE: getSelectedSite removed - use useSelectedSite hook instead
</file>

<file path="src/stores/ui/useUiStore.ts">
/**
 * UI store for managing user interface state and interactions.
 * Handles modal visibility, selected states, and UI preferences.
 */
import { create } from "zustand";
import { persist } from "zustand/middleware";
import type { ChartTimeRange, Site } from "../types";
import type { UIStore } from "./types";
import { logStoreAction } from "../utils";
⋮----
// State
⋮----
// Actions
⋮----
// Don't persist modal states or selected site
</file>

<file path="src/stores/updates/types.ts">
/**
 * Updates store types and interfaces.
 * Manages application updates and update notifications.
 */
import type { UpdateStatus } from "../types";
/**
 * Update information interface.
 */
export interface UpdateInfo {
    /** Version number */
    version: string;
    /** Release notes */
    releaseNotes: string;
    /** Release name */
    releaseName: string;
    /** Release date */
    releaseDate: string;
}
⋮----
/** Version number */
⋮----
/** Release notes */
⋮----
/** Release name */
⋮----
/** Release date */
⋮----
/**
 * Updates store interface.
 * Manages application update status and operations.
 */
export interface UpdatesStore {
    // State
    /** Current update status */
    updateStatus: UpdateStatus;
    /** Update error message if any */
    updateError: string | undefined;
    /** Update progress (0-100) */
    updateProgress: number;
    /** Update information */
    updateInfo: UpdateInfo | undefined;
    // Actions
    /** Set update status */
    setUpdateStatus: (status: UpdateStatus) => void;
    /** Set update error */
    setUpdateError: (error: string | undefined) => void;
    /** Set update progress */
    setUpdateProgress: (progress: number) => void;
    /** Set update info */
    setUpdateInfo: (info: UpdateInfo | undefined) => void;
    /** Apply downloaded update and restart */
    applyUpdate: () => void;
    /** Clear update error */
    clearUpdateError: () => void;
}
⋮----
// State
/** Current update status */
⋮----
/** Update error message if any */
⋮----
/** Update progress (0-100) */
⋮----
/** Update information */
⋮----
// Actions
/** Set update status */
⋮----
/** Set update error */
⋮----
/** Set update progress */
⋮----
/** Set update info */
⋮----
/** Apply downloaded update and restart */
⋮----
/** Clear update error */
</file>

<file path="src/theme/components.css">
/* stylelint-disable keyframes-name-pattern -- already kebab case just -- */
/* stylelint-disable selector-class-pattern -- already kebab case just -- */
/* stylelint-disable no-descending-specificity -- not worth fixing atm -- */
/* Theme Components CSS - Professional UI Enhancement */
/* CSS Custom Properties for animations */
:root {
/* Themed Box Classes */
.themed-box {
.themed-box--background-primary {
.themed-box--background-secondary {
.themed-box--background-tertiary {
.themed-box--surface-base {
.themed-box--surface-elevated {
.themed-box--surface-overlay {
.themed-box--padding-xs {
.themed-box--padding-sm {
.themed-box--padding-md {
.themed-box--padding-lg {
.themed-box--padding-xl {
.themed-box--rounded-none {
.themed-box--rounded-sm {
.themed-box--rounded-md {
.themed-box--rounded-lg {
.themed-box--rounded-xl {
.themed-box--rounded-full {
.themed-box--shadow-sm {
.themed-box--shadow-md {
.themed-box--shadow-lg {
.themed-box--shadow-xl {
.themed-box--shadow-inner {
.themed-box--border {
/* Themed Text Classes */
.themed-text {
.themed-text--primary {
.themed-text--secondary {
.themed-text--tertiary {
.themed-text--inverse {
.themed-text--error {
/* Status color variants for text */
.themed-text--success {
.themed-text--warning {
.themed-text--danger {
.themed-text--size-xs {
.themed-text--size-sm {
.themed-text--size-base {
.themed-text--size-lg {
.themed-text--size-xl {
.themed-text--size-2xl {
.themed-text--size-3xl {
.themed-text--size-4xl {
.themed-text--weight-normal {
.themed-text--weight-medium {
.themed-text--weight-semibold {
.themed-text--weight-bold {
.themed-text--align-left {
.themed-text--align-center {
.themed-text--align-right {
/* Themed Button Classes */
.themed-button {
.themed-button:hover {
.themed-button:disabled,
.themed-button--primary {
.themed-button--secondary {
.themed-button--success {
.themed-button--warning {
.themed-button--error {
.themed-button--ghost {
.themed-button--size-xs {
.themed-button--size-sm {
.themed-button--size-md {
.themed-button--size-lg {
.themed-button--full-width {
/* Status Colors */
.themed-status-up {
.themed-status-down {
.themed-status-pending {
.themed-status-paused {
.themed-status-unknown {
.themed-button:hover::before {
.themed-button:active {
.themed-button:disabled {
.themed-button:disabled::before {
.themed-button.full-width {
/* Button Sizes - Enhanced */
.themed-button--xs {
.themed-button--sm {
.themed-button--md {
.themed-button--lg {
/* Icon Button Enhancements */
.themed-button--icon {
.themed-button--icon .button-icon {
/* Loading Spinner - Enhanced */
.themed-button__icon {
⋮----
/* Professional fade in animation */
⋮----
/* Status Indicator - Enhanced */
.status-indicator {
.status-indicator::after {
.status-indicator:hover::after {
.status-indicator--sm {
.status-indicator--md {
.status-indicator--lg {
/* Pulsing animation for pending status */
.status-indicator--pending {
⋮----
/* Input Base - Enhanced */
.themed-input {
.themed-input:focus {
.themed-input:hover:not(:focus) {
.themed-input:disabled {
/* Select Base - Enhanced */
.themed-select {
.themed-select:focus {
.themed-select:hover:not(:focus) {
.themed-select:disabled {
/* Checkbox Base - Enhanced */
.themed-checkbox {
.themed-checkbox:focus {
.themed-checkbox:hover {
.themed-checkbox:checked {
.themed-checkbox:checked::after {
.themed-checkbox:disabled {
/* Mini Chart Bar - Enhanced */
.mini-chart-bar {
.mini-chart-bar:hover {
.mini-chart-bar::after {
.mini-chart-bar:hover::after {
/* Card Hover Effects - Enhanced */
.site-card-hover {
.site-card-hover::before {
.site-card-hover:hover {
.site-card-hover:hover::before {
.site-card-hover:active {
/* Modal Overlay - Enhanced */
.modal-overlay {
⋮----
.modal-content {
/* Error Alert - Enhanced */
.error-alert {
.error-alert__text {
.error-alert__close {
.error-alert__close:hover {
.error-alert__icon {
/* Professional Container Animations */
.container-fade-in {
.container-fade-in:nth-child(2) {
.container-fade-in:nth-child(3) {
.container-fade-in:nth-child(4) {
/* Enhanced Status Indicators with proper alignment */
.status-group {
.status-group:hover {
.status-text {
/* Professional Header Styling */
.header-enhanced {
.header-title {
.header-controls {
.header-controls > * {
.header-controls > *:nth-child(2) {
.header-controls > *:nth-child(3) {
.header-controls > *:nth-child(4) {
/* Icon Button Improvements */
.icon-button {
.icon-button .icon {
.icon-button:hover .icon {
.icon-button::before {
.icon-button:hover::before {
.icon-button:active::before {
/* Enhanced Site Card Styling */
.site-card-enhanced {
.site-card-enhanced::after {
.site-card-enhanced:hover::after {
.site-card-enhanced:hover {
/* Enhanced Form Controls */
.form-group {
.form-label {
.form-control-wrapper {
.form-control-wrapper::after {
.form-control-wrapper:focus-within::after {
/* Professional Loading States */
.loading-state {
.loading-state.dark {
.loading-dots {
.loading-dot {
.loading-dot:nth-child(1) {
.loading-dot:nth-child(2) {
.loading-dot:nth-child(3) {
⋮----
/* Professional Tooltips */
.tooltip {
.tooltip::before {
.tooltip::after {
.tooltip:hover::before,
/* Professional Empty States */
.empty-state {
.empty-state-icon {
⋮----
.empty-state-title {
.empty-state-description {
/* Micro-interactions for buttons */
.button-micro {
.button-micro::after {
.button-micro:active::after {
/* Professional scrollbar styling */
.custom-scrollbar::-webkit-scrollbar {
.custom-scrollbar::-webkit-scrollbar-track {
.custom-scrollbar::-webkit-scrollbar-thumb {
.custom-scrollbar::-webkit-scrollbar-thumb:hover {
.custom-scrollbar.dark::-webkit-scrollbar-track {
.custom-scrollbar.dark::-webkit-scrollbar-thumb {
.custom-scrollbar.dark::-webkit-scrollbar-thumb:hover {
/* Site Card Hover */
/* Dividers */
.divider-y > * + * {
.divider-y.dark > * + * {
/* Utility Classes */
.border-t {
.border-b {
.text-center {
.text-sm {
.shadow-sm {
.hover-opacity {
.hover-opacity:hover {
.mt-4 {
.ml-auto {
/* Themed Components Base Classes */
.themed-status-indicator {
.themed-status-indicator__dot {
.themed-status-indicator__text {
.themed-mini-chart-bar {
/* Layout Utilities */
.app-container {
.modal-container {
.main-container {
⋮----
.header-container {
⋮----
.grid-layout {
⋮----
max-width: 48rem; /* ~768px */
⋮----
max-width: 64rem; /* ~1024px */
⋮----
max-width: 80rem; /* ~1280px */
⋮----
max-width: 96rem; /* ~1536px */
⋮----
max-width: 120rem; /* ~1920px */
⋮----
max-width: 160rem; /* ~2560px - 4K support */
⋮----
max-width: 240rem; /* ~3840px - 4K support */
⋮----
/* Loading Overlay */
.loading-overlay {
.loading-content {
.loading-spinner {
/* Common Layout Classes */
.flex {
.flex-1 {
.items-center {
.justify-between {
.space-x-1 > * + * {
.space-x-2 > * + * {
.space-x-3 > * + * {
.space-x-4 > * + * {
.space-y-1 > * + * {
.space-y-4 > * + * {
.space-y-6 > * + * {
.gap-2 {
.gap-8 {
/* Width and Height Utilities */
.w-full {
.min-w-0 {
.min-w-140 {
/* Margin and Padding Utilities */
.mb-1 {
.mb-2 {
.mb-4 {
.mt-1 {
.mt-2 {
.ml-4 {
.p-0 {
/* Display Utilities */
.block {
.truncate {
/* Settings Layout */
.setting-item {
.setting-info {
.setting-title {
.setting-description {
/* Enhanced Icon Button */
.themed-icon-button {
.themed-icon-button:hover {
/* Themed Card Component */
.themed-card {
.themed-card--hoverable:hover,
.themed-card--clickable {
.themed-card__header {
.themed-card__header-icon {
.themed-card__header-content {
.themed-card__content {
/* Themed Badge Component */
.themed-badge {
.themed-badge--xs {
.themed-badge--sm {
.themed-badge--md {
.themed-badge:hover {
/* Themed Progress Component */
.themed-progress {
.themed-progress__container {
.themed-progress__bar {
.themed-progress__bar::after {
⋮----
/* Themed Tooltip Component */
.themed-tooltip {
.themed-tooltip::before,
.themed-tooltip::before {
.themed-tooltip::after {
.themed-tooltip:hover::before,
.themed-status-indicator__dot--pending {
.themed-status-indicator__icon {
/* Removed duplicate .themed-status-indicator__text selector to resolve no-duplicate-selectors error */
⋮----
/* Enhanced Button Loading State */
.themed-button__loading {
.themed-button__spinner {
⋮----
/* Enhanced Input Focus States */
.themed-input:focus,
.themed-input:hover,
.themed-input:disabled,
.themed-mini-chart-bar:hover {
.themed-mini-chart-bar::after {
.themed-mini-chart-bar:hover::after {
/* Responsive Design Helpers */
⋮----
/* Dark Mode Specific Enhancements */
⋮----
/* Accessibility Enhancements */
⋮----
.themed-button,
⋮----
/* High Contrast Mode Support */
⋮----
.themed-input,
⋮----
/* Site Icon Components */
.site-icon-container {
.site-icon {
.site-icon-fallback {
.site-icon-fallback-hidden {
.hidden {
/* Icon color utility classes for theme-driven icon coloring */
.themed-icon--primary {
.themed-icon--secondary {
.themed-icon--success {
.themed-icon--info {
.themed-icon--up {
.themed-icon--down {
.themed-icon--pending {
.themed-icon--unknown {
/* Ensure .themed-badge and .themed-card icons inherit color from these classes */
.themed-badge .themed-icon--primary,
</file>

<file path="src/theme/index.ts">
/**
 * Theme module barrel export.
 * Provides centralized access to all theme-related functionality.
 */
// Theme components
⋮----
// Theme hooks and utilities
⋮----
// Theme types and configurations
</file>

<file path="src/theme/themes.ts">
/**
 * Theme definitions for the application.
 * Contains predefined light and dark theme configurations with complete styling properties.
 */
import { FONT_FAMILY_MONO, FONT_FAMILY_SANS } from "../constants";
import { Theme } from "./types";
/**
 * Light theme configuration.
 * Provides a clean, bright appearance suitable for well-lit environments.
 */
⋮----
errorAlert: "#991b1b", // Dark red for error alerts
⋮----
/**
 * Dark theme configuration.
 * Provides a modern dark appearance suitable for low-light environments and reduced eye strain.
 */
⋮----
errorAlert: "#dc2626", // Red for error alerts in dark mode
⋮----
// High contrast theme for accessibility
⋮----
errorAlert: "#cc0000", // Dark red for error alerts in high contrast
⋮----
xs: "0.875rem", // Slightly larger for accessibility
⋮----
normal: "500", // Slightly bolder for better contrast
</file>

<file path="src/theme/types.ts">
/**
 * Theme system type definitions.
 * Defines the structure and interfaces for the application's theming system.
 */
/**
 * Color palette interface defining all theme colors.
 * Provides a comprehensive color system for consistent theming.
 */
export interface ThemeColors {
    // Core colors
    primary: {
        50: string;
        100: string;
        200: string;
        300: string;
        400: string;
        500: string;
        600: string;
        700: string;
        800: string;
        900: string;
    };
    // Status colors
    status: {
        up: string;
        down: string;
        pending: string;
        unknown: string;
        paused: string;
        mixed: string;
    };
    // Semantic colors
    success: string;
    warning: string;
    error: string;
    errorAlert: string;
    info: string;
    // Background colors
    background: {
        primary: string;
        secondary: string;
        tertiary: string;
        modal: string;
    };
    // Text colors
    text: {
        primary: string;
        secondary: string;
        tertiary: string;
        inverse: string;
    };
    // Border colors
    border: {
        primary: string;
        secondary: string;
        focus: string;
    };
    // Surface colors
    surface: {
        base: string;
        elevated: string;
        overlay: string;
    };
    // Hover states
    hover: {
        light: string;
        medium: string;
        dark: string;
    };
}
⋮----
// Core colors
⋮----
// Status colors
⋮----
// Semantic colors
⋮----
// Background colors
⋮----
// Text colors
⋮----
// Border colors
⋮----
// Surface colors
⋮----
// Hover states
⋮----
/**
 * Spacing scale interface for consistent layout spacing.
 * Defines standard spacing values used throughout the application.
 */
export interface ThemeSpacing {
    /** Extra small spacing */
    xs: string;
    /** Small spacing */
    sm: string;
    /** Medium spacing */
    md: string;
    /** Large spacing */
    lg: string;
    /** Extra large spacing */
    xl: string;
    /** Double extra large spacing */
    "2xl": string;
    /** Triple extra large spacing */
    "3xl": string;
}
⋮----
/** Extra small spacing */
⋮----
/** Small spacing */
⋮----
/** Medium spacing */
⋮----
/** Large spacing */
⋮----
/** Extra large spacing */
⋮----
/** Double extra large spacing */
⋮----
/** Triple extra large spacing */
⋮----
/**
 * Typography system interface for text styling.
 * Defines font families, sizes, weights, and line heights.
 */
export interface ThemeTypography {
    /** Font family definitions */
    fontFamily: {
        /** Sans-serif font stack */
        sans: string[];
        /** Monospace font stack */
        mono: string[];
    };
    /** Font size scale */
    fontSize: {
        xs: string;
        sm: string;
        base: string;
        lg: string;
        xl: string;
        "2xl": string;
        "3xl": string;
        "4xl": string;
    };
    /** Font weight scale */
    fontWeight: {
        normal: string;
        medium: string;
        semibold: string;
        bold: string;
    };
    /** Line height scale */
    lineHeight: {
        tight: string;
        normal: string;
        relaxed: string;
    };
}
⋮----
/** Font family definitions */
⋮----
/** Sans-serif font stack */
⋮----
/** Monospace font stack */
⋮----
/** Font size scale */
⋮----
/** Font weight scale */
⋮----
/** Line height scale */
⋮----
/**
 * Shadow system interface for elevation and depth.
 * Defines consistent shadow styles for UI components.
 */
export interface ThemeShadows {
    /** Small shadow for subtle elevation */
    sm: string;
    /** Medium shadow for moderate elevation */
    md: string;
    /** Large shadow for high elevation */
    lg: string;
    /** Extra large shadow for maximum elevation */
    xl: string;
    /** Inner shadow for inset effects */
    inner: string;
}
⋮----
/** Small shadow for subtle elevation */
⋮----
/** Medium shadow for moderate elevation */
⋮----
/** Large shadow for high elevation */
⋮----
/** Extra large shadow for maximum elevation */
⋮----
/** Inner shadow for inset effects */
⋮----
/**
 * Border radius system interface for consistent corner rounding.
 * Defines standard border radius values for components.
 */
export interface ThemeBorderRadius {
    /** No border radius */
    none: string;
    /** Small border radius */
    sm: string;
    /** Medium border radius */
    md: string;
    /** Large border radius */
    lg: string;
    /** Extra large border radius */
    xl: string;
    /** Fully rounded borders */
    full: string;
}
⋮----
/** No border radius */
⋮----
/** Small border radius */
⋮----
/** Medium border radius */
⋮----
/** Large border radius */
⋮----
/** Extra large border radius */
⋮----
/** Fully rounded borders */
⋮----
/**
 * Complete theme interface containing all theme properties.
 * Represents a complete theme configuration with all styling properties.
 */
export interface Theme {
    /** Human-readable theme name */
    name: string;
    /** Color palette for the theme */
    colors: ThemeColors;
    /** Spacing scale for layout */
    spacing: ThemeSpacing;
    /** Typography system */
    typography: ThemeTypography;
    /** Shadow definitions */
    shadows: ThemeShadows;
    /** Border radius definitions */
    borderRadius: ThemeBorderRadius;
    /** Whether this is a dark theme */
    isDark: boolean;
}
⋮----
/** Human-readable theme name */
⋮----
/** Color palette for the theme */
⋮----
/** Spacing scale for layout */
⋮----
/** Typography system */
⋮----
/** Shadow definitions */
⋮----
/** Border radius definitions */
⋮----
/** Whether this is a dark theme */
⋮----
/** Available theme names in the application */
export type ThemeName = "light" | "dark" | "high-contrast" | "system" | "custom";
/**
 * Theme state interface for managing active themes.
 * Tracks current theme selection and custom theme definitions.
 */
export interface ThemeState {
    /** Currently selected theme name */
    currentTheme: ThemeName;
    /** Custom user-defined themes */
    customThemes: Record<string, Theme>;
    /** Currently active theme object */
    activeTheme: Theme;
    /** System theme preference (light/dark) */
    systemThemePreference: "light" | "dark";
}
⋮----
/** Currently selected theme name */
⋮----
/** Custom user-defined themes */
⋮----
/** Currently active theme object */
⋮----
/** System theme preference (light/dark) */
</file>

<file path="src/utils/data/generateUuid.ts">
/**
 * Utility function for generating unique identifiers.
 * Uses crypto.randomUUID when available, falls back to custom implementation.
 */
/**
 * Generate a unique identifier string.
 * Uses the browser's crypto.randomUUID() when available for better entropy,
 * otherwise falls back to a custom implementation using Math.random() and timestamp.
 *
 * @returns A unique identifier string (UUID format when crypto is available)
 * @example
 * ```typescript
 * const id = generateUuid();
 * // Returns: "123e4567-e89b-12d3-a456-426614174000" (crypto.randomUUID)
 * // Or: "site-ab3d5ef2-1640995200000" (fallback)
 * ```
 */
export function generateUuid(): string
</file>

<file path="src/utils/index.ts">
/**
 * Utilities barrel export.
 * Provides centralized access to all utility functions.
 */
// Time utilities
⋮----
// Status utilities
⋮----
// Data utilities
</file>

<file path="src/utils/monitorTitleFormatters.ts">
/**
 * Client-side monitor type suffix formatters.
 * This provides dynamic suffix generation for monitor types in the frontend.
 */
import { Monitor } from "../types";
/**
 * Type for monitor title suffix formatter functions
 */
export type TitleSuffixFormatter = (monitor: Monitor) => string;
/**
 * Registry of title suffix formatters for different monitor types
 */
⋮----
/**
 * Get title suffix formatter for a monitor type
 */
export function getTitleSuffixFormatter(monitorType: string): TitleSuffixFormatter | undefined
⋮----
// eslint-disable-next-line security/detect-object-injection
⋮----
/**
 * Register a title suffix formatter for a monitor type
 */
export function registerTitleSuffixFormatter(monitorType: string, formatter: TitleSuffixFormatter): void
⋮----
// eslint-disable-next-line security/detect-object-injection
⋮----
/**
 * Format title suffix for a monitor dynamically
 */
export function formatTitleSuffix(monitor: Monitor): string
⋮----
// Fallback to empty string if no formatter is registered
</file>

<file path="src/utils/siteStatus.ts">
/**
 * Site status calculation utilities for the frontend.
 * Provides comprehensive logic for determining overall site status based on monitor states.
 */
import { Site } from "../types";
/**
 * Possible site status values based on monitor states
 */
export type SiteStatus = "up" | "down" | "pending" | "paused" | "mixed" | "unknown";
/**
 * Calculate the overall site status based on monitor states.
 *
 * Logic:
 * - "up": All monitors are up and running
 * - "down": All monitors are down
 * - "pending": All monitors are pending
 * - "paused": All monitors are paused (not monitoring)
 * - "mixed": Monitors have different statuses (some up, some down, some paused, etc.)
 * - "unknown": No monitors exist
 *
 * @param site - The site to calculate status for
 * @returns Overall site status
 */
export function calculateSiteStatus(site: Site): SiteStatus
⋮----
// Get unique statuses
⋮----
// Single status - all monitors have the same status
⋮----
// Multiple statuses - mixed state
⋮----
/**
 * Calculate the overall site monitoring status.
 *
 * Logic:
 * - "running": All monitors are actively monitoring
 * - "stopped": No monitors are actively monitoring
 * - "partial": Some monitors are monitoring, some are not
 *
 * @param site - The site to calculate monitoring status for
 * @returns Overall monitoring status
 */
export function calculateSiteMonitoringStatus(site: Site): "running" | "stopped" | "partial"
/**
 * Get a display-friendly site status that considers both operational status and monitoring state.
 * This is the primary function to use for displaying site status in the UI.
 *
 * @param site - The site to get display status for
 * @returns Display status for the site
 */
export function getSiteDisplayStatus(site: Site): SiteStatus
⋮----
// If no monitors exist, show as unknown
⋮----
// If no monitoring is active, show as paused regardless of operational status
⋮----
// If monitoring is partial, show as mixed
⋮----
// All monitors are running, return the operational status
⋮----
/**
 * Get a human-readable description of the site status.
 *
 * @param site - The site to get description for
 * @returns Human-readable status description
 */
export function getSiteStatusDescription(site: Site): string
/**
 * Get the appropriate status indicator color for a site status.
 *
 * @param status - The site status
 * @returns Color variant for status indicators
 */
export function getSiteStatusVariant(status: SiteStatus): "success" | "warning" | "error" | "info"
</file>

<file path="src/utils/status.ts">
/**
 * Status utility functions for consistent status handling across components.
 * Provides emoji icons and formatting for different status types.
 */
/**
 * Get the emoji icon for a given status.
 * Provides visual indicators for different monitoring states.
 *
 * @param status - The status string to get an icon for
 * @returns Emoji string representing the status
 */
export function getStatusIcon(status: string): string
/**
 * Format status with emoji icon and properly capitalized text.
 * Combines status icon with formatted text for display.
 *
 * @param status - The status string to format
 * @returns Formatted string with emoji and capitalized text (e.g., "✅ Up")
 */
export function formatStatusWithIcon(status: string): string
</file>

<file path="electron/electronUtils.ts">
/**
 * Electron utility functions for common main process operations.
 *
 * @remarks
 * Provides reusable utility functions for environment detection and development helpers.
 *
 * @packageDocumentation
 */
import { app } from "electron";
/**
 * Determines if the application is running in development mode.
 *
 * @returns `true` if running in development mode, `false` for production
 *
 * @remarks
 * Uses NODE_ENV and Electron's packaging state to detect runtime environment.
 *
 * @example
 * ```typescript
 * if (isDev()) {
 *   logger.debug("Running in development mode - enabling debug features");
 *   // Enable hot reload, detailed logging, etc.
 * } else {
 *   logger.info("Running in production mode");
 *   // Optimize for performance, reduce logging
 * }
 * ```
 *
 * @public
 */
export function isDev(): boolean
</file>

<file path="electron/events/middleware.ts">
/**
 * Pre-built middleware functions for the TypedEventBus.
 * Provides common functionality like logging, metrics, and filtering.
 */
import type { EventMiddleware } from "../events/index";
import { logger as baseLogger } from "../utils/index";
⋮----
/**
 * Logging middleware that logs all events with configurable detail levels.
 */
export function createLoggingMiddleware(options: {
    level?: "debug" | "info" | "warn" | "error";
    includeData?: boolean;
filter?: (eventName: string)
⋮----
// Apply filter if provided
⋮----
/**
 * Metrics middleware that tracks event counts and timing.
 */
export function createMetricsMiddleware(options: {
    trackCounts?: boolean;
    trackTiming?: boolean;
metricsCallback?: (metric:
⋮----
// Track event counts
⋮----
// Track event timing
⋮----
/**
 * Error handling middleware that catches and logs middleware errors.
 */
export function createErrorHandlingMiddleware(options: {
onError?: (error: Error, event: string, data: unknown)
/**
 * Rate limiting middleware to prevent event spam.
 */
export function createRateLimitMiddleware(options: {
    maxEventsPerSecond?: number;
    burstLimit?: number;
onRateLimit?: (event: string, data: unknown)
⋮----
// Remove old entries (older than 1 second)
⋮----
// Check burst limit
⋮----
return; // Don't continue to next middleware
⋮----
// Check rate limit
⋮----
return; // Don't continue to next middleware
⋮----
// Update event times
⋮----
/**
 * Validation middleware that validates event data against schemas.
 */
export function createValidationMiddleware<T extends Record<string, unknown>>(
    validators: Partial<{ [K in keyof T]: (data: T[K]) => boolean | { isValid: boolean; error?: string } }>
): EventMiddleware
/**
 * Filter middleware that can block certain events based on conditions.
 */
export function createFilterMiddleware(options: {
    allowList?: string[];
    blockList?: string[];
condition?: (event: string, data: unknown)
⋮----
// Check allow list
⋮----
// Check block list
⋮----
// Check custom condition
⋮----
/**
 * Debug middleware that provides detailed debugging information.
 */
export function createDebugMiddleware(options:
/**
 * Middleware composer to combine multiple middleware functions.
 */
export function composeMiddleware(...middlewares: EventMiddleware[]): EventMiddleware
⋮----
const processNext = async (): Promise<void> =>
⋮----
/**
 * Pre-configured middleware stacks for common use cases.
 */
⋮----
/**
     * Custom stack builder.
     */
⋮----
/**
     * Development stack with debugging, logging, and error handling.
     */
⋮----
/**
     * Production stack with metrics, rate limiting, and error handling.
     */
⋮----
/**
     * Testing stack with minimal overhead.
     */
</file>

<file path="electron/index.ts">
/**
 * @packageDocumentation
 * Electron main barrel export.
 *
 * Provides centralized access to all Electron modules.
 *
 * @remarks
 * This barrel file re-exports the following main modules for convenient and consistent imports throughout the application:
 * - Core modules: constants, electronUtils, types, UptimeOrchestrator
 * - Event system: events
 * - Managers: managers
 * - Services: services
 * - Utilities: utils
 *
 * For the full list of exports, see the respective files in the electron directory.
 */
// Core modules
⋮----
// Event system
⋮----
// Managers
⋮----
// Services
⋮----
// Utilities
</file>

<file path="electron/managers/validators/SiteValidator.ts">
/**
 * Site validation logic extracted for better separation of concerns.
 * Handles all site-specific validation rules.
 */
import { Site } from "../../types";
import { ValidationResult } from "../../managers/index";
import { MonitorValidator } from "./MonitorValidator";
/**
 * Validates site configuration according to business rules.
 * Focused on site-level validation concerns.
 */
export class SiteValidator {
⋮----
constructor()
/**
     * Validate complete site configuration.
     */
public validateSiteConfiguration(site: Site): ValidationResult
⋮----
// Validate site identifier
⋮----
// Validate monitors array
⋮----
/**
     * Validate site identifier according to business rules.
     */
private validateSiteIdentifier(site: Site): string[]
/**
     * Validate site monitors array and individual monitors.
     */
private validateSiteMonitors(site: Site): string[]
⋮----
// Validate each monitor
⋮----
/**
     * Business rule: Determine if a site should be included in exports.
     */
public shouldIncludeInExport(site: Site): boolean
⋮----
// Business rule: Include all sites with valid identifiers
</file>

<file path="electron/services/database/utils/dynamicSchema.ts">
/**
 * Dynamic database schema management for monitor types.
 * Automatically generates database columns and mappings based on monitor type registry.
 */
import { getAllMonitorTypeConfigs } from "../../monitoring/MonitorTypeRegistry";
export interface DatabaseFieldDefinition {
    /** Column name in database */
    columnName: string;
    /** SQL data type */
    sqlType: string;
    /** Whether column allows NULL values */
    nullable: boolean;
    /** Default value for the column */
    defaultValue?: string;
    /** Field name from monitor type definition */
    sourceField: string;
    /** Monitor type this field belongs to */
    monitorType: string;
}
⋮----
/** Column name in database */
⋮----
/** SQL data type */
⋮----
/** Whether column allows NULL values */
⋮----
/** Default value for the column */
⋮----
/** Field name from monitor type definition */
⋮----
/** Monitor type this field belongs to */
⋮----
/**
 * Automatically generate database field definitions from monitor type registry.
 */
export function generateDatabaseFieldDefinitions(): DatabaseFieldDefinition[]
⋮----
// Convert field name to snake_case for database
⋮----
// Skip if we've already seen this field (avoid duplicates)
⋮----
// All dynamic fields are nullable since they're only used by specific monitor types
⋮----
/**
 * Generate CREATE TABLE SQL with all monitor type fields.
 */
export function generateMonitorTableSchema(): string
/**
 * Map database row to monitor object with dynamic field handling.
 */
export function mapRowToMonitor(row: Record<string, unknown>): Record<string, unknown>
⋮----
monitoring: Boolean(row.enabled), // Map enabled -> monitoring for frontend compatibility
⋮----
// Dynamically map monitor type specific fields
⋮----
/**
 * Map monitor object to database row with dynamic field handling.
 */
export function mapMonitorToRow(monitor: Record<string, unknown>): Record<string, unknown>
⋮----
// Dynamically map monitor type specific fields
⋮----
/**
 * Generate SQL parameter placeholders for INSERT/UPDATE operations.
 */
export function generateSqlParameters():
/**
 * Convert field type to SQL data type.
 */
function getSqlTypeFromFieldType(fieldType: string): string
/**
 * Convert camelCase to snake_case for database columns.
 */
function toSnakeCase(str: string): string
/**
 * Convert database value to JavaScript type.
 */
function convertFromDatabase(value: unknown, sqlType: string): unknown
/**
 * Convert JavaScript value to database format.
 */
function convertToDatabase(value: unknown, sqlType: string): unknown
⋮----
} // Convert anything else to string to avoid object binding errors
</file>

<file path="electron/services/database/utils/historyMapper.ts">
import { StatusHistory } from "../../../types";
/**
 * Utility functions for mapping database rows to history entries.
 */
/**
 * Convert database row to history entry.
 */
export function rowToHistoryEntry(row: Record<string, unknown>): StatusHistory
</file>

<file path="electron/services/database/utils/index.ts">
/**
 * Database utilities index file.
 * Exports all database utility functions for easy importing.
 */
// Value conversion utilities
⋮----
// Monitor mapping utilities
⋮----
// Dynamic schema utilities
⋮----
// History utilities
⋮----
// Database schema utilities
⋮----
// Database backup utilities
</file>

<file path="electron/services/index.ts">
/**
 * Electron services barrel export.
 * Provides centralized access to all electron services.
 */
// Service Container
⋮----
// Application services
⋮----
// Database services
⋮----
// IPC services
⋮----
// Monitoring services
⋮----
// Notification services
⋮----
// Updater services
⋮----
// Window services
</file>

<file path="electron/services/ServiceContainer.ts">
/**
 * Centralized dependency injection container for all Electron services.
 *
 * @remarks
 * Provides a unified way to manage service dependencies and lifecycle,
 * ensuring proper initialization order and singleton management where appropriate.
 *
 * Services are categorized by type:
 * - **Core Services**: Essential infrastructure (Database, IPC)
 * - **Application Services**: Business logic orchestrators
 * - **Feature Services**: Specific functionality (Monitoring, Notifications)
 * - **Utility Services**: Support functions (Window, Updater)
 */
import { UptimeOrchestrator } from "../index";
import { AutoUpdaterService } from "./updater/index";
import { DatabaseService } from "./database/index";
import { IpcService } from "./ipc/index";
import { NotificationService } from "./notifications/index";
import { WindowService } from "./window/index";
import { logger } from "../utils/index";
/**
 * Service container configuration interface.
 */
export interface ServiceContainerConfig {
    /** Enable debug logging for service initialization */
    enableDebugLogging?: boolean;
    /** Custom notification service configuration */
    notificationConfig?: {
        showDownAlerts: boolean;
        showUpAlerts: boolean;
    };
}
⋮----
/** Enable debug logging for service initialization */
⋮----
/** Custom notification service configuration */
⋮----
/**
 * Centralized service container for dependency management.
 */
export class ServiceContainer {
⋮----
/**
     * Get the singleton service container instance.
     */
public static getInstance(config?: ServiceContainerConfig): ServiceContainer
/**
     * Reset container for testing purposes.
     */
public static resetForTesting(): void
⋮----
// Core Services (Infrastructure)
⋮----
// Utility Services
⋮----
// Application Services (Business Logic)
⋮----
private constructor(config: ServiceContainerConfig =
/**
     * Initialize all services in the correct order.
     */
public async initialize(): Promise<void>
⋮----
// Initialize core services first
⋮----
// Initialize application services
⋮----
// Initialize IPC (depends on orchestrator)
⋮----
// Core Services
public getDatabaseService(): DatabaseService
// Utility Services
public getWindowService(): WindowService
public getAutoUpdaterService(): AutoUpdaterService
public getNotificationService(): NotificationService
// Application Services
public getUptimeOrchestrator(): UptimeOrchestrator
public getIpcService(): IpcService
⋮----
// IPC service depends on orchestrator and updater
⋮----
/**
     * Get all initialized services for shutdown.
     */
public getInitializedServices():
</file>

<file path="electron/utils/database/databaseInitializer.ts">
/**
 * Database initialization utility.
 * Handles database setup and site loading with proper error handling.
 */
import { UptimeEvents, TypedEventBus } from "../../events/index";
import { DatabaseService } from "../../services/index";
import { monitorLogger as logger, withDbRetry } from "../../utils/index";
/**
 * Initialize the database and load sites.
 * @param databaseService - The database service instance
 * @param loadSitesCallback - Callback function to load sites
 * @param eventEmitter - Event emitter for error handling
 */
export async function initDatabase(
    databaseService: DatabaseService,
    loadSitesCallback: () => Promise<void>,
    eventEmitter: TypedEventBus<UptimeEvents>
): Promise<void>
⋮----
// Don't re-throw the error - let it be handled via the event system
</file>

<file path="electron/utils/database/index.ts">
/**
 * Database utilities index file.
 * Exports all database utility functions for easy importing.
 */
// Database initialization
⋮----
// History limit management
⋮----
// New service-based architecture
⋮----
// Import/Export services
</file>

<file path="electron/utils/errorHandling.ts">
/**
 * Standardized error handling utilities for consistent error management.
 *
 * @remarks
 * Provides consistent error handling patterns across all services, with support
 * for different contexts (transactional, non-transactional, async operations).
 *
 * Key patterns:
 * - **Consistent logging**: Standardized error message formatting
 * - **Error wrapping**: Convert unknown errors to Error instances
 * - **Context-aware handling**: Different strategies for different operation types
 * - **Event emission**: Automatic error event emission where appropriate
 */
import { logger } from "./logger";
import { TypedEventBus, UptimeEvents } from "../events";
/**
 * Error context information for better error tracking.
 */
export interface ErrorContext {
    /** Operation that failed */
    operation: string;
    /** Additional context data */
    context?: Record<string, unknown>;
    /** Whether this error occurred in a transaction */
    inTransaction?: boolean;
    /** Service/component where error occurred */
    component?: string;
}
⋮----
/** Operation that failed */
⋮----
/** Additional context data */
⋮----
/** Whether this error occurred in a transaction */
⋮----
/** Service/component where error occurred */
⋮----
/**
 * Options for error handling behavior.
 */
export interface ErrorHandlingOptions {
    /** Whether to re-throw the error after handling */
    rethrow?: boolean;
    /** Whether to emit error events */
    emitEvents?: boolean;
    /** Whether to log the error */
    logError?: boolean;
    /** Custom error message prefix */
    messagePrefix?: string;
    /** Event emitter for error events */
    eventEmitter?: TypedEventBus<UptimeEvents>;
}
⋮----
/** Whether to re-throw the error after handling */
⋮----
/** Whether to emit error events */
⋮----
/** Whether to log the error */
⋮----
/** Custom error message prefix */
⋮----
/** Event emitter for error events */
⋮----
/**
 * Standardized error wrapper that ensures errors are Error instances.
 */
export function wrapError(error: unknown, defaultMessage: string): Error
⋮----
// Preserve original error as cause if possible
⋮----
/**
 * Format error message with context.
 */
export function formatErrorMessage(baseMessage: string, context: ErrorContext, error: Error): string
/**
 * Centralized error handling utility.
 *
 * @example
 * ```typescript
 * // In a service method
 * try {
 *   await someOperation();
 * } catch (error) {
 *   return handleError(error, {
 *     operation: "create-site",
 *     component: "SiteManager",
 *     context: { siteId: "example" }
 *   }, {
 *     rethrow: true,
 *     emitEvents: true,
 *     eventEmitter: this.eventEmitter
 *   });
 * }
 * ```
 */
export async function handleError(
    error: unknown,
    context: ErrorContext,
    options: ErrorHandlingOptions = {}
): Promise<void>
⋮----
// Wrap unknown errors
⋮----
// Format error message
⋮----
// Log error with context
⋮----
// Emit error events if requested
⋮----
// Don't let event emission errors break error handling
⋮----
// Re-throw if requested
⋮----
/**
 * Wrapper for async operations with standardized error handling.
 *
 * @example
 * ```typescript
 * const result = await withErrorHandling(
 *   async () => await someAsyncOperation(),
 *   {
 *     operation: "fetch-sites",
 *     component: "SiteRepository"
 *   },
 *   {
 *     emitEvents: true,
 *     eventEmitter: this.eventEmitter
 *   }
 * );
 * ```
 */
export async function withErrorHandling<T>(
    operation: () => Promise<T>,
    context: ErrorContext,
    options: ErrorHandlingOptions = {}
): Promise<T>
⋮----
// This will never execute if rethrow=true (default)
⋮----
/**
 * Wrapper for sync operations with standardized error handling.
 */
export function withSyncErrorHandling<T>(
    operation: () => T,
    context: ErrorContext,
    options: ErrorHandlingOptions = {}
): T
⋮----
// Use void to handle async error handling in sync context
⋮----
throw error; // Re-throw for sync operations
⋮----
/**
 * Special error handling for database transactions.
 *
 * @remarks
 * Transactions have special requirements:
 * - Errors should always be re-thrown to trigger rollback
 * - Logging should include transaction context
 * - No event emission during transaction (wait for commit/rollback)
 */
export function handleTransactionError(error: unknown, context: Omit<ErrorContext, "inTransaction">): never
⋮----
// Always log transaction errors
⋮----
// Always re-throw transaction errors to trigger rollback
⋮----
/**
 * Error handling specifically for operational hooks.
 */
export async function handleOperationalError(
    error: unknown,
    context: ErrorContext,
    options: ErrorHandlingOptions = {}
): Promise<never>
⋮----
// Operational errors typically need event emission
⋮----
// Will never reach here due to rethrow=true
</file>

<file path="electron/utils/logger.ts">
/**
 * Centralized logging utilities for the Electron main process.
 * Provides structured logging with consistent formatting and categorization.
 */
import log from "electron-log/main";
/**
 * Centralized logger utility for the backend.
 * Provides consistent logging across all backend services.
 */
⋮----
/**
 * Database-specific logger for database operations and queries.
 */
⋮----
/**
 * Monitor-specific logger for monitoring operations and health checks.
 */
</file>

<file path="electron/utils/retry.ts">
/**
 * Retry utility for handling transient failures in database and network operations.
 * Provides configurable retry logic with exponential backoff for robust error handling.
 */
import { dbLogger } from "./logger";
/**
 * Generic retry utility with configurable parameters
 *
 * @param operation - The async operation to retry
 * @param options - Retry configuration options
 * @returns Promise that resolves with the operation result
 * @throws Error if all retry attempts fail
 */
export async function withRetry<T>(
    operation: () => Promise<T>,
    options: {
        delayMs?: number;
        maxRetries?: number;
onError?: (error: unknown, attempt: number)
/**
 * Database-specific retry wrapper with optimized settings for database operations.
 *
 * @param operation - Database operation to retry
 * @param operationName - Name of the operation for logging
 * @param maxRetries - Maximum number of retry attempts (default: 5)
 * @returns Promise that resolves with the operation result
 */
export async function withDbRetry<T>(operation: () => Promise<T>, operationName: string, maxRetries = 5): Promise<T>
</file>

<file path="electron/utils/siteStatus.ts">
/**
 * Site status calculation utilities.
 * Provides comprehensive logic for determining overall site status based on monitor states.
 */
import { Site } from "../types";
/**
 * Possible site status values based on monitor states
 */
export type SiteStatus = "up" | "down" | "pending" | "paused" | "mixed" | "unknown";
/**
 * Calculate the overall site status based on monitor states.
 *
 * Logic:
 * - "up": All monitors are up and running
 * - "down": All monitors are down
 * - "pending": All monitors are pending
 * - "paused": All monitors are paused (not monitoring)
 * - "mixed": Monitors have different statuses (some up, some down, some paused, etc.)
 * - "unknown": No monitors exist
 *
 * @param site - The site to calculate status for
 * @returns Overall site status
 */
export function calculateSiteStatus(site: Site): SiteStatus
⋮----
// Get unique statuses
⋮----
// Single status - all monitors have the same status
⋮----
// Multiple statuses - mixed state
⋮----
/**
 * Calculate the overall site monitoring status.
 *
 * Logic:
 * - "running": All monitors are actively monitoring
 * - "stopped": No monitors are actively monitoring
 * - "partial": Some monitors are monitoring, some are not
 *
 * @param site - The site to calculate monitoring status for
 * @returns Overall monitoring status
 */
export function calculateSiteMonitoringStatus(site: Site): "running" | "stopped" | "partial"
/**
 * Get a display-friendly site status that considers both operational status and monitoring state.
 * This is the primary function to use for displaying site status in the UI.
 *
 * @param site - The site to get display status for
 * @returns Display status for the site
 */
export function getSiteDisplayStatus(site: Site): SiteStatus
⋮----
// If no monitors exist, show as unknown
⋮----
// If no monitoring is active, show as paused regardless of operational status
⋮----
// If monitoring is partial, show as mixed
⋮----
// All monitors are running, return the operational status
⋮----
/**
 * Get a human-readable description of the site status.
 *
 * @param site - The site to get description for
 * @returns Human-readable status description
 */
export function getSiteStatusDescription(site: Site): string
/**
 * Get the appropriate status indicator color for a site status.
 *
 * @param status - The site status
 * @returns Color variant for status indicators
 */
export function getSiteStatusVariant(status: SiteStatus): "success" | "warning" | "error" | "info"
</file>

<file path="src/components/AddSiteForm/DynamicMonitorFields.tsx">
/**
 * Dynamic form component that generates monitor fields based on type configuration.
 * Eliminates hard-coded form field rendering by loading field definitions from backend.
 */
import { useState, useEffect } from "react";
import { TextField } from "./FormFields";
import {
    getMonitorTypeConfig,
    type MonitorFieldDefinition,
    type MonitorTypeConfig,
} from "../../utils/monitorTypeHelper";
interface DynamicMonitorFieldsProps {
    /** Selected monitor type */
    readonly monitorType: string;
    /** Current form values */
    readonly values: Record<string, string | number>;
    /** Change handlers for each field */
    readonly onChange: Record<string, (value: string | number) => void>;
    /** Whether the form is in a loading state */
    readonly isLoading?: boolean;
}
⋮----
/** Selected monitor type */
⋮----
/** Current form values */
⋮----
/** Change handlers for each field */
⋮----
/** Whether the form is in a loading state */
⋮----
/**
 * Renders form fields dynamically based on monitor type configuration loaded from backend.
 */
⋮----
// Load monitor type configuration from backend
⋮----
const loadConfig = async () =>
⋮----
/** Field definition */
⋮----
/** Current field value */
⋮----
/** Change handler */
⋮----
/** Whether the field is disabled */
⋮----
/**
 * Renders a single form field based on its definition.
 */
⋮----
const handleChange = (newValue: string | number) =>
</file>

<file path="src/components/common/HistoryChart.tsx">
/**
 * HistoryChart component for visualizing status history as mini chart bars.
 * Provides a compact, responsive chart for displaying historical uptime/downtime data.
 */
import React from "react";
import { MiniChartBar, ThemedText } from "../../theme";
import { StatusHistory } from "../../types";
/** Props for the HistoryChart component */
interface HistoryChartProperties {
    /** Array of historical status records to display */
    history: StatusHistory[];
    /** Title to display above the chart */
    title: string;
    /** Maximum number of items to display (default: 120) */
    maxItems?: number;
    /** Additional CSS classes */
    className?: string;
}
⋮----
/** Array of historical status records to display */
⋮----
/** Title to display above the chart */
⋮----
/** Maximum number of items to display (default: 120) */
⋮----
/** Additional CSS classes */
⋮----
/**
 * Reusable history chart component for visualizing status history.
 * Can be used anywhere we need to show historical data.
 *
 * Features:
 * - Responsive layout using CSS
 * - Memoized to prevent unnecessary re-renders
 * - Configurable item limit
 * - Graceful handling of empty data
 *
 * @param props - HistoryChart component props
 * @returns JSX element containing the history chart or null if no data
 */
⋮----
// Return null for empty history (React convention for "render nothing")
⋮----
// React components, returning null from a render function
// is actually the correct and idiomatic way to indicate "render nothing."
// This is a special case where null is the standard React convention.
// eslint-disable-next-line unicorn/no-null -- React components can return null
⋮----
// Show up to maxItems bars, most recent first (reverse chronological order)
</file>

<file path="src/components/Dashboard/SiteCard/index.tsx">
/**
 * SiteCard component displaying comprehensive monitoring information for a single site.
 * Composed of multiple sub-components for maintainability and reusability.
 */
import React from "react";
import { useSite } from "../../../hooks/site";
import { ThemedBox } from "../../../theme";
import { Site } from "../../../types";
import { SiteCardFooter } from "./SiteCardFooter";
import { SiteCardHeader } from "./SiteCardHeader";
import { SiteCardHistory } from "./SiteCardHistory";
import { SiteCardMetrics } from "./SiteCardMetrics";
import { SiteCardStatus } from "./SiteCardStatus";
/** Props for the SiteCard component */
interface SiteCardProperties {
    /** Site data to display */
    site: Site;
}
⋮----
/** Site data to display */
⋮----
/**
 * Main site card component using composition of smaller, focused sub-components.
 * Provides a complete overview of site monitoring status, metrics, and controls.
 *
 * Features:
 * - Real-time status indicators
 * - Historical uptime data visualization
 * - Monitor management controls
 * - Performance metrics display
 * - Click-to-expand details
 *
 * Much cleaner and more maintainable than a monolithic component approach.
 * Memoized to prevent unnecessary re-renders when parent updates.
 *
 * @param props - SiteCard component props
 * @returns JSX element containing the complete site monitoring card
 */
⋮----
// Use our custom hook to get all the data and functionality we need
⋮----
// Action handlers
⋮----
// UI state
⋮----
// Site monitor data
⋮----
// Site statistics
</file>

<file path="src/components/Dashboard/SiteCard/SiteCardHeader.tsx">
/**
 * SiteCardHeader component displaying site name, monitor selector, and action buttons.
 * Provides the top section of each site card with interactive controls.
 */
import React from "react";
import { ThemedText } from "../../../theme";
import { Site } from "../../../types";
import { ActionButtonGroup } from "./components/ActionButtonGroup";
import { MonitorSelector } from "./components/MonitorSelector";
/** Props for the SiteCardHeader component */
interface SiteCardHeaderProperties {
    /** Site data to display */
    site: Site;
    /** Currently selected monitor ID */
    selectedMonitorId: string;
    /** Handler for monitor selection changes */
    onMonitorIdChange: (event: React.ChangeEvent<HTMLSelectElement>) => void;
    /** Handler for immediate check button */
    onCheckNow: () => void;
    /** Handler for start monitoring button */
    onStartMonitoring: () => void;
    /** Handler for stop monitoring button */
    onStopMonitoring: () => void;
    /** Whether any operation is currently loading */
    isLoading: boolean;
    /** Whether monitoring is currently active */
    isMonitoring: boolean;
    /** Whether site has any monitors configured */
    hasMonitor: boolean;
}
⋮----
/** Site data to display */
⋮----
/** Currently selected monitor ID */
⋮----
/** Handler for monitor selection changes */
⋮----
/** Handler for immediate check button */
⋮----
/** Handler for start monitoring button */
⋮----
/** Handler for stop monitoring button */
⋮----
/** Whether any operation is currently loading */
⋮----
/** Whether monitoring is currently active */
⋮----
/** Whether site has any monitors configured */
⋮----
/**
 * Header section of the site card containing site name, monitor selection, and action buttons.
 * Provides interactive controls for monitor management and site operations.
 * Memoized to prevent unnecessary re-renders when parent data hasn't changed.
 *
 * @param props - SiteCardHeader component props
 * @returns JSX element containing site header with controls
 */
</file>

<file path="src/components/Header/Header.css">
/* Use theme variables for status colors and accent */
:root {
.themed-header {
.header-title {
.header-title::after {
.header-controls {
.header-status-summary {
.health-badge {
.health-badge[data-health-color] {
.status-up-badge {
.status-down-badge {
.status-pending-badge {
.status-paused-badge {
.health-badge:hover {
.status-up-badge:hover {
.status-down-badge:hover {
.status-pending-badge:hover {
.status-paused-badge:hover {
/* Remove all default borders and box-shadows from header items */
.header-title-box,
/* Show visible outlines and subtle background on hover/focus */
.header-title-box:hover,
.header-status-summary-box:hover,
.health-badge:hover,
.status-up-badge:hover,
.status-down-badge:hover,
.status-pending-badge:hover,
.status-paused-badge:hover,
.total-sites-badge:hover,
.header-interval-box:hover,
.header-controls-box:hover,
/* Accessibility: reduce motion */
⋮----
.themed-header,
</file>

<file path="src/components/Header/Header.tsx">
/**
 * Header component providing global status overview and application controls.
 * Displays uptime statistics, theme toggle, and settings access.
 */
import { useMemo } from "react";
import { useSitesStore, useUIStore } from "../../stores";
import { ThemedBox, ThemedText, ThemedButton, StatusIndicator, useTheme, useAvailabilityColors } from "../../theme";
⋮----
/**
 * Main header component for the application.
 *
 * Features:
 * - Global uptime statistics across all monitors
 * - Status indicator counts (up/down/pending)
 * - Theme toggle (light/dark mode)
 * - Settings modal trigger
 * - Responsive layout with proper text truncation
 *
 * @returns JSX element containing the application header
 */
⋮----
// Count all monitors across all sites by status using functional approach
⋮----
// Calculate overall uptime percentage across all monitors
⋮----
{/* Left: App Title & Status Summary */}
⋮----
{/* App Title with subtle background and border */}
⋮----
{/* Status Summary - Enhanced */}
⋮----
{/* Overall Health Badge */}
⋮----
data-health-color=
⋮----
{/* Up Status */}
⋮----
{/* Divider */}
⋮----
{/* Down Status */}
⋮----
{/* Divider */}
⋮----
{/* Pending Status */}
⋮----
{/* Divider */}
⋮----
{/* Paused Status */}
⋮----
{/* Total Sites Badge */}
⋮----
{/* Right: Controls */}
⋮----
{/* Theme Toggle */}
⋮----
{/* Settings Button */}
</file>

<file path="src/components/SiteDetails/SiteDetails.css">
/* Site Details Header */
.site-details-header {
.site-details-header:hover {
.site-details-header-overlay {
⋮----
.site-details-header-content {
/* Responsive header adjustments */
⋮----
.site-details-header-info {
⋮----
.site-details-title {
.site-details-title::after {
.site-details-title:hover {
.site-details-title:hover::after {
.site-details-title:active {
.site-details-url {
.site-details-meta {
.site-details-last-checked {
.site-details-refresh-indicator {
.site-details-refresh-text {
.site-details-loading-spinner {
.site-details-spinner {
.site-details-actions {
/* Override themed button colors in header */
.site-details-header .themed-button-ghost {
.site-details-header .themed-button-ghost:hover {
/* Background for elevated surfaces */
.bg-surface-elevated {
/* Chart containers */
.h-64 {
/* Screenshot thumbnail styles */
.site-details-thumbnail-link {
.site-details-thumbnail-img {
.site-details-thumbnail-caption {
/* Portal-based screenshot hover overlay */
.site-details-thumbnail-portal-overlay {
⋮----
/* Overlay positioning via CSS variables */
⋮----
.site-details-thumbnail-portal-img-wrapper {
.site-details-thumbnail-img-portal {
/* Responsive adjustments */
/* stylelint-disable-next-line media-feature-range-notation -- messes up postcss */
⋮----
/* Keyframe animations */
</file>

<file path="src/components/SiteDetails/useAddSiteForm.ts">
/**
 * Custom hook for managing add site form state and validation.
 * Provides comprehensive form state management for creating new sites and adding monitors to existing sites.
 * Supports real-time validation, automatic UUID generation, and error handling.
 */
import { useState, useEffect, useCallback } from "react";
import { DEFAULT_CHECK_INTERVAL } from "../../constants";
import { generateUuid } from "../../utils/index";
import type { MonitorType } from "../../types";
import { useMonitorFields } from "../../hooks/useMonitorFields";
/** Form operation mode */
export type FormMode = "new" | "existing";
/**
 * Form state interface containing all form field values and UI state.
 */
export interface AddSiteFormState {
    /** URL field for HTTP monitors */
    url: string;
    /** Host/IP field for port monitors */
    host: string;
    /** Port number field for port monitors */
    port: string;
    /** Display name for the site */
    name: string;
    /** Selected monitor type */
    monitorType: MonitorType;
    /** Check interval in milliseconds */
    checkInterval: number;
    /** Generated site identifier */
    siteId: string;
    /** Form operation mode (new site vs existing site) */
    addMode: FormMode;
    /** Selected existing site ID when adding to existing */
    selectedExistingSite: string;
    /** Current form validation error */
    formError: string | undefined;
}
⋮----
/** URL field for HTTP monitors */
⋮----
/** Host/IP field for port monitors */
⋮----
/** Port number field for port monitors */
⋮----
/** Display name for the site */
⋮----
/** Selected monitor type */
⋮----
/** Check interval in milliseconds */
⋮----
/** Generated site identifier */
⋮----
/** Form operation mode (new site vs existing site) */
⋮----
/** Selected existing site ID when adding to existing */
⋮----
/** Current form validation error */
⋮----
/**
 * Form actions interface containing all form manipulation functions.
 */
export interface AddSiteFormActions {
    /** Set URL field value */
    setUrl: (value: string) => void;
    /** Set host field value */
    setHost: (value: string) => void;
    /** Set port field value */
    setPort: (value: string) => void;
    /** Set site name field value */
    setName: (value: string) => void;
    /** Set monitor type */
    setMonitorType: (value: MonitorType) => void;
    /** Set check interval */
    setCheckInterval: (value: number) => void;
    /** Set site ID */
    setSiteId: (value: string) => void;
    /** Set form operation mode */
    setAddMode: (value: FormMode) => void;
    /** Set selected existing site */
    setSelectedExistingSite: (value: string) => void;
    /** Set form error message */
    setFormError: (error: string | undefined) => void;
    /** Reset form to initial state */
    resetForm: () => void;
    /** Whether the form is currently valid */
    isFormValid: () => boolean;
}
⋮----
/** Set URL field value */
⋮----
/** Set host field value */
⋮----
/** Set port field value */
⋮----
/** Set site name field value */
⋮----
/** Set monitor type */
⋮----
/** Set check interval */
⋮----
/** Set site ID */
⋮----
/** Set form operation mode */
⋮----
/** Set selected existing site */
⋮----
/** Set form error message */
⋮----
/** Reset form to initial state */
⋮----
/** Whether the form is currently valid */
⋮----
/**
 * Hook for managing add site form state and operations.
 *
 * Features:
 * - Complete form state management
 * - Real-time validation
 * - Support for both new sites and adding monitors to existing sites
 * - Automatic UUID generation for new sites
 * - Form reset functionality
 * - Error handling and display
 *
 * @returns Combined form state and action handlers
 */
export function useAddSiteForm(): AddSiteFormState & AddSiteFormActions
⋮----
// Form field state
⋮----
// Mode and selection state
⋮----
// UI state
⋮----
// Use monitor fields hook for dynamic validation
⋮----
// Reset fields when monitor type changes, but preserve them if they've been explicitly set
⋮----
// Get current monitor type fields
⋮----
// Reset fields that are not used by the current monitor type
⋮----
// Reset name and siteId when switching to new site
⋮----
// Simple validation function without logging - only used for submit button state
⋮----
// Basic validation for mode and name
⋮----
// Dynamic validation based on monitor type fields
⋮----
// Reset form to initial state
⋮----
// State
</file>

<file path="src/hooks/useBackendFocusSync.ts">
/**
 * Hook for synchronizing data when the application window gains focus.
 * Provides functionality to automatically refresh data from the backend
 * when users return to the application after being away.
 */
import { useEffect } from "react";
import { useSitesStore } from "../stores";
/**
 * useBackendFocusSync
 * Adds a window focus event listener that triggers fullSyncFromBackend when enabled.
 * This is useful for ensuring data consistency when the user returns to the app.
 * @param enabled - Set to true to enable focus-based backend sync (default: false)
 */
export function useBackendFocusSync(enabled = false)
⋮----
const handleFocus = (): void =>
⋮----
// Use full sync on focus to ensure complete data consistency
// since the user may have been away for a while
</file>

<file path="src/hooks/useMonitorFields.ts">
/**
 * Hook for accessing monitor field definitions from the registry.
 * Provides field configurations for dynamic form handling.
 */
import { useState, useEffect } from "react";
import type { MonitorFieldDefinition } from "../utils/monitorTypeHelper";
interface UseMonitorFieldsResult {
    /** Get field definitions for a specific monitor type */
    getFields: (monitorType: string) => MonitorFieldDefinition[];
    /** Get required fields for a specific monitor type */
    getRequiredFields: (monitorType: string) => string[];
    /** Check if a field is required for a monitor type */
    isFieldRequired: (monitorType: string, fieldName: string) => boolean;
    /** Whether field definitions are loaded */
    isLoaded: boolean;
}
⋮----
/** Get field definitions for a specific monitor type */
⋮----
/** Get required fields for a specific monitor type */
⋮----
/** Check if a field is required for a monitor type */
⋮----
/** Whether field definitions are loaded */
⋮----
/**
 * Hook to access monitor field definitions from the registry.
 */
export function useMonitorFields(): UseMonitorFieldsResult
⋮----
const loadFieldConfigs = async () =>
⋮----
setIsLoaded(true); // Set loaded even on error to prevent infinite loading
⋮----
const getFields = (monitorType: string): MonitorFieldDefinition[] =>
⋮----
// eslint-disable-next-line security/detect-object-injection
⋮----
const getRequiredFields = (monitorType: string): string[] =>
const isFieldRequired = (monitorType: string, fieldName: string): boolean =>
</file>

<file path="src/hooks/useMonitorTypes.ts">
/**
 * Custom hook for managing monitor type configurations from the backend.
 * Provides async loading with caching and error handling.
 */
import { useState, useEffect } from "react";
import { getMonitorTypeOptions } from "../utils/monitorTypeHelper";
interface UseMonitorTypesResult {
    /** Monitor type options for form select fields */
    options: { label: string; value: string }[];
    /** Whether monitor types are currently loading */
    isLoading: boolean;
    /** Error message if loading failed */
    error: string | undefined;
    /** Refresh monitor types from backend */
    refresh: () => Promise<void>;
}
⋮----
/** Monitor type options for form select fields */
⋮----
/** Whether monitor types are currently loading */
⋮----
/** Error message if loading failed */
⋮----
/** Refresh monitor types from backend */
⋮----
/**
 * Hook to load monitor type configurations from backend.
 *
 * @returns Monitor type options and loading state
 */
export function useMonitorTypes(): UseMonitorTypesResult
⋮----
const loadMonitorTypes = async () =>
⋮----
// Fallback to basic options if backend fails
⋮----
const refresh = async () =>
</file>

<file path="src/hooks/useStateSynchronization.ts">
/**
 * Frontend hook for integrating with unified state management system.
 *
 * @remarks
 * This hook bridges the gap between frontend Zustand stores and the
 * backend state synchronization service, providing real-time updates
 * and consistent state across all application layers.
 */
import { useCallback, useEffect } from "react";
import { Site } from "../types";
/**
 * Configuration for state synchronization hook.
 *
 * @public
 */
export interface StateSyncHookConfig {
    /** Function to update sites in frontend store */
    setSites: (sites: Site[]) => void;
    /** Function to get current sites from frontend store */
    getSites: () => Site[];
    /** Optional callback for sync events */
    onSync?: (action: "update" | "delete" | "bulk-sync", siteIdentifier?: string) => void;
}
⋮----
/** Function to update sites in frontend store */
⋮----
/** Function to get current sites from frontend store */
⋮----
/** Optional callback for sync events */
⋮----
/**
 * Hook for integrating frontend store with backend state synchronization.
 *
 * @param config - Configuration for state synchronization
 * @returns Sync control functions
 *
 * @example
 * ```tsx
 * const { enableSync, disableSync, manualSync } = useStateSynchronization({
 *   setSites: useSitesStore.getState().setSites,
 *   getSites: useSitesStore.getState().getSites,
 *   onSync: (action, id) => console.log(`Sync: ${action}`, id)
 * });
 * ```
 *
 * @public
 */
export function useStateSynchronization(config: StateSyncHookConfig)
⋮----
/**
     * Handle backend state updates.
     */
⋮----
// Only update if sites have actually changed to avoid unnecessary re-renders
⋮----
/**
     * Listen for state synchronization events from backend.
     */
⋮----
// Setup IPC listener for state changes
⋮----
// No cleanup needed if no listener was set up
⋮----
/**
     * Force synchronization from backend.
     */
⋮----
// The sync event will be received via the onStateSyncEvent listener
⋮----
/**
     * Check if frontend state is synchronized with backend.
     */
⋮----
// Note: This method would need to be added to the electronAPI interface
⋮----
return true; // Assume synchronized if no backend integration
⋮----
/** Force synchronization from backend */
⋮----
/** Check if state is synchronized */
⋮----
/** Manual sync handler for direct use */
⋮----
/**
 * Simple alias for basic state synchronization functionality.
 */
export function useBasicStateSynchronization(config: StateSyncHookConfig)
</file>

<file path="src/index.css">
/* stylelint-disable-next-line import-notation -- This is the proper way for Tailwind CSS */
⋮----
:root {
⋮----
/* Define gray color palette for compatibility */
⋮----
/* Define other color palettes used in the app */
⋮----
/* Status indicator background and text colors for theming (match themes.ts) */
--color-status-up-bg: #e6f9f0; /* light background for up */
--color-status-up: #10b981; /* text and main color for up */
⋮----
/* Font and general styling */
⋮----
body {
#root {
@layer base {
⋮----
html {
⋮----
@layer components {
⋮----
.status-indicator {
.status-up {
.status-down {
.status-pending {
.status-paused {
</file>

<file path="src/services/chartConfig.ts">
/**
 * Chart configuration service for consistent, theme-aware data visualization.
 *
 * @remarks
 * Provides centralized Chart.js configuration management with automatic theme
 * integration for consistent styling across all charts in the application.
 * This service ensures that charts maintain visual consistency and respond
 * to theme changes appropriately.
 *
 * The service supports multiple chart types with optimized configurations:
 * - Line charts for time-series data (response times, uptime trends)
 * - Area charts for filled visualizations
 * - Doughnut charts for status distributions
 * - Responsive design with mobile-friendly defaults
 *
 * @example
 * ```typescript
 * const chartConfig = new ChartConfigService(currentTheme);
 * const lineConfig = chartConfig.getLineChartConfig();
 * const doughnutConfig = chartConfig.getDoughnutChartConfig();
 * ```
 *
 * @packageDocumentation
 */
import { ChartOptions } from "chart.js";
import { Theme } from "../theme";
/**
 * Chart Configuration Service for theme-aware chart styling.
 *
 * @remarks
 * Centralizes all chart configurations to ensure consistency and maintainability
 * across the application. The service automatically applies theme colors, fonts,
 * and spacing to all chart configurations.
 *
 * @public
 */
export class ChartConfigService {
⋮----
/** Current theme instance for styling configuration */
⋮----
/**
     * Creates a new chart configuration service.
     *
     * @param theme - Theme instance containing colors, typography, and spacing
     */
constructor(theme: Theme)
/**
     * Get base configuration shared across all chart types.
     *
     * @returns Partial chart options with common styling and behavior
     *
     * @remarks
     * Provides consistent foundation for all charts including responsive behavior,
     * theme-aware colors, typography, and tooltip styling. This configuration
     * is extended by specific chart type methods.
     *
     * This is an internal method used by other configuration methods.
     */
private getBaseConfig(): Partial<ChartOptions>
/**
     * Get base scale configuration
     */
private getBaseScale()
/**
     * Response time line chart configuration
     */
getLineChartConfig(): ChartOptions<"line">
/**
     * Status distribution bar chart configuration
     */
getBarChartConfig(): ChartOptions<"bar">
/**
     * Uptime doughnut chart configuration
     */
getDoughnutChartConfig(totalChecks: number): ChartOptions<"doughnut">
⋮----
/**
 * React hook for getting theme-aware chart configurations.
 *
 * @param theme - Current theme object for styling charts
 * @param totalChecks - Total number of checks for pie chart configuration
 * @returns Object containing various chart configuration options
 */
export function useChartConfigs(theme: Theme, totalChecks = 0)
</file>

<file path="src/services/logger.ts">
/**
 * Centralized logging service using electron-log for consistent logging across processes.
 *
 * @remarks
 * Provides structured logging functionality organized by functional domains
 * (app, site, monitor, store) for contextual logging that's easy to filter.
 *
 * @packageDocumentation
 */
import log from "electron-log/renderer";
// Configure electron-log for renderer process
// The /renderer import handles the connection to main process automatically
⋮----
// File logging will be handled by the main process via IPC
⋮----
// Create logger with app context
⋮----
// Log application lifecycle events
⋮----
// Debug level - for development debugging
⋮----
// Error level - errors that should be investigated
⋮----
// Info level - general application flow
⋮----
// Raw access to electron-log for special cases
⋮----
// Silly level - extremely detailed debugging
⋮----
// Specialized logging methods for common scenarios
// Log site monitoring events
⋮----
// Log system/electron events
⋮----
// Log user actions
⋮----
// Verbose level - very detailed debugging
⋮----
// Warn level - something unexpected but not an error
⋮----
// Also export a typed interface for better IDE support
export type Logger = typeof logger;
</file>

<file path="src/stores/error/useErrorStore.ts">
/**
 * Centralized error store for managing application errors and loading states.
 * Provides global error handling and store-specific error tracking.
 */
import { create } from "zustand";
import type { ErrorStore } from "./types";
import { logStoreAction } from "../utils";
⋮----
// Actions
⋮----
// Use destructuring to avoid dynamic delete
// eslint-disable-next-line @typescript-eslint/no-unused-vars
⋮----
// eslint-disable-next-line security/detect-object-injection
⋮----
// eslint-disable-next-line security/detect-object-injection
⋮----
// State
</file>

<file path="src/stores/index.ts">
/**
 * Centralized exports for all store modules in the application.
 *
 * @remarks
 * Barrel file providing organized entry point for stores, types, and utilities.
 * Exports are grouped by functional domain for easy navigation.
 *
 * @packageDocumentation
 * @public
 */
// =============================================================================
// Error Handling
// =============================================================================
// Error boundary component and store for centralized error management
⋮----
// =============================================================================
// Sites Management
// =============================================================================
// Core site management store and related functionality
⋮----
// Site monitoring actions and types
⋮----
// Site operations actions and types
⋮----
// Sites state management
⋮----
// Site sync actions and types
⋮----
// Site services and utilities
⋮----
// =============================================================================
// Application Settings & Configuration
// =============================================================================
// User preferences and application settings management
⋮----
// =============================================================================
// User Interface State
// =============================================================================
// UI state, navigation, and interaction management
⋮----
// =============================================================================
// Application Updates
// =============================================================================
// Update checking, downloading, and installation management
⋮----
// =============================================================================
// Statistics & Analytics
// =============================================================================
// Site performance statistics and analytics data
⋮----
// =============================================================================
// Shared Types & Utilities
// =============================================================================
// Common types, constants, and utility functions used across stores
</file>

<file path="src/stores/sites/types.ts">
/**
 * Sites store types and interfaces.
 */
import type { Site, StatusUpdate, Monitor } from "../../types";
export interface SitesState {
    /** Array of monitored sites */
    sites: Site[];
    /** Selected monitor IDs per site (UI state, not persisted) */
    selectedMonitorIds: Record<string, string>;
    /** Currently selected site identifier */
    selectedSiteId: string | undefined;
}
⋮----
/** Array of monitored sites */
⋮----
/** Selected monitor IDs per site (UI state, not persisted) */
⋮----
/** Currently selected site identifier */
⋮----
export interface SitesActions {
    /** Initialize sites data from backend */
    initializeSites: () => Promise<{ success: boolean; sitesLoaded: number; message: string }>;
    /** Create a new site */
    createSite: (siteData: { identifier: string; name?: string; monitors?: Monitor[] }) => Promise<void>;
    /** Delete a site */
    deleteSite: (identifier: string) => Promise<void>;
    /** Check a site now */
    checkSiteNow: (siteId: string, monitorId: string) => Promise<void>;
    /** Modify an existing site */
    modifySite: (identifier: string, updates: Partial<Site>) => Promise<void>;
    /** Update site check interval */
    updateSiteCheckInterval: (siteId: string, monitorId: string, interval: number) => Promise<void>;
    /** Update monitor retry attempts */
    updateMonitorRetryAttempts: (siteId: string, monitorId: string, retryAttempts: number) => Promise<void>;
    /** Update monitor timeout */
    updateMonitorTimeout: (siteId: string, monitorId: string, timeout: number) => Promise<void>;
    /** Start monitoring for a site monitor */
    startSiteMonitorMonitoring: (siteId: string, monitorId: string) => Promise<void>;
    /** Start monitoring for all monitors of a site */
    startSiteMonitoring: (siteId: string) => Promise<void>;
    /** Stop monitoring for a site monitor */
    stopSiteMonitorMonitoring: (siteId: string, monitorId: string) => Promise<void>;
    /** Stop monitoring for all monitors of a site */
    stopSiteMonitoring: (siteId: string) => Promise<void>;
    /** Add a monitor to an existing site */
    addMonitorToSite: (siteId: string, monitor: Monitor) => Promise<void>;
    /** Remove a monitor from a site */
    removeMonitorFromSite: (siteId: string, monitorId: string) => Promise<void>;
    /** Sync sites from backend */
    syncSitesFromBackend: () => Promise<void>;
    /** Full sync from backend */
    fullSyncFromBackend: () => Promise<void>;
    /** Set sites data */
    setSites: (sites: Site[]) => void;
    /** Add a site to the store */
    addSite: (site: Site) => void;
    /** Remove a site from the store */
    removeSite: (identifier: string) => void;
    /** Set selected site */
    setSelectedSite: (site: Site | undefined) => void;
    /** Set selected monitor ID for a site */
    setSelectedMonitorId: (siteId: string, monitorId: string) => void;
    /** Get selected monitor ID for a site */
    getSelectedMonitorId: (siteId: string) => string | undefined;
    /** Get the currently selected site */
    getSelectedSite: () => Site | undefined;
    /** Subscribe to status updates */
    subscribeToStatusUpdates: (callback: (update: StatusUpdate) => void) => void;
    /** Unsubscribe from status updates */
    unsubscribeFromStatusUpdates: () => void;
    /** Download SQLite backup */
    downloadSQLiteBackup: () => Promise<void>;
}
⋮----
/** Initialize sites data from backend */
⋮----
/** Create a new site */
⋮----
/** Delete a site */
⋮----
/** Check a site now */
⋮----
/** Modify an existing site */
⋮----
/** Update site check interval */
⋮----
/** Update monitor retry attempts */
⋮----
/** Update monitor timeout */
⋮----
/** Start monitoring for a site monitor */
⋮----
/** Start monitoring for all monitors of a site */
⋮----
/** Stop monitoring for a site monitor */
⋮----
/** Stop monitoring for all monitors of a site */
⋮----
/** Add a monitor to an existing site */
⋮----
/** Remove a monitor from a site */
⋮----
/** Sync sites from backend */
⋮----
/** Full sync from backend */
⋮----
/** Set sites data */
⋮----
/** Add a site to the store */
⋮----
/** Remove a site from the store */
⋮----
/** Set selected site */
⋮----
/** Set selected monitor ID for a site */
⋮----
/** Get selected monitor ID for a site */
⋮----
/** Get the currently selected site */
⋮----
/** Subscribe to status updates */
⋮----
/** Unsubscribe from status updates */
⋮----
/** Download SQLite backup */
⋮----
export type SitesStore = SitesState & SitesActions;
</file>

<file path="src/stores/sites/useSiteMonitoring.ts">
/**
 * Site monitoring operations module.
 * Handles monitoring start/stop operations and manual checks.
 *
 * Note: Empty clearError and setLoading functions are intentional in withErrorHandling calls
 * as error handling is managed centrally by the store infrastructure.
 */
import { logStoreAction, withErrorHandling } from "../utils";
import { MonitoringService, SiteService } from "./services";
export interface SiteMonitoringActions {
    /** Check a site now */
    checkSiteNow: (siteId: string, monitorId: string) => Promise<void>;
    /** Start monitoring for all monitors of a site */
    startSiteMonitoring: (siteId: string) => Promise<void>;
    /** Start monitoring for a site monitor */
    startSiteMonitorMonitoring: (siteId: string, monitorId: string) => Promise<void>;
    /** Stop monitoring for all monitors of a site */
    stopSiteMonitoring: (siteId: string) => Promise<void>;
    /** Stop monitoring for a site monitor */
    stopSiteMonitorMonitoring: (siteId: string, monitorId: string) => Promise<void>;
}
⋮----
/** Check a site now */
⋮----
/** Start monitoring for all monitors of a site */
⋮----
/** Start monitoring for a site monitor */
⋮----
/** Stop monitoring for all monitors of a site */
⋮----
/** Stop monitoring for a site monitor */
⋮----
export type SiteMonitoringDependencies = Record<string, never>;
export const createSiteMonitoringActions = (): SiteMonitoringActions => (
⋮----
// Backend will emit 'status-update', which will trigger incremental update
⋮----
// No need for manual sync - StatusUpdateHandler will update UI via events
⋮----
// No need for manual sync - StatusUpdateHandler will update UI via events
⋮----
// No need for manual sync - StatusUpdateHandler will update UI via events
⋮----
// No need for manual sync - StatusUpdateHandler will update UI via events
</file>

<file path="src/stores/sites/useSitesState.ts">
/**
 * Sites state management module.
 * Handles core state operations for sites, selected site, and monitor selections.
 */
import type { Site } from "../../types";
import { logStoreAction } from "../utils";
export interface SitesState {
    /** Array of monitored sites */
    sites: Site[];
    /** Selected monitor IDs per site (UI state, not persisted) */
    selectedMonitorIds: Record<string, string>;
    /** Currently selected site identifier */
    selectedSiteId: string | undefined;
}
⋮----
/** Array of monitored sites */
⋮----
/** Selected monitor IDs per site (UI state, not persisted) */
⋮----
/** Currently selected site identifier */
⋮----
export interface SitesStateActions {
    /** Set sites data */
    setSites: (sites: Site[]) => void;
    /** Add a site to the store */
    addSite: (site: Site) => void;
    /** Remove a site from the store */
    removeSite: (identifier: string) => void;
    /** Set selected site */
    setSelectedSite: (site: Site | undefined) => void;
    /** Set selected monitor ID for a site */
    setSelectedMonitorId: (siteId: string, monitorId: string) => void;
    /** Get selected monitor ID for a site */
    getSelectedMonitorId: (siteId: string) => string | undefined;
    /** Get the currently selected site */
    getSelectedSite: () => Site | undefined;
}
⋮----
/** Set sites data */
⋮----
/** Add a site to the store */
⋮----
/** Remove a site from the store */
⋮----
/** Set selected site */
⋮----
/** Set selected monitor ID for a site */
⋮----
/** Get selected monitor ID for a site */
⋮----
/** Get the currently selected site */
⋮----
export type SitesStateStore = SitesState & SitesStateActions;
export const createSitesStateActions = (
    set: (function_: (state: SitesState) => Partial<SitesState>) => void,
    get: () => SitesState
): SitesStateActions => (
⋮----
// eslint-disable-next-line security/detect-object-injection
⋮----
// Remove the monitor selection for the removed site
⋮----
// eslint-disable-next-line @typescript-eslint/no-unused-vars
</file>

<file path="src/stores/sites/useSiteSync.ts">
/**
 * Site synchronization operations module.
 * Handles syncing data from backend and status update subscriptions.
 *
 * Note: Empty clearError and setLoading functions are intentional in withErrorHandling calls
 * as error handling is managed centrally by the store infrastructure.
 */
import type { Site, StatusUpdate } from "../../types";
import { logStoreAction, withErrorHandling } from "../utils";
import { SiteService } from "./services";
import { StatusUpdateManager, createStatusUpdateHandler } from "./utils";
export interface SiteSyncActions {
    /** Sync sites from backend */
    syncSitesFromBackend: () => Promise<void>;
    /** Full sync from backend */
    fullSyncFromBackend: () => Promise<void>;
    /** Subscribe to status updates */
    subscribeToStatusUpdates: (callback: (update: StatusUpdate) => void) => {
        success: boolean;
        subscribed: boolean;
        message: string;
    };
    /** Unsubscribe from status updates */
    unsubscribeFromStatusUpdates: () => {
        success: boolean;
        unsubscribed: boolean;
        message: string;
    };
}
⋮----
/** Sync sites from backend */
⋮----
/** Full sync from backend */
⋮----
/** Subscribe to status updates */
⋮----
/** Unsubscribe from status updates */
⋮----
export interface SiteSyncDependencies {
    getSites: () => Site[];
    setSites: (sites: Site[]) => void;
}
// Create a shared status update manager instance
⋮----
export const createSiteSyncActions = (deps: SiteSyncDependencies): SiteSyncActions =>
⋮----
// Handle null/undefined responses from backend by defaulting to empty array
</file>

<file path="src/stores/sites/utils/monitorOperations.ts">
/**
 * Monitor operations utility for handling monitor-related operations.
 * Provides utilities for working with monitor data and configurations.
 */
import { type Monitor, type MonitorType, type Site, ERROR_MESSAGES } from "../../types";
/**
 * Creates a default monitor for a site
 */
export function createDefaultMonitor(overrides: Partial<Monitor> =
⋮----
checkInterval: 300_000, // 5 minutes default
⋮----
responseTime: -1, // Sentinel value for never checked
retryAttempts: 3, // Default retry attempts
⋮----
timeout: 5000, // Default timeout
⋮----
/**
 * Validates monitor data
 */
export function validateMonitor(monitor: Partial<Monitor>): monitor is Monitor
/**
 * Normalizes monitor data ensuring all required fields are present
 */
export function normalizeMonitor(monitor: Partial<Monitor>): Monitor
⋮----
checkInterval: monitor.checkInterval ?? 300_000, // 5 minutes default
⋮----
responseTime: monitor.responseTime ?? -1, // Sentinel value for never checked
retryAttempts: monitor.retryAttempts ?? 3, // Default retry attempts
⋮----
timeout: monitor.timeout ?? 5000, // Default timeout
⋮----
// Only add optional fields if they are explicitly provided
⋮----
/**
 * Finds a monitor in a site by ID
 */
export function findMonitorInSite(site: Site, monitorId: string): Monitor | undefined
/**
 * Updates a monitor in a site
 */
export function updateMonitorInSite(site: Site, monitorId: string, updates: Partial<Monitor>): Site
/**
 * Adds a monitor to a site
 */
export function addMonitorToSite(site: Site, monitor: Monitor): Site
/**
 * Removes a monitor from a site
 */
export function removeMonitorFromSite(site: Site, monitorId: string): Site
/**
 * Validates that a monitor exists in a site
 */
export function validateMonitorExists(site: Site | undefined, monitorId: string): void
/**
 * Creates monitor update operations
 */
⋮----
/**
     * Toggle monitor monitoring state
     */
⋮----
/**
     * Update monitor check interval
     */
⋮----
/**
     * Update monitor retry attempts
     */
⋮----
/**
     * Update monitor status
     */
⋮----
/**
     * Update monitor timeout
     */
</file>

<file path="src/stores/types.ts">
/**
 * Shared types and interfaces for all stores in the application.
 *
 * @remarks
 * Common types, interfaces, and constants used across multiple stores.
 * Provides centralized location for shared functionality and consistency.
 *
 * @packageDocumentation
 */
import { ThemeName } from "../theme";
/**
 * Application update status enumeration.
 *
 * @remarks
 * Represents the various states of the application update process,
 * from initial idle state through checking, downloading, and completion.
 * Used by the updates store to track update progress and display
 * appropriate UI states to the user.
 */
export type UpdateStatus = "idle" | "checking" | "available" | "downloading" | "downloaded" | "error";
/**
 * Chart time range options for data visualization.
 */
export type ChartTimeRange = "1h" | "24h" | "7d" | "30d";
/**
 * Standardized error messages used across the application.
 * @readonly
 */
⋮----
/**
 * Application settings interface for user preferences and configuration.
 */
export interface AppSettings {
    /** Enable desktop notifications for status changes */
    notifications: boolean;
    /** Auto-start monitoring when the application launches */
    autoStart: boolean;
    /** Minimize to system tray instead of closing the application */
    minimizeToTray: boolean;
    /** Current theme name (light, dark, etc.) */
    theme: ThemeName;
    /** Enable sound alerts for status changes */
    soundAlerts: boolean;
    /** Maximum number of history records to keep per monitor */
    historyLimit: number;
}
⋮----
/** Enable desktop notifications for status changes */
⋮----
/** Auto-start monitoring when the application launches */
⋮----
/** Minimize to system tray instead of closing the application */
⋮----
/** Current theme name (light, dark, etc.) */
⋮----
/** Enable sound alerts for status changes */
⋮----
/** Maximum number of history records to keep per monitor */
⋮----
/**
 * Base store interface providing common error handling and loading state functionality.
 *
 * @remarks
 * Standard error handling and loading state pattern used across all stores.
 * All store interfaces should extend this for consistent error handling.
 */
export interface BaseStore {
    /** The last error message, if any */
    lastError: string | undefined;
    /** Whether an async operation is currently in progress */
    isLoading: boolean;
    /** Set an error message in the store */
    setError: (error: string | undefined) => void;
    /** Set the loading state */
    setLoading: (loading: boolean) => void;
    /** Clear the current error message */
    clearError: () => void;
}
⋮----
/** The last error message, if any */
⋮----
/** Whether an async operation is currently in progress */
⋮----
/** Set an error message in the store */
⋮----
/** Set the loading state */
⋮----
/** Clear the current error message */
⋮----
/**
 * Store composition utility type for extracting action methods from store interfaces.
 *
 * @remarks
 * This utility type extracts only the function properties (actions) from a store
 * interface, filtering out state properties. It's useful for creating action-only
 * interfaces or for dependency injection patterns where only actions are needed.
 *
 * @example
 * ```typescript
 * interface MyStore {
 *   data: string[];
 *   isLoading: boolean;
 *   fetchData: () => Promise<void>;
 *   clearData: () => void;
 * }
 *
 * type MyStoreActions = StoreActions<MyStore>;
 * // Result: { fetchData: () => Promise<void>; clearData: () => void; }
 * ```
 */
export type StoreActions<T> = {
    [K in keyof T]: T[K] extends (...arguments_: unknown[]) => unknown ? T[K] : never;
};
/**
 * Store state utility type for extracting state properties from store interfaces.
 *
 * @remarks
 * This utility type extracts only the non-function properties (state) from a store
 * interface, filtering out action methods. It's useful for creating state-only
 * interfaces or for serialization purposes where only data needs to be preserved.
 *
 * @example
 * ```typescript
 * interface MyStore {
 *   data: string[];
 *   isLoading: boolean;
 *   fetchData: () => Promise<void>;
 *   clearData: () => void;
 * }
 *
 * type MyStoreState = StoreState<MyStore>;
 * // Result: { data: string[]; isLoading: boolean; }
 * ```
 */
export type StoreState<T> = {
    [K in keyof T]: T[K] extends (...arguments_: unknown[]) => unknown ? never : T[K];
};
/**
 * Re-exported types from the main types file for convenience.
 *
 * @remarks
 * These re-exports provide convenient access to core application types without
 * needing to import from multiple files. This helps maintain a clean import
 * structure and reduces the number of import statements needed in store files.
 */
</file>

<file path="src/stores/updates/useUpdatesStore.ts">
/**
 * Updates store for managing application updates and notifications.
 * Handles update status, error states, and update operations.
 */
import { create } from "zustand";
import { persist } from "zustand/middleware";
import type { UpdateStatus } from "../types";
import type { UpdatesStore } from "./types";
import { logStoreAction } from "../utils";
⋮----
// State
⋮----
// Actions
</file>

<file path="src/theme/components.tsx">
/**
 * Themed UI components for the Uptime Watcher application.
 *
 * Provides a comprehensive set of themed React components including boxes, buttons,
 * inputs, selects, badges, and specialized components for status display.
 * All components support the application's theming system with variants,
 * surfaces, and responsive design capabilities.
 *
 * Note: className is a standard React prop and should not be renamed.
 */
import React from "react";
import { ARIA_LABEL, TRANSITION_ALL } from "../constants";
import { useTheme, useThemeClasses } from "./useTheme";
import { getStatusIcon, formatResponseTime } from "../utils";
⋮----
// Type aliases for commonly used union types
type BoxVariant = "primary" | "secondary" | "tertiary";
type BoxSurface = "base" | "elevated" | "overlay";
type BoxPadding = "xs" | "sm" | "md" | "lg" | "xl";
type BoxRounded = "none" | "sm" | "md" | "lg" | "xl" | "full";
type BoxShadow = "sm" | "md" | "lg" | "xl" | "inner";
type BoxElement = "div" | "button" | "section" | "article" | "aside" | "header" | "footer" | "nav";
type TextVariant =
    | "primary"
    | "secondary"
    | "tertiary"
    | "inverse"
    | "error"
    | "success"
    | "warning"
    | "danger"
    | "info";
type TextSize = "xs" | "sm" | "md" | "base" | "lg" | "xl" | "2xl" | "3xl" | "4xl";
type TextWeight = "normal" | "medium" | "semibold" | "bold";
type TextAlign = "left" | "center" | "right" | "justify";
type ButtonVariant = "primary" | "secondary" | "tertiary" | "success" | "warning" | "error" | "ghost" | "outline";
type ButtonSize = "xs" | "sm" | "md" | "lg" | "xl";
type BadgeVariant = "primary" | "secondary" | "success" | "warning" | "error" | "info";
type BadgeSize = "xs" | "sm" | "md" | "lg";
// Constants for commonly duplicated strings
⋮----
interface ThemeProviderProperties {
    readonly children: React.ReactNode;
}
export function ThemeProvider(
⋮----
// Initialize theme on mount
⋮----
interface ThemedBoxProperties {
    readonly variant?: BoxVariant;
    readonly surface?: BoxSurface;
    readonly padding?: BoxPadding;
    readonly rounded?: BoxRounded;
    readonly shadow?: BoxShadow;
    readonly border?: boolean;
    readonly className?: string;
    readonly style?: React.CSSProperties;
    readonly onClick?: (e?: React.MouseEvent<HTMLElement>) => void;
    readonly onMouseEnter?: () => void;
    readonly onMouseLeave?: () => void;
    readonly children: React.ReactNode;
    readonly as?: BoxElement;
    readonly role?: string;
    readonly tabIndex?: number;
    readonly "aria-label"?: string;
}
export function ThemedBox({
    "aria-label": ariaLabel,
    as: Component = "div",
    border = false,
    children,
    className = "",
    onClick,
    onMouseEnter,
    onMouseLeave,
    padding = "md",
    role,
    rounded = "md",
    shadow,
    style = {},
    surface = "base",
    tabIndex,
    variant = "primary",
}: ThemedBoxProperties)
⋮----
// For interactive elements, add proper accessibility attributes
⋮----
interface ThemedTextProperties {
    readonly variant?: TextVariant;
    readonly size?: TextSize;
    readonly weight?: TextWeight;
    readonly align?: TextAlign;
    readonly className?: string;
    readonly style?: React.CSSProperties;
    readonly children: React.ReactNode;
}
export function ThemedText({
    align = "left",
    children,
    className = "",
    size = "base",
    style = {},
    variant = "primary",
    weight = "normal",
}: ThemedTextProperties)
interface ThemedButtonProperties {
    readonly variant?: ButtonVariant;
    readonly size?: ButtonSize;
    readonly type?: "button" | "submit" | "reset";
    readonly disabled?: boolean;
    readonly loading?: boolean;
    readonly fullWidth?: boolean;
    readonly icon?: React.ReactNode;
    readonly iconColor?: string;
    readonly iconPosition?: "left" | "right";
    readonly className?: string;
    readonly style?: React.CSSProperties;
    readonly title?: string;
    readonly onClick?: (e?: React.MouseEvent<HTMLButtonElement>) => void;
    readonly children?: React.ReactNode;
    readonly "aria-label"?: string;
}
/**
 * Maps color name to CSS class for icon coloring.
 *
 * @param color - Color name or custom color value
 * @returns CSS class name or undefined for custom colors
 */
function getIconColorClass(color?: string): string | undefined
⋮----
// If it's a hex or rgb(a) or custom string, fallback to inline style
⋮----
/**
 * Wraps icon in a span with color class or inline style.
 *
 * @param icon - React icon element
 * @param color - Color name or custom color value
 * @returns Colored icon wrapped in span
 */
function renderColoredIcon(icon: React.ReactNode, color?: string)
⋮----
const renderContent = () =>
⋮----
onClick=
⋮----
const getSizeStyles = () =>
⋮----
// Ensure value is always defined to prevent controlled/uncontrolled warnings
⋮----
// Ensure value is always defined to prevent controlled/uncontrolled warnings
⋮----
// Enhanced components with better visual feedback and icons
⋮----
const getSize = () =>
⋮----
const getVariantStyles = () =>
⋮----
const getVariantColor = () =>
const getHeight = () =>
⋮----
export function ThemedTooltip(
</file>

<file path="src/utils/duration.ts">
/**
 * Utility function to calculate the maximum duration for monitoring checks
 * with retry attempts and exponential backoff.
 *
 * @param timeout - Timeout value per attempt in seconds
 * @param retryAttempts - Number of retry attempts
 * @returns Formatted duration string (e.g., "30s", "2m")
 */
export function calculateMaxDuration(timeout: number, retryAttempts: number): string
</file>

<file path="src/utils/dynamicMonitorUi.ts">
/**
 * Dynamic UI utilities that use monitor registry for extensible UI behavior.
 * These utilities eliminate hardcoded monitor type checks throughout the frontend.
 */
import type { MonitorType } from "../types";
import { getMonitorTypeConfig, type MonitorTypeConfig } from "./monitorTypeHelper";
/**
 * Cache for monitor type configurations
 */
⋮----
/**
 * Get monitor type configuration with caching
 */
async function getConfig(monitorType: MonitorType): Promise<MonitorTypeConfig | undefined>
/**
 * Format detail label dynamically based on monitor type configuration.
 *
 * @param monitorType - Type of monitor
 * @param details - Detail value to format
 * @returns Formatted detail string
 *
 * @example
 * ```typescript
 * const label = formatMonitorDetail("http", "200"); // "Response Code: 200"
 * const label = formatMonitorDetail("port", "80");  // "Port: 80"
 * ```
 */
export function formatMonitorDetail(monitorType: MonitorType, details: string): string
⋮----
// Recreate formatter functions based on monitor type since they can't be serialized over IPC
⋮----
// eslint-disable-next-line security/detect-object-injection -- MonitorType is a known safe union type
⋮----
/**
 * Check if monitor type supports response time analytics.
 *
 * @param monitorType - Type of monitor
 * @returns Whether monitor supports response time analytics
 */
export async function supportsResponseTime(monitorType: MonitorType): Promise<boolean>
/**
 * Check if monitor type supports advanced analytics.
 *
 * @param monitorType - Type of monitor
 * @returns Whether monitor supports advanced analytics
 */
export async function supportsAdvancedAnalytics(monitorType: MonitorType): Promise<boolean>
/**
 * Get help text for monitor type form fields.
 *
 * @param monitorType - Type of monitor
 * @returns Object containing primary and secondary help texts
 */
export async function getMonitorHelpTexts(monitorType: MonitorType): Promise<
/**
 * Get analytics label for monitor type.
 *
 * @param monitorType - Type of monitor
 * @returns Analytics label or fallback
 */
export async function getAnalyticsLabel(monitorType: MonitorType): Promise<string>
/**
 * Check if monitor type should show URL in display.
 *
 * @param monitorType - Type of monitor
 * @returns Whether to show URL
 */
export async function shouldShowUrl(monitorType: MonitorType): Promise<boolean>
/**
 * Check if all monitor types in array support response time.
 * Useful for conditional rendering of response time charts.
 *
 * @param monitorTypes - Array of monitor types to check
 * @returns Whether all types support response time
 */
export async function allSupportsResponseTime(monitorTypes: MonitorType[]): Promise<boolean>
/**
 * Check if all monitor types in array support advanced analytics.
 * Useful for conditional rendering of advanced analytics components.
 *
 * @param monitorTypes - Array of monitor types to check
 * @returns Whether all types support advanced analytics
 */
export async function allSupportsAdvancedAnalytics(monitorTypes: MonitorType[]): Promise<boolean>
/**
 * Get available monitor types that support a specific feature.
 *
 * @param feature - Feature to check for ('responseTime' | 'advancedAnalytics')
 * @returns Array of monitor types that support the feature
 */
export async function getTypesWithFeature(feature: "responseTime" | "advancedAnalytics"): Promise<MonitorType[]>
/**
 * Clear the configuration cache. Useful for testing or when monitor types change.
 */
export function clearConfigCache(): void
</file>

<file path="src/utils/monitorTypeHelper.ts">
/**
 * Frontend helper utilities for monitor types.
 * Provides access to monitor type definitions through the IPC bridge.
 */
/**
 * Frontend representation of monitor field definition.
 */
export interface MonitorFieldDefinition {
    /** Field name (matches monitor property) */
    name: string;
    /** Display label for the field */
    label: string;
    /** Input type for form rendering */
    type: "text" | "number" | "url";
    /** Whether field is required */
    required: boolean;
    /** Placeholder text */
    placeholder?: string;
    /** Help text for the field */
    helpText?: string;
    /** Min value for number fields */
    min?: number;
    /** Max value for number fields */
    max?: number;
}
⋮----
/** Field name (matches monitor property) */
⋮----
/** Display label for the field */
⋮----
/** Input type for form rendering */
⋮----
/** Whether field is required */
⋮----
/** Placeholder text */
⋮----
/** Help text for the field */
⋮----
/** Min value for number fields */
⋮----
/** Max value for number fields */
⋮----
/**
 * Frontend representation of monitor type configuration.
 */
export interface MonitorTypeConfig {
    /** Unique identifier for the monitor type */
    type: string;
    /** Human-readable display name */
    displayName: string;
    /** Description of what this monitor checks */
    description: string;
    /** Version of the monitor implementation */
    version: string;
    /** Field definitions for dynamic form generation */
    fields: MonitorFieldDefinition[];
    /** UI display configuration */
    uiConfig?: {
        /** Whether this monitor type supports response time analytics */
        supportsResponseTime?: boolean;
        /** Whether this monitor type supports advanced analytics */
        supportsAdvancedAnalytics?: boolean;
        /** Help text for form fields */
        helpTexts?: {
            primary?: string;
            secondary?: string;
        };
        /** Display preferences */
        display?: {
            showUrl?: boolean;
            showAdvancedMetrics?: boolean;
        };
        /** Detail label formatter for different contexts */
        detailFormats?: {
            /** Format for analytics display */
            analyticsLabel?: string;
            // Note: Functions are excluded as they can't be serialized over IPC
        };
    };
}
⋮----
/** Unique identifier for the monitor type */
⋮----
/** Human-readable display name */
⋮----
/** Description of what this monitor checks */
⋮----
/** Version of the monitor implementation */
⋮----
/** Field definitions for dynamic form generation */
⋮----
/** UI display configuration */
⋮----
/** Whether this monitor type supports response time analytics */
⋮----
/** Whether this monitor type supports advanced analytics */
⋮----
/** Help text for form fields */
⋮----
/** Display preferences */
⋮----
/** Detail label formatter for different contexts */
⋮----
/** Format for analytics display */
⋮----
// Note: Functions are excluded as they can't be serialized over IPC
⋮----
// Cache for monitor type configurations from backend
⋮----
/**
 * Get all available monitor types from backend via IPC.
 * Results are cached for performance.
 */
export async function getAvailableMonitorTypes(): Promise<MonitorTypeConfig[]>
⋮----
// Fallback to empty array if backend is unavailable
⋮----
/**
 * Get configuration for a specific monitor type.
 */
export async function getMonitorTypeConfig(type: string): Promise<MonitorTypeConfig | undefined>
/**
 * Get form options for monitor type selector.
 */
export async function getMonitorTypeOptions(): Promise<
/**
 * Clear the monitor type cache.
 * Useful for forcing a refresh of monitor type data.
 */
export function clearMonitorTypeCache(): void
</file>

<file path="src/utils/monitorValidation.ts">
/**
 * Registry-based monitor validation utilities.
 * Uses the backend monitor type registry for consistent validation.
 */
import type { MonitorType } from "../types";
/**
 * Validate monitor data using backend registry.
 *
 * @param type - Monitor type
 * @param data - Monitor data to validate
 * @returns Promise resolving to validation result
 */
export async function validateMonitorData(
    type: MonitorType,
    data: Record<string, unknown>
): Promise<
⋮----
// Use IPC to validate via backend registry
⋮----
// Handle the advanced validation result format
⋮----
/**
 * Validate individual monitor field.
 *
 * @param type - Monitor type
 * @param fieldName - Field name to validate
 * @param value - Field value
 * @returns Promise resolving to validation errors (empty if valid)
 */
export async function validateMonitorField(type: MonitorType, fieldName: string, value: unknown): Promise<string[]>
⋮----
// Use the full validation and extract errors for this field
⋮----
// Filter errors to only include those for the specific field
⋮----
/**
 * Create monitor object with proper field mapping.
 *
 * @param type - Monitor type
 * @param fields - Field values
 * @returns Monitor object with type-specific fields
 */
export function createMonitorObject(type: MonitorType, fields: Record<string, unknown>): Record<string, unknown>
</file>

<file path="src/utils/time.ts">
/**
 * Centralized utility functions for time and formatting.
 * Provides consistent time formatting throughout the application.
 */
/**
 * Format response time in a human-readable format.
 * Automatically chooses between milliseconds and seconds based on magnitude.
 *
 * @param time - Response time in milliseconds
 * @returns Formatted time string (e.g., "234ms" or "1.23s")
 */
export function formatResponseTime(time?: number): string
/**
 * Format timestamp in a human-readable relative format.
 * Shows how long ago the timestamp occurred.
 *
 * @param timestamp - Unix timestamp in milliseconds
 * @returns Formatted relative timestamp string (e.g., "2 minutes ago")
 */
export function formatRelativeTimestamp(timestamp: number): string
/**
 * Format timestamp as a full date/time string
 * @param timestamp - Unix timestamp in milliseconds
 * @returns Formatted date/time string
 */
export function formatFullTimestamp(timestamp: number): string
/**
 * Format duration in a human-readable format
 * @param ms - Duration in milliseconds
 * @returns Formatted duration string (e.g., "2h 15m", "45s")
 */
export function formatDuration(ms: number): string
/**
 * Format time duration for monitoring intervals (simple format).
 * Used for displaying check intervals in a concise format.
 * @param milliseconds - Time duration in milliseconds
 * @returns Formatted time string (e.g., "30s", "5m", "1h")
 */
export function formatIntervalDuration(milliseconds: number): string
/**
 * Format time duration with milliseconds for response times (detailed format).
 * Used for displaying response times and performance metrics.
 * @param milliseconds - Time duration in milliseconds
 * @returns Formatted time string (e.g., "123ms", "30s", "5m", "1h")
 */
export function formatResponseDuration(milliseconds: number): string
/**
 * Get display label for interval value.
 * Handles both numeric intervals and interval objects with custom labels.
 * @param interval - Interval configuration (number or object with value/label)
 * @returns Human readable label for the interval
 */
export function getIntervalLabel(interval: number |
import { CHART_TIME_PERIODS } from "../constants";
/**
 * Type for time period keys
 */
export type TimePeriod = keyof typeof CHART_TIME_PERIODS;
/**
 * Format time periods for display
 */
</file>

<file path="electron/managers/ConfigurationManager.ts">
/**
 * Configuration manager for business rules and policies.
 * Centralizes business logic for configuration decisions.
 */
import { DEFAULT_CHECK_INTERVAL } from "../constants";
import { isDev } from "../electronUtils";
import { Site } from "../types";
import { SiteValidator, MonitorValidator } from "./validators/index";
export interface ValidationResult {
    isValid: boolean;
    errors: string[];
}
export interface HistoryRetentionConfig {
    defaultLimit: number;
    maxLimit: number;
    minLimit: number;
}
/**
 * Manages business configuration and policies.
 * Centralizes business rules that were previously scattered across utilities.
 * Uses composition pattern with specialized validators to reduce complexity.
 */
export class ConfigurationManager {
⋮----
constructor()
/**
     * Get the default monitor check interval according to business rules.
     */
public getDefaultMonitorInterval(): number
/**
     * Business rule: Determine if monitoring should be auto-started for a site.
     */
public shouldAutoStartMonitoring(site: Site): boolean
⋮----
// Business rule: Don't auto-start in development mode
⋮----
// Business rule: Only auto-start for sites that have monitors
⋮----
// Business rule: Site monitoring property takes precedence
⋮----
/**
     * Business rule: Determine if a monitor should receive a default interval.
     */
public shouldApplyDefaultInterval(monitor: Site["monitors"][0]): boolean
/**
     * Get history retention configuration according to business rules.
     * These limits align with the HISTORY_LIMIT_OPTIONS available in the UI.
     */
public getHistoryRetentionRules(): HistoryRetentionConfig
⋮----
defaultLimit: 500, // Matches DEFAULT_HISTORY_LIMIT constant
maxLimit: Number.MAX_SAFE_INTEGER, // Matches "Unlimited" option in HISTORY_LIMIT_OPTIONS
minLimit: 25, // Matches lowest option in HISTORY_LIMIT_OPTIONS
⋮----
/**
     * Validate site configuration according to business rules.
     * Delegates to specialized site validator.
     */
public validateSiteConfiguration(site: Site): ValidationResult
/**
     * Validate monitor configuration according to business rules.
     * Delegates to specialized monitor validator.
     */
public validateMonitorConfiguration(monitor: Site["monitors"][0]): ValidationResult
/**
     * Business rule: Get the minimum allowed check interval.
     */
public getMinimumCheckInterval(): number
⋮----
return 1000; // 1 second minimum
⋮----
/**
     * Business rule: Get the minimum allowed timeout.
     */
public getMinimumTimeout(): number
⋮----
return 1000; // 1 second minimum
⋮----
/**
     * Business rule: Get the maximum allowed port number.
     */
public getMaximumPortNumber(): number
/**
     * Business rule: Determine if a site should be included in exports.
     * Delegates to site validator for consistency.
     */
public shouldIncludeInExport(site: Site): boolean
⋮----
// Singleton instance for easy access
</file>

<file path="electron/managers/validators/MonitorValidator.ts">
/**
 * Monitor validation logic extracted for better separation of concerns.
 * Handles all monitor-specific validation rules using registry-driven approach.
 */
import { Site } from "../../types";
import { ValidationResult } from "../../managers/index";
import {
    validateMonitorData,
    isValidMonitorType,
    getRegisteredMonitorTypes,
} from "../../services/monitoring/MonitorTypeRegistry";
/**
 * Validates monitor configuration according to business rules.
 * Uses registry-driven validation with Zod schemas.
 */
export class MonitorValidator {
⋮----
/**
     * Validate monitor configuration according to business rules.
     */
public validateMonitorConfiguration(monitor: Site["monitors"][0]): ValidationResult
/**
     * Validate monitor type-specific requirements using registry and Zod schemas.
     */
private validateMonitorTypeSpecific(monitor: Site["monitors"][0]): string[]
⋮----
// Validate monitor type using registry
⋮----
// Use Zod schema validation from registry
⋮----
/**
     * Validate timing constraints (intervals, timeouts).
     */
private validateTimingConstraints(monitor: Site["monitors"][0]): string[]
/**
     * Validate retry attempts configuration.
     */
private validateRetryAttempts(monitor: Site["monitors"][0]): string[]
/**
     * Business rule: Determine if a monitor should receive a default interval.
     */
public shouldApplyDefaultInterval(monitor: Site["monitors"][0]): boolean
</file>

<file path="electron/preload.ts">
/**
 * Preload script that exposes safe IPC communication to the renderer process.
 *
 * @remarks
 * Creates a secure bridge between main and renderer processes using contextBridge.
 * Organized by functional domains: sites, monitoring, data, settings, events, system.
 *
 * @packageDocumentation
 */
import { contextBridge, ipcRenderer } from "electron";
import { Site } from "./types";
/**
 * Site management API methods for CRUD operations.
 */
⋮----
/**
     * Add a new site with its monitors to the application.
     *
     * @param site - Complete site object with monitors
     * @returns Promise resolving to the created site with assigned IDs
     */
⋮----
/**
     * Trigger an immediate health check for a specific monitor.
     *
     * @param identifier - Unique site identifier
     * @param monitorId - Unique monitor identifier
     * @returns Promise resolving when check is complete
     */
⋮----
/**
     * Retrieve all configured sites from the database.
     *
     * @returns Promise resolving to array of all sites with their monitors
     */
⋮----
/**
     * Remove a specific monitor from a site.
     *
     * @param siteIdentifier - Unique site identifier
     * @param monitorId - Unique monitor identifier to remove
     * @returns Promise resolving when monitor is removed
     */
⋮----
/**
     * Remove a site and all its associated data (monitors, history, etc.).
     *
     * @param identifier - Unique site identifier
     * @returns Promise resolving when site is completely removed
     */
⋮----
/**
     * Update site properties (name, monitoring status, etc.).
     *
     * @param identifier - Unique site identifier
     * @param updates - Partial site object with properties to update
     * @returns Promise resolving when update is complete
     */
⋮----
/**
 * Monitoring control API methods for starting and stopping health checks.
 *
 * @remarks
 * Controls the monitoring lifecycle for sites and individual monitors.
 * All monitoring operations are asynchronous and affect the background
 * monitoring scheduler.
 */
⋮----
/**
     * Start monitoring for all configured sites.
     *
     * @returns Promise resolving when all monitors are started
     */
⋮----
/**
     * Start monitoring for a specific site or individual monitor.
     *
     * @param identifier - Unique site identifier
     * @param monitorId - Optional specific monitor ID (if omitted, starts all monitors for the site)
     * @returns Promise resolving when monitoring is started
     */
⋮----
/**
     * Stop monitoring for all sites.
     *
     * @returns Promise resolving when all monitors are stopped
     */
⋮----
/**
     * Stop monitoring for a specific site or individual monitor.
     *
     * @param identifier - Unique site identifier
     * @param monitorId - Optional specific monitor ID (if omitted, stops all monitors for the site)
     * @returns Promise resolving when monitoring is stopped
     */
⋮----
/**
 * Data management API methods for import, export, and backup operations.
 *
 * @remarks
 * Handles application data persistence operations including JSON import/export
 * for configuration backup and SQLite database backup for complete data recovery.
 */
⋮----
/**
     * Download a complete SQLite database backup.
     *
     * @returns Promise resolving to object containing backup data and suggested filename
     *
     * @example
     * ```typescript
     * const { buffer, fileName } = await window.electronAPI.data.downloadSQLiteBackup();
     * const blob = new Blob([buffer], { type: 'application/octet-stream' });
     * // Save blob as file with fileName
     * ```
     */
⋮----
/**
     * Export all application data as JSON string.
     *
     * @returns Promise resolving to JSON string containing all sites, monitors, and settings
     */
⋮----
/**
     * Import application data from JSON string.
     *
     * @param data - JSON string containing application data to import
     * @returns Promise resolving to true if import was successful, false otherwise
     */
⋮----
/**
 * Settings and configuration API methods.
 *
 * @remarks
 * Manages application-wide configuration settings that affect behavior
 * such as history retention, notification preferences, and other user preferences.
 */
⋮----
/**
     * Get the current history retention limit.
     *
     * @returns Promise resolving to the number of history records kept per monitor
     */
⋮----
/**
     * Update the history retention limit and prune existing history.
     *
     * @param limit - The new maximum number of history records to keep per monitor
     * @returns Promise resolving when the limit is updated and old records are pruned
     *
     * @remarks
     * This operation will immediately prune history records that exceed the new limit
     * across all monitors to free up storage space.
     */
⋮----
/**
 * Event handling API methods for real-time communication.
 *
 * @remarks
 * Provides methods to listen for events from the main process, enabling
 * real-time UI updates when monitor statuses change or other significant
 * events occur in the background.
 */
⋮----
/**
     * Register a callback for monitor status update events.
     *
     * @param callback - Function to call when a monitor status changes
     *
     * @remarks
     * This is the primary way to receive real-time updates about monitor
     * status changes for UI updates and notifications.
     */
⋮----
/**
     * Register a callback for monitoring started events.
     *
     * @param callback - Function to call when monitoring starts for a site/monitor
     *
     * @remarks
     * Called when a monitor begins actively monitoring a site.
     */
⋮----
/**
     * Register a callback for monitoring stopped events.
     *
     * @param callback - Function to call when monitoring stops for a site/monitor
     *
     * @remarks
     * Called when a monitor stops actively monitoring a site.
     */
⋮----
/**
     * Register a callback for test events (development/debugging).
     *
     * @param callback - Function to call when test events are received
     *
     * @remarks
     * Used primarily for development and debugging purposes.
     */
⋮----
/**
     * Register a callback for application update status events.
     *
     * @param callback - Function to call when update status changes
     *
     * @remarks
     * Receives events about application updates (checking, downloading, ready to install).
     */
⋮----
/**
     * Remove all event listeners for a specific channel.
     *
     * @param channel - The event channel to clear listeners from
     *
     * @remarks
     * Use this for cleanup when components unmount to prevent memory leaks.
     */
⋮----
/**
 * System and application-level API methods.
 *
 * @remarks
 * Handles system-level operations like application updates, external
 * URL opening, and other OS integration features.
 */
⋮----
/**
     * Quit the application and install a pending update.
     *
     * @remarks
     * Only effective when an update has been downloaded and is ready to install.
     * This will close the application and start the update installer.
     */
⋮----
/**
     * Open a URL in the user's default external browser.
     *
     * @param url - The URL to open in the external browser
     *
     * @remarks
     * Provides a secure way to open external links without navigating
     * away from the application.
     */
⋮----
/**
 * State synchronization API for real-time frontend updates.
 *
 * @remarks
 * Provides methods for registering event listeners for state changes
 * and managing synchronization between backend and frontend stores.
 */
⋮----
/**
     * Register listener for state synchronization events.
     *
     * @param callback - Function to call when state changes occur
     * @returns Cleanup function to remove the listener
     */
⋮----
const handler = (_event: Electron.IpcRendererEvent, eventData: Parameters<typeof callback>[0]) =>
⋮----
/**
     * Manually request a full state synchronization.
     *
     * @returns Promise resolving when sync is complete
     */
⋮----
/**
 * Monitor types API methods for accessing monitor type registry.
 *
 * @remarks
 * Provides access to available monitor types and their configurations
 * for dynamic form generation and validation.
 */
⋮----
/**
     * Get all available monitor types with their configurations.
     *
     * @returns Promise resolving to array of monitor type configurations
     */
⋮----
/**
     * Validate monitor data using backend registry.
     *
     * @param type - Monitor type to validate
     * @param data - Monitor data to validate
     * @returns Promise resolving to validation result
     */
⋮----
/**
 * Expose the organized API to the renderer process via contextBridge.
 *
 * @remarks
 * This creates the `window.electronAPI` object available in the renderer process.
 * The API is organized by functional domains for better maintainability and
 * type safety. Each domain corresponds to a specific area of functionality.
 */
⋮----
// Domain-specific APIs organized for maintainability
</file>

<file path="electron/services/database/DatabaseService.ts">
import { app } from "electron";
import { Database } from "node-sqlite3-wasm";
// eslint-disable-next-line unicorn/import-style -- Need namespace import for both sync and async usage
⋮----
import { logger } from "../../utils/index";
import {
    createDatabaseBackup,
    createDatabaseTables,
    createDatabaseIndexes,
    setupMonitorTypeValidation,
} from "./utils/index";
/**
 * Database service for SQLite connection and transaction management.
 *
 * @remarks
 * Provides a singleton interface for database operations with automatic
 * connection management, schema initialization, and transaction support.
 * All database operations should go through this service for consistency.
 *
 * @example
 * ```typescript
 * const dbService = DatabaseService.getInstance();
 * await dbService.initialize();
 * const db = dbService.getDatabase();
 * ```
 */
export class DatabaseService {
⋮----
/**
     * Get the singleton database service instance.
     *
     * @returns The shared DatabaseService instance
     *
     * @remarks
     * Uses singleton pattern to ensure only one database connection
     * exists throughout the application lifecycle.
     */
public static getInstance(): DatabaseService
⋮----
/**
     * Private constructor for singleton pattern.
     *
     * @remarks
     * Use {@link DatabaseService.getInstance} to get the service instance.
     */
private constructor()
⋮----
// Private constructor for singleton pattern
⋮----
/**
     * Initialize the database connection and create tables if they don't exist.
     *
     * @returns The initialized database instance
     *
     * @throws {@link Error} When database initialization fails
     *
     * @remarks
     * Creates the database file in the user data directory if it doesn't exist.
     * Sets up the complete schema including all required tables and indexes.
     * Safe to call multiple times - returns existing connection if already initialized.
     */
public initialize(): Database
/**
     * Get the database instance.
     *
     * @returns The active database connection
     *
     * @throws {@link Error} When database is not initialized
     *
     * @remarks
     * Call {@link DatabaseService.initialize} first to set up the database connection.
     */
public getDatabase(): Database
/**
     * Create a backup of the database as a downloadable buffer.
     *
     * @returns Promise resolving to backup data and filename
     *
     * @throws {@link Error} When backup creation fails
     *
     * @remarks
     * Creates a compressed backup of the entire database suitable for download or storage.
     * The backup includes all tables, data, and schema information.
     */
public async downloadBackup(): Promise<
/**
     * Execute a function within a database transaction.
     *
     * @param operation - Function to execute within the transaction
     * @returns Promise resolving to the operation result
     *
     * @throws {@link Error} When transaction fails or operation throws
     *
     * @remarks
     * Automatically handles transaction lifecycle:
     * - Begins transaction before operation
     * - Commits transaction on successful completion
     * - Rolls back transaction if operation throws
     * Ensures data consistency for complex operations involving multiple queries.
     */
public async executeTransaction<T>(operation: (db: Database) => Promise<T>): Promise<T>
/**
     * Close the database connection.
     *
     * @throws {@link Error} When connection close fails
     *
     * @remarks
     * Safely closes the database connection and cleans up resources.
     * Should be called during application shutdown to ensure proper cleanup.
     */
public close(): void
</file>

<file path="electron/services/database/utils/historyManipulation.ts">
import { Database } from "node-sqlite3-wasm";
import { isDev } from "../../../electronUtils";
import { StatusHistory } from "../../../types";
import { logger } from "../../../utils/index";
/**
 * Utility functions for manipulating history data in the database.
 */
/**
 * Add a new history entry for a monitor.
 */
export function addHistoryEntry(db: Database, monitorId: string, entry: StatusHistory, details?: string): void
/**
 * Delete history entries for a specific monitor.
 */
export function deleteHistoryByMonitorId(db: Database, monitorId: string): void
/**
 * Clear all history from the database.
 */
export function deleteAllHistory(db: Database): void
/**
 * Prune old history entries for a monitor, keeping only the most recent entries.
 */
export function pruneHistoryForMonitor(db: Database, monitorId: string, limit: number): void
⋮----
// Get entries to delete (keep only the most recent 'limit' entries)
⋮----
// Use parameterized query to avoid SQL injection
⋮----
/**
 * Bulk insert history entries (for import functionality).
 * Assumes it's called within an existing transaction context.
 * Uses a prepared statement for better performance.
 */
export function bulkInsertHistory(
    db: Database,
    monitorId: string,
    historyEntries: (StatusHistory & { details?: string })[]
): void
⋮----
// Prepare the statement once for better performance
</file>

<file path="electron/services/monitoring/MonitorScheduler.ts">
import { isDev } from "../../electronUtils";
import { Site } from "../../types";
import { logger } from "../../utils/index";
/**
 * Service for managing monitor scheduling and intervals.
 * Handles per-monitor interval timers and scheduling logic.
 */
export class MonitorScheduler {
⋮----
/**
     * Set the callback function to execute when a monitor check is scheduled.
     */
public setCheckCallback(callback: (siteIdentifier: string, monitorId: string) => Promise<void>): void
/**
     * Perform an immediate check for a monitor (used when starting monitoring).
     */
public async performImmediateCheck(siteIdentifier: string, monitorId: string): Promise<void>
/**
     * Start monitoring for a specific monitor with its own interval.
     */
public startMonitor(siteIdentifier: string, monitor: Site["monitors"][0]): boolean
⋮----
// Stop existing interval if any
⋮----
// Use monitor-specific checkInterval
⋮----
// Start interval immediately
⋮----
// Perform immediate check when starting (without waiting for interval)
⋮----
/**
     * Stop monitoring for a specific monitor.
     */
public stopMonitor(siteIdentifier: string, monitorId: string): boolean
/**
     * Start monitoring for all monitors in a site.
     */
public startSite(site: Site): void
/**
     * Stop monitoring for all monitors in a site.
     */
public stopSite(siteIdentifier: string, monitors?: Site["monitors"]): void
⋮----
// Stop specific monitors
⋮----
// Stop all monitors for this site
⋮----
/**
     * Stop all monitoring intervals.
     */
public stopAll(): void
/**
     * Restart monitoring for a specific monitor (useful when interval changes).
     */
public restartMonitor(siteIdentifier: string, monitor: Site["monitors"][0]): boolean
/**
     * Check if a monitor is currently being monitored.
     */
public isMonitoring(siteIdentifier: string, monitorId: string): boolean
/**
     * Get the number of active monitoring intervals.
     */
public getActiveCount(): number
/**
     * Get all active monitoring keys.
     */
public getActiveMonitors(): string[]
</file>

<file path="electron/services/monitoring/MonitorTypeRegistry.ts">
/**
 * Extensible monitor type system for new monitoring capabilities.
 *
 * @remarks
 * This new architecture replaces hard-coded monitor types with a plugin-based
 * system that allows easy addition of new monitor types without code changes
 * in multiple files.
 */
/* eslint-disable security/detect-object-injection */
// ^ Dynamic object access is required for flexible monitor type registration
// Property names come from validated monitor configurations
import { z } from "zod";
import validator from "validator";
import { HttpMonitor } from "./HttpMonitor";
import { PortMonitor } from "./PortMonitor";
import { advancedValidationEngine, ValidationRuleBuilder, CommonValidationRules } from "./AdvancedValidationEngine";
import { EnhancedTypeGuard } from "./EnhancedTypeGuards";
import { migrationRegistry, versionManager, createMigrationOrchestrator, exampleMigrations } from "./MigrationSystem";
import { logger } from "../../utils/logger";
// Field definition for dynamic form generation
export interface MonitorFieldDefinition {
    /** Field name (matches monitor property) */
    name: string;
    /** Display label for the field */
    label: string;
    /** Input type for form rendering */
    type: "text" | "number" | "url";
    /** Whether field is required */
    required: boolean;
    /** Placeholder text */
    placeholder?: string;
    /** Help text for the field */
    helpText?: string;
    /** Min value for number fields */
    min?: number;
    /** Max value for number fields */
    max?: number;
}
⋮----
/** Field name (matches monitor property) */
⋮----
/** Display label for the field */
⋮----
/** Input type for form rendering */
⋮----
/** Whether field is required */
⋮----
/** Placeholder text */
⋮----
/** Help text for the field */
⋮----
/** Min value for number fields */
⋮----
/** Max value for number fields */
⋮----
// UI configuration for monitor type display
export interface MonitorUIConfig {
    /** Detail label formatter function name */
    detailLabelFormatter?: string;
    /** Chart data formatters */
    chartFormatters?: {
        responseTime?: boolean;
        uptime?: boolean;
        advanced?: boolean;
    };
    /** Help text for form fields */
    helpTexts?: {
        primary?: string;
        secondary?: string;
    };
    /** Display preferences */
    display?: {
        showUrl?: boolean;
        showPort?: boolean;
        showAdvancedMetrics?: boolean;
    };
}
⋮----
/** Detail label formatter function name */
⋮----
/** Chart data formatters */
⋮----
/** Help text for form fields */
⋮----
/** Display preferences */
⋮----
// Base monitor type definition
export interface BaseMonitorConfig {
    /** Unique identifier for the monitor type */
    readonly type: string;
    /** Human-readable display name */
    readonly displayName: string;
    /** Description of what this monitor checks */
    readonly description: string;
    /** Version of the monitor implementation */
    readonly version: string;
    /** Field definitions for dynamic form generation */
    readonly fields: MonitorFieldDefinition[];
    /** Zod validation schema for this monitor type */
    readonly validationSchema: z.ZodSchema;
    /** Factory function to create monitor service instances */
    readonly serviceFactory: () => import("./types").IMonitorService;
⋮----
/** Unique identifier for the monitor type */
⋮----
/** Human-readable display name */
⋮----
/** Description of what this monitor checks */
⋮----
/** Version of the monitor implementation */
⋮----
/** Field definitions for dynamic form generation */
⋮----
/** Zod validation schema for this monitor type */
⋮----
/** Factory function to create monitor service instances */
⋮----
/** UI display configuration */
⋮----
/** Function to format detail display in history (e.g., "Port: 80", "Response Code: 200") */
⋮----
/** Function to format title suffix for history charts (e.g., " (https://example.com)") */
⋮----
/** Whether this monitor type supports response time analytics */
⋮----
/** Whether this monitor type supports advanced analytics */
⋮----
/** Help text for form fields */
⋮----
/** Display preferences */
⋮----
/** Detail label formatter for different contexts */
⋮----
/** Format for history detail column */
⋮----
/** Format for analytics display */
⋮----
// Shared validation schemas using Zod with enhanced validation
⋮----
// Use validator.js for robust URL validation
⋮----
// Use validator.js for robust host validation
⋮----
// Registry for monitor types
⋮----
/**
 * Register a new monitor type.
 *
 * @param config - Monitor type configuration
 */
export function registerMonitorType(config: BaseMonitorConfig): void
/**
 * Get all registered monitor types.
 *
 * @returns Array of registered monitor types
 */
export function getRegisteredMonitorTypes(): string[]
/**
 * Get all registered monitor types with their configurations.
 *
 * @returns Array of monitor type configurations
 */
export function getAllMonitorTypeConfigs(): BaseMonitorConfig[]
/**
 * Check if a monitor type is registered.
 *
 * @param type - Monitor type to check
 * @returns True if type is registered
 */
export function isValidMonitorType(type: string): boolean
/**
 * Get configuration for a monitor type.
 *
 * @param type - Monitor type
 * @returns Monitor configuration or undefined
 */
export function getMonitorTypeConfig(type: string): BaseMonitorConfig | undefined
/**
 * Get service factory for a monitor type.
 *
 * @param type - Monitor type
 * @returns Service factory function or undefined
 */
⋮----
/**
 * Validate monitor data using Zod schemas.
 *
 * @param type - Monitor type
 * @param data - Monitor data to validate
 * @returns Validation result
 */
⋮----
// Register existing monitor types with their field definitions and schemas
⋮----
// Initialize advanced validation rules for existing monitor types
⋮----
// URL validation will catch this
⋮----
// Check for common port/protocol combinations
⋮----
// Register validation rules with the advanced validation engine
⋮----
// Register example migrations for the migration system
⋮----
// Set current versions for existing monitor types
⋮----
// Enhanced validation function with improved error reporting
⋮----
// First, validate the monitor type
⋮----
// Validate using the advanced validation engine
⋮----
// Enhanced type guard for better runtime validation
⋮----
// Use enhanced type guard validation
⋮----
// Create monitor object with proper validation
⋮----
// Database migration helper - properly implemented with basic migration system
⋮----
// Validate the monitor type
⋮----
// Check if migration is needed
⋮----
// If no data provided, just return success for version bump
⋮----
// Use the migration orchestrator for data migration
⋮----
// Type guard for runtime validation
⋮----
// Generate union type from registered monitor types
⋮----
// Helper to get the current monitor types as a union
</file>

<file path="electron/services/monitoring/PortMonitor.ts">
/**
 * TCP/UDP port monitoring service for network connectivity health checks.
 *
 * @remarks
 * Provides comprehensive port monitoring capabilities for TCP and UDP endpoints
 * with configurable timeouts, retry logic, and intelligent connection handling.
 * Designed for reliable network connectivity verification across various protocols.
 *
 * Key features:
 * - **TCP/UDP Support**: Handles both TCP and UDP port connectivity checks
 * - **Configurable Timeouts**: Per-monitor timeout configuration support
 * - **Retry Logic**: Intelligent retry handling for transient network failures
 * - **Connection Pooling**: Efficient connection management for performance
 * - **Network Error Detection**: Distinguishes between different failure types
 * - **Performance Metrics**: Accurate connection time measurement
 *
 * @example
 * ```typescript
 * const portMonitor = new PortMonitor({ timeout: 5000 });
 * const result = await portMonitor.check({
 *   id: "mon_1",
 *   type: "port",
 *   host: "example.com",
 *   port: 443,
 *   status: "pending",
 *   // ... other monitor properties
 * });
 * console.log(`Status: ${result.status}, Response time: ${result.responseTime}ms`);
 * ```
 *
 * @packageDocumentation
 */
import { DEFAULT_REQUEST_TIMEOUT } from "../../constants";
import { Site } from "../../types";
import { IMonitorService, MonitorCheckResult, MonitorConfig } from "./types";
import { performPortCheckWithRetry } from "./utils/index";
/**
 * Service for performing port monitoring checks.
 *
 * @remarks
 * Implements the IMonitorService interface to provide TCP/UDP port connectivity
 * monitoring with advanced features for reliability and performance. Uses native
 * Node.js networking APIs with custom timeout and retry logic.
 *
 * The service automatically handles different types of network failures and
 * provides detailed error reporting for troubleshooting connectivity issues.
 */
export class PortMonitor implements IMonitorService {
⋮----
/**
     * Create a new PortMonitor instance.
     *
     * @param config - Configuration options for the monitor
     *
     * @remarks
     * Initializes the monitor with default timeout values and merges any
     * provided configuration options. Safe to instantiate multiple times
     * with different configurations for various monitoring needs.
     */
constructor(config: MonitorConfig =
⋮----
timeout: DEFAULT_REQUEST_TIMEOUT, // Use consistent default timeout
⋮----
/**
     * Get the monitor type this service handles.
     *
     * @returns The monitor type identifier
     *
     * @remarks
     * Returns the string identifier used to route monitoring requests
     * to this service implementation.
     */
public getType(): Site["monitors"][0]["type"]
/**
     * Perform a port connectivity check on the given monitor.
     *
     * @param monitor - Monitor configuration containing host and port details
     * @returns Promise resolving to check result with status and timing data
     *
     * @throws Error when monitor type is not "port"
     *
     * @remarks
     * Uses per-monitor retry attempts and timeout configuration for robust
     * connectivity checking. Validates monitor configuration before attempting
     * connection and provides detailed error information for failures.
     *
     * The check will use the monitor's configured timeout if available,
     * falling back to the service default. Response time includes the full
     * connection establishment time for accurate performance metrics.
     */
public async check(monitor: Site["monitors"][0]): Promise<MonitorCheckResult>
/**
     * Update the configuration for this monitor.
     *
     * @param config - Partial configuration to merge with existing settings
     *
     * @remarks
     * Updates the monitor's configuration by merging the provided partial
     * configuration with existing settings. This allows dynamic reconfiguration
     * of timeout values and other parameters without recreating the monitor instance.
     */
public updateConfig(config: Partial<MonitorConfig>): void
/**
     * Get the current configuration.
     *
     * @returns A copy of the current monitor configuration
     *
     * @remarks
     * Returns a defensive copy of the current configuration to prevent
     * external modification. This ensures configuration immutability
     * and prevents accidental state corruption.
     */
public getConfig(): MonitorConfig
</file>

<file path="electron/services/monitoring/types.ts">
/**
 * Type definitions for monitoring services and operations.
 *
 * @remarks
 * Defines interfaces and types used by monitor services to perform health checks
 * and manage monitoring configurations across different monitor types.
 *
 * @packageDocumentation
 */
import type { Site } from "../../types";
/**
 * Result of a monitor check operation.
 *
 * @remarks
 * Contains the outcome of a single health check attempt, including status,
 * performance metrics, and optional diagnostic information.
 *
 * @public
 */
export interface MonitorCheckResult {
    /**
     * Status outcome of the check.
     *
     * @remarks
     * - `"up"`: Monitor endpoint is healthy and responding normally
     * - `"down"`: Monitor endpoint is failing, unreachable, or returned an error
     */
    status: "up" | "down";
    /**
     * Response time in milliseconds.
     *
     * @remarks
     * For successful checks, this represents the actual response time.
     * For failed checks, this may represent timeout value or time until failure.
     */
    responseTime: number;
    /**
     * Optional human-readable details about the check result.
     *
     * @remarks
     * May include status codes, response headers, or other diagnostic information
     * useful for troubleshooting or display purposes.
     *
     * @remarks Examples: "HTTP 200 OK", "Connection timeout", "DNS resolution failed"
     */
    details?: string;
    /**
     * Optional error message if the check failed.
     *
     * @remarks
     * Provides technical error information for debugging failed checks.
     * Should not be displayed directly to end users.
     * Examples: "ECONNREFUSED", "Socket timeout", "Certificate expired"
     */
    error?: string;
}
⋮----
/**
     * Status outcome of the check.
     *
     * @remarks
     * - `"up"`: Monitor endpoint is healthy and responding normally
     * - `"down"`: Monitor endpoint is failing, unreachable, or returned an error
     */
⋮----
/**
     * Response time in milliseconds.
     *
     * @remarks
     * For successful checks, this represents the actual response time.
     * For failed checks, this may represent timeout value or time until failure.
     */
⋮----
/**
     * Optional human-readable details about the check result.
     *
     * @remarks
     * May include status codes, response headers, or other diagnostic information
     * useful for troubleshooting or display purposes.
     *
     * @remarks Examples: "HTTP 200 OK", "Connection timeout", "DNS resolution failed"
     */
⋮----
/**
     * Optional error message if the check failed.
     *
     * @remarks
     * Provides technical error information for debugging failed checks.
     * Should not be displayed directly to end users.
     * Examples: "ECONNREFUSED", "Socket timeout", "Certificate expired"
     */
⋮----
/**
 * Interface for monitor services that perform health checks.
 *
 * @remarks
 * All monitor implementations must implement this interface to provide
 * consistent behavior across different monitoring types (HTTP, port, etc.).
 *
 * @public
 */
export interface IMonitorService {
    /**
     * Perform a health check on a monitor.
     *
     * @param monitor - The monitor configuration to check
     * @returns Promise resolving to the check result
     *
     * @throws {@link Error} When monitor configuration is invalid or check fails catastrophically
     *
     * @remarks
     * Implementations should handle timeouts, retries, and error conditions gracefully.
     * Failed checks should return a result with `status: "down"` rather than throwing,
     * unless the monitor configuration itself is invalid.
     */
    check(monitor: Site["monitors"][0]): Promise<MonitorCheckResult>;
    /**
     * Get the type of monitor this service handles.
     *
     * @returns The monitor type this service is responsible for
     *
     * @remarks
     * Used by the monitor factory to route checks to the appropriate service.
     * Must match one of the values in the monitor's `type` field.
     */
    getType(): Site["monitors"][0]["type"];
    /**
     * Update the configuration for this monitor service.
     *
     * @param config - Partial configuration to update
     *
     * @remarks
     * Allows runtime configuration updates without recreating the service instance.
     * Only the provided configuration properties will be updated.
     */
    updateConfig(config: Partial<MonitorConfig>): void;
}
⋮----
/**
     * Perform a health check on a monitor.
     *
     * @param monitor - The monitor configuration to check
     * @returns Promise resolving to the check result
     *
     * @throws {@link Error} When monitor configuration is invalid or check fails catastrophically
     *
     * @remarks
     * Implementations should handle timeouts, retries, and error conditions gracefully.
     * Failed checks should return a result with `status: "down"` rather than throwing,
     * unless the monitor configuration itself is invalid.
     */
check(monitor: Site["monitors"][0]): Promise<MonitorCheckResult>;
/**
     * Get the type of monitor this service handles.
     *
     * @returns The monitor type this service is responsible for
     *
     * @remarks
     * Used by the monitor factory to route checks to the appropriate service.
     * Must match one of the values in the monitor's `type` field.
     */
getType(): Site["monitors"][0]["type"];
/**
     * Update the configuration for this monitor service.
     *
     * @param config - Partial configuration to update
     *
     * @remarks
     * Allows runtime configuration updates without recreating the service instance.
     * Only the provided configuration properties will be updated.
     */
updateConfig(config: Partial<MonitorConfig>): void;
⋮----
/**
 * Configuration for monitor check behavior.
 *
 * @remarks
 * Global configuration that applies to all monitors of a given type,
 * unless overridden by individual monitor settings.
 *
 * @public
 */
export interface MonitorConfig {
    /**
     * Request timeout in milliseconds.
     *
     * @defaultValue 10000 (10 seconds)
     *
     * @remarks
     * Maximum time to wait for a response before considering the check failed.
     * Individual monitors can override this with their own timeout settings.
     */
    timeout?: number;
    /**
     * User agent string for HTTP requests.
     *
     * @defaultValue "Uptime-Watcher/1.0"
     *
     * @remarks
     * Identifies the monitoring application in HTTP request headers.
     * Some servers may use this for logging or access control.
     */
    userAgent?: string;
}
⋮----
/**
     * Request timeout in milliseconds.
     *
     * @defaultValue 10000 (10 seconds)
     *
     * @remarks
     * Maximum time to wait for a response before considering the check failed.
     * Individual monitors can override this with their own timeout settings.
     */
⋮----
/**
     * User agent string for HTTP requests.
     *
     * @defaultValue "Uptime-Watcher/1.0"
     *
     * @remarks
     * Identifies the monitoring application in HTTP request headers.
     * Some servers may use this for logging or access control.
     */
</file>

<file path="electron/services/window/WindowService.ts">
/**
 * Window management service for Electron application windows.
 *
 * @remarks
 * Handles the creation, configuration, and lifecycle management of Electron
 * browser windows. Provides a centralized service for window operations
 * including content loading, event handling, and communication with renderers.
 *
 * Key responsibilities:
 * - Create and configure the main application window
 * - Load appropriate content based on environment (dev/prod)
 * - Handle window lifecycle events (ready-to-show, closed, etc.)
 * - Manage window state and provide access methods
 * - Facilitate communication between main and renderer processes
 *
 * The service automatically handles environment-specific loading:
 * - Development: Loads from Vite dev server with DevTools
 * - Production: Loads from built static files
 *
 * @example
 * ```typescript
 * const windowService = new WindowService();
 * const mainWindow = windowService.createMainWindow();
 *
 * // Send data to renderer
 * windowService.sendToRenderer('status-update', { status: 'up' });
 *
 * // Check if window exists
 * if (windowService.hasMainWindow()) {
 *   // Window operations...
 * }
 * ```
 *
 * @packageDocumentation
 */
import { BrowserWindow } from "electron";
// eslint-disable-next-line unicorn/import-style -- Need namespace import for path operations
⋮----
import { isDev } from "../../electronUtils";
import { logger } from "../../utils/index";
/**
 * Service responsible for window management and lifecycle.
 *
 * @remarks
 * Provides centralized management of Electron browser windows with proper
 * security configuration, content loading, and event handling. Ensures
 * windows are created with appropriate security settings including context
 * isolation and disabled node integration.
 */
export class WindowService {
⋮----
/** Reference to the main application window (null if not created) */
⋮----
/**
     * Create and configure the main application window.
     *
     * @returns The created BrowserWindow instance
     *
     * @remarks
     * Creates a new main window with secure defaults including:
     * - Context isolation enabled for security
     * - Node integration disabled in renderer
     * - Preload script for safe IPC communication
     * - Appropriate minimum and default dimensions
     * - Environment-specific content loading
     *
     * The window is initially hidden and will be shown when ready-to-show
     * event is fired to prevent visual flash.
     */
public createMainWindow(): BrowserWindow
⋮----
show: false, // Hidden initially to prevent flash
⋮----
contextIsolation: true, // Security: isolate context
nodeIntegration: false, // Security: disable node in renderer
preload: path.join(__dirname, "preload.js"), // Safe IPC bridge
⋮----
/**
     * Load the appropriate content based on the current environment.
     *
     * @remarks
     * Handles environment-specific content loading:
     * - Development: Loads from Vite dev server (localhost:5173) with DevTools
     * - Production: Loads from built static files in the app bundle
     *
     * Includes error handling for cases where the dev server might not be running.
     */
private loadContent(): void
/**
     * Setup window event handlers.
     */
private setupWindowEvents(): void
/**
     * Get the main window instance.
     */
public getMainWindow(): BrowserWindow | null
/**
     * Check if the main window exists and is not destroyed.
     */
public hasMainWindow(): boolean
/**
     * Send a message to the main window's renderer process.
     */
public sendToRenderer(channel: string, data?: unknown): void
/**
     * Close the main window.
     */
public closeMainWindow(): void
/**
     * Get all browser windows.
     */
public getAllWindows(): BrowserWindow[]
</file>

<file path="electron/utils/database/serviceFactory.ts">
/**
 * Factory functions to create services with proper dependency injection.
 */
import { UptimeEvents, TypedEventBus } from "../../events";
import {
    SiteRepository,
    MonitorRepository,
    HistoryRepository,
    SettingsRepository,
    DatabaseService,
} from "../../services/index";
import { monitorLogger } from "../../utils/index";
import { DataBackupService, DataBackupOrchestrator } from "./DataBackupService";
import { DataImportExportService, DataImportExportOrchestrator } from "./DataImportExportService";
import { SiteCache } from "./interfaces";
import { SiteRepositoryService, SiteLoadingOrchestrator } from "./SiteRepositoryService";
import { SiteWriterService, SiteWritingOrchestrator } from "./SiteWriterService";
/**
 * Adapter for the logger to implement Logger interface.
 */
class LoggerAdapter {
⋮----
constructor(logger: typeof monitorLogger)
debug(message: string, ...args: unknown[]): void
error(message: string, error?: unknown, ...args: unknown[]): void
info(message: string, ...args: unknown[]): void
warn(message: string, ...args: unknown[]): void
⋮----
/**
 * Factory function to create a properly configured SiteRepositoryService.
 *
 * @param eventEmitter - Event bus for emitting database events
 * @returns Configured SiteRepositoryService instance
 */
export function createSiteRepositoryService(eventEmitter: TypedEventBus<UptimeEvents>): SiteRepositoryService
/**
 * Factory function to create a properly configured SiteWriterService.
 *
 * @returns Configured SiteWriterService instance
 */
export function createSiteWriterService(): SiteWriterService
/**
 * Factory function to create a properly configured SiteLoadingOrchestrator.
 *
 * @param eventEmitter - Event bus for emitting database events
 * @returns Configured SiteLoadingOrchestrator instance
 */
export function createSiteLoadingOrchestrator(eventEmitter: TypedEventBus<UptimeEvents>): SiteLoadingOrchestrator
/**
 * Factory function to create a properly configured SiteWritingOrchestrator.
 *
 * @returns Configured SiteWritingOrchestrator instance
 */
export function createSiteWritingOrchestrator(): SiteWritingOrchestrator
/**
 * Factory function to create a site cache.
 *
 * @returns New SiteCache instance
 */
export function createSiteCache(): SiteCache
/**
 * Factory function to create a properly configured DataImportExportService.
 *
 * @param eventEmitter - Event bus for emitting import/export events
 * @returns Configured DataImportExportService instance
 */
export function createDataImportExportService(eventEmitter: TypedEventBus<UptimeEvents>): DataImportExportService
/**
 * Factory function to create a properly configured DataBackupService.
 */
export function createDataBackupService(eventEmitter: TypedEventBus<UptimeEvents>): DataBackupService
/**
 * Factory function to create a properly configured DataImportExportOrchestrator.
 */
export function createDataImportExportOrchestrator(
    eventEmitter: TypedEventBus<UptimeEvents>
): DataImportExportOrchestrator
/**
 * Factory function to create a properly configured DataBackupOrchestrator.
 */
export function createDataBackupOrchestrator(eventEmitter: TypedEventBus<UptimeEvents>): DataBackupOrchestrator
</file>

<file path="electron/utils/database/StateSyncService.ts">
/**
 * Centralized state synchronization service to unify multiple state sources.
 *
 * @remarks
 * This service resolves the issue of having three different state sources:
 * 1. Database (persistent storage)
 * 2. Cache (manager layer)
 * 3. Frontend store (UI state)
 *
 * It provides a single source of truth with automatic synchronization
 * and cache invalidation across all layers.
 */
import { UptimeEvents, TypedEventBus } from "../../events";
import { SiteRepository } from "../../services/index";
import { Site } from "../../types";
import { SiteCacheInterface } from "./interfaces";
import { logger } from "../logger";
/**
 * Configuration for state synchronization service.
 *
 * @public
 */
export interface StateSyncConfig {
    /** Site repository for database access */
    siteRepository: SiteRepository;
    /** Site cache for memory access */
    siteCache: SiteCacheInterface;
    /** Event emitter for state change notifications */
    eventEmitter: TypedEventBus<UptimeEvents>;
    /** Frontend store synchronization callback */
    frontendSync?: (sites: Site[]) => void;
    /** Enable debug logging for sync operations */
    enableDebugLogging?: boolean;
}
⋮----
/** Site repository for database access */
⋮----
/** Site cache for memory access */
⋮----
/** Event emitter for state change notifications */
⋮----
/** Frontend store synchronization callback */
⋮----
/** Enable debug logging for sync operations */
⋮----
/**
 * State synchronization strategies.
 *
 * @public
 */
export type SyncStrategy =
    | "database-first" // Database is source of truth
    | "cache-first" // Cache is source of truth (with database fallback)
    | "hybrid"; // Intelligent selection based on data freshness
⋮----
| "database-first" // Database is source of truth
| "cache-first" // Cache is source of truth (with database fallback)
| "hybrid"; // Intelligent selection based on data freshness
/**
 * Centralized state synchronization service.
 *
 * @remarks
 * Provides unified access to site data across all application layers
 * with automatic synchronization and cache invalidation.
 */
export class StateSyncService {
⋮----
/**
     * Create a new state synchronization service.
     *
     * @param config - Configuration for state synchronization
     * @param strategy - Synchronization strategy to use
     */
constructor(config: StateSyncConfig, strategy: SyncStrategy = "hybrid")
/**
     * Get all sites using the configured synchronization strategy.
     *
     * @returns Promise resolving to array of all sites
     */
public async getSites(): Promise<Site[]>
/**
     * Get a single site by identifier.
     *
     * @param identifier - Site identifier
     * @returns Promise resolving to site or undefined
     */
public async getSite(identifier: string): Promise<Site | undefined>
⋮----
// Try cache first for single-site access
⋮----
// Fallback to database
⋮----
// Note: This would need to be expanded to load full Site object with monitors
⋮----
/**
     * Update a site across all state sources.
     *
     * @param site - Site to update
     */
public async updateSite(site: Site): Promise<void>
⋮----
// Update database first (source of truth)
⋮----
// Update cache
⋮----
// Notify frontend
⋮----
// Emit state change event
⋮----
/**
     * Delete a site from all state sources.
     *
     * @param identifier - Site identifier to delete
     */
public async deleteSite(identifier: string): Promise<boolean>
⋮----
// Delete from database first
⋮----
// Remove from cache
⋮----
// Notify frontend
⋮----
// Emit state change event
⋮----
/**
     * Force synchronization from database to all other state sources.
     */
public async forceSyncFromDatabase(): Promise<void>
⋮----
// Load all sites from database
⋮----
// Update cache
⋮----
// Notify frontend
⋮----
// Emit synchronization complete event
⋮----
/**
     * Check if state is synchronized (no pending changes).
     */
public isSynchronized(): boolean
/**
     * Get database sites (always from database).
     */
private async getDatabaseSites(): Promise<Site[]>
⋮----
// Note: This simplified version returns partial sites
// In a full implementation, this would load complete Site objects with monitors
⋮----
// For now, return empty array of full sites
// This would need to be implemented to construct full Site objects
⋮----
/**
     * Get cache-first sites (cache with database fallback).
     */
private async getCacheFirstSites(): Promise<Site[]>
⋮----
// Cache empty, fallback to database
⋮----
/**
     * Get hybrid sites (intelligent strategy selection).
     */
private async getHybridSites(): Promise<Site[]>
⋮----
const SYNC_THRESHOLD_MS = 30_000; // 30 seconds
// Use cache if it has data and sync is recent
⋮----
// Otherwise sync from database
⋮----
/**
     * Setup cache invalidation event handling.
     */
private setupCacheInvalidationHandling(): void
⋮----
// Check if cache supports invalidation callbacks
⋮----
// Type assertion since we've verified the method exists
⋮----
// Notify frontend of cache changes
</file>

<file path="electron/utils/index.ts">
/**
 * Electron utilities barrel export.
 * Provides centralized access to all electron utility functions and services.
 */
// Database utilities
⋮----
// Monitoring utilities
⋮----
// Standalone utilities
</file>

<file path="src/components/AddSiteForm/index.ts">
/**
 * AddSiteForm module barrel export.
 * Provides centralized access to all AddSiteForm components and utilities.
 */
// Main component
⋮----
// Form field components
⋮----
// Form handling utilities
⋮----
// Custom hook
</file>

<file path="src/components/dynamic-monitor-ui.tsx">
/**
 * React components for dynamic monitor UI behavior.
 * These components handle async loading of monitor configurations and provide
 * consistent UI behavior across different monitor types.
 */
import React, { useEffect, useState } from "react";
import type { MonitorType } from "../types";
import { formatMonitorDetail } from "../utils/dynamicMonitorUi";
/**
 * Component that dynamically formats monitor detail labels.
 * Handles async loading of monitor configuration.
 */
interface DetailLabelProps {
    readonly monitorType: MonitorType;
    readonly details: string;
    readonly fallback?: string;
}
export function DetailLabel(
/**
 * Component that conditionally renders based on response time support.
 */
interface ConditionalResponseTimeProps {
    readonly monitorType: MonitorType;
    readonly children: React.ReactNode;
    readonly fallback?: React.ReactNode;
}
export function ConditionalResponseTime(
⋮----
const checkSupport = async () =>
⋮----
/**
 * Component that conditionally renders based on advanced analytics support.
 */
interface ConditionalAdvancedAnalyticsProps {
    readonly monitorType: MonitorType;
    readonly children: React.ReactNode;
    readonly fallback?: React.ReactNode;
}
export function ConditionalAdvancedAnalytics(
/**
 * Component that conditionally renders based on multiple monitor types support.
 */
interface ConditionalMultipleTypesProps {
    readonly monitorTypes: MonitorType[];
    readonly feature: "responseTime" | "advancedAnalytics";
    readonly children: React.ReactNode;
    readonly fallback?: React.ReactNode;
}
export function ConditionalMultipleTypes(
/**
 * Hook for dynamic help text loading.
 */
export function useDynamicHelpText(monitorType: MonitorType)
⋮----
const loadHelpTexts = async () =>
</file>

<file path="src/components/SiteDetails/SiteDetailsHeader.tsx">
/**
 * Site details header component
 *
 * Displays the site title, URL, status indicator, and screenshot thumbnail
 * in a visually appealing header with gradient background and accent styling.
 */
import { MdExpandLess, MdExpandMore } from "react-icons/md";
import { useThemeStyles } from "../../hooks";
import { logger } from "../../services";
import { ThemedText, StatusIndicator, ThemedBox, ThemedBadge } from "../../theme";
import { Site, Monitor } from "../../types";
import { ScreenshotThumbnail } from "./ScreenshotThumbnail";
/**
 * Type guard to check if the window.electronAPI has openExternal method
 * @param api - The API object to check
 * @returns True if the API has openExternal method
 */
function hasOpenExternal(api: unknown): api is
/** Props for the SiteDetailsHeader component */
interface SiteDetailsHeaderProperties {
    /** The site object to display information for */
    readonly site: Site;
    /** The currently selected monitor for the site */
    readonly selectedMonitor?: Monitor;
    /** Whether the header is collapsed */
    readonly isCollapsed?: boolean;
    /** Callback to toggle the header collapse state */
    readonly onToggleCollapse?: () => void;
}
⋮----
/** The site object to display information for */
⋮----
/** The currently selected monitor for the site */
⋮----
/** Whether the header is collapsed */
⋮----
/** Callback to toggle the header collapse state */
⋮----
/**
 * Header component for site details view.
 *
 * Displays site name, URL (for HTTP monitors), status indicator with loading spinner,
 * and a screenshot thumbnail. Handles external URL opening with proper fallbacks.
 *
 * @param props - Component props
 * @returns JSX element containing the site details header
 */
⋮----
// Use theme-aware styles
⋮----
{/* Left accent bar */}
⋮----
{/* Left side: Screenshot, Status, and Site Info */}
⋮----
{/* Website Screenshot Thumbnail - Only show URL for HTTP monitors */}
⋮----
{/* Show clickable URL for HTTP monitors that have a URL */}
⋮----
{/* Display appropriate connection info based on monitor type */}
</file>

<file path="src/components/SiteDetails/tabs/AnalyticsTab.tsx">
/**
 * Analytics tab component providing comprehensive monitoring statistics and visualizations.
 * Displays advanced metrics, charts, and performance analysis for site monitoring.
 */
import { Line, Bar, Doughnut } from "react-chartjs-2";
import { FiActivity, FiTrendingUp, FiBarChart2 } from "react-icons/fi";
import { MdAnalytics, MdTrendingUp, MdSpeed, MdPieChart } from "react-icons/md";
import { ConditionalResponseTime } from "../../dynamic-monitor-ui";
import { DowntimePeriod } from "../../../hooks/site/useSiteAnalytics";
import { logger } from "../../../services";
import {
    ThemedText,
    ThemedButton,
    ThemedCard,
    ThemedBadge,
    ThemedProgress,
    useTheme,
    useAvailabilityColors,
} from "../../../theme";
import { MonitorType } from "../../../types";
/**
 * Props for the AnalyticsTab component.
 * Contains comprehensive metrics, chart data, and formatting functions.
 */
interface AnalyticsTabProperties {
    /** Average response time across all checks */
    readonly avgResponseTime: number;
    /** Chart.js data configuration for bar chart */
    readonly barChartData: Record<string, unknown>;
    /** Chart.js options configuration for bar chart */
    readonly barChartOptions: Record<string, unknown>;
    /** Chart.js options configuration for doughnut chart */
    readonly doughnutOptions: Record<string, unknown>;
    /** Number of failed checks */
    readonly downCount: number;
    /** Array of downtime periods with durations */
    readonly downtimePeriods: DowntimePeriod[];
    /** Function to format duration values */
    readonly formatDuration: (ms: number) => string;
    /** Function to format response time values */
    readonly formatResponseTime: (time: number) => string;
    /** Function to get description based on availability percentage */
    readonly getAvailabilityDescription: (percentage: number) => string;
    /** Chart.js data configuration for line chart */
    readonly lineChartData: Record<string, unknown>;
    /** Chart.js options configuration for line chart */
    readonly lineChartOptions: Record<string, unknown>;
    /** Type of monitor being analyzed */
    readonly monitorType: MonitorType;
    /** Mean time to recovery in milliseconds */
    readonly mttr: number;
    /** 50th percentile response time */
    readonly p50: number;
    /** 95th percentile response time */
    readonly p95: number;
    /** 99th percentile response time */
    readonly p99: number;
    /** Function to toggle advanced metrics visibility */
    readonly setShowAdvancedMetrics: (show: boolean) => void;
    /** Function to set the chart time range */
    readonly setSiteDetailsChartTimeRange: (range: "1h" | "24h" | "7d" | "30d") => void;
    /** Whether advanced metrics are currently shown */
    readonly showAdvancedMetrics: boolean;
    /** Current chart time range selection */
    readonly siteDetailsChartTimeRange: "1h" | "24h" | "7d" | "30d";
    /** Total number of checks performed */
    readonly totalChecks: number;
    /** Total downtime in milliseconds */
    readonly totalDowntime: number;
    /** Number of successful checks */
    readonly upCount: number;
    /** Uptime percentage as string */
    readonly uptime: string;
    /** Chart.js data configuration for uptime chart */
    readonly uptimeChartData: Record<string, unknown>;
}
⋮----
/** Average response time across all checks */
⋮----
/** Chart.js data configuration for bar chart */
⋮----
/** Chart.js options configuration for bar chart */
⋮----
/** Chart.js options configuration for doughnut chart */
⋮----
/** Number of failed checks */
⋮----
/** Array of downtime periods with durations */
⋮----
/** Function to format duration values */
⋮----
/** Function to format response time values */
⋮----
/** Function to get description based on availability percentage */
⋮----
/** Chart.js data configuration for line chart */
⋮----
/** Chart.js options configuration for line chart */
⋮----
/** Type of monitor being analyzed */
⋮----
/** Mean time to recovery in milliseconds */
⋮----
/** 50th percentile response time */
⋮----
/** 95th percentile response time */
⋮----
/** 99th percentile response time */
⋮----
/** Function to toggle advanced metrics visibility */
⋮----
/** Function to set the chart time range */
⋮----
/** Whether advanced metrics are currently shown */
⋮----
/** Current chart time range selection */
⋮----
/** Total number of checks performed */
⋮----
/** Total downtime in milliseconds */
⋮----
/** Number of successful checks */
⋮----
/** Uptime percentage as string */
⋮----
/** Chart.js data configuration for uptime chart */
⋮----
/**
 * Analytics tab component displaying comprehensive monitoring analytics and visualizations.
 *
 * Features:
 * - Multiple chart types (line, bar, doughnut) for different metrics
 * - Key performance indicators (uptime, response time, availability)
 * - Advanced metrics (percentiles, MTTR, downtime analysis)
 * - Interactive charts with time range filtering
 * - Downtime period analysis
 * - Export capabilities for chart data
 *
 * @param props - Component props containing metrics and chart configurations
 * @returns JSX element displaying analytics interface
 */
⋮----
// Function to get response time color based on performance
const getResponseTimeColor = (responseTime: number): string =>
⋮----
} // Green for excellent (≤100ms)
⋮----
} // Yellow for good (≤500ms)
return currentTheme.colors.error; // Red for poor (>500ms)
⋮----
// Icon colors configuration
const getIconColors = () =>
⋮----
{/* Time Range Selector */}
⋮----
setSiteDetailsChartTimeRange(range);
⋮----
{/* Key Metrics Grid */}
⋮----

⋮----
{/* Average Response Time Card - Available for all current monitor types */}
⋮----
icon=
⋮----
{/* Response Time Percentiles */}
⋮----
{/* Charts Grid */}
⋮----
{/* Response Time Chart */}
⋮----
{/* Uptime Doughnut Chart */}
⋮----
{/* Status Distribution Bar Chart */}
</file>

<file path="src/components/SiteDetails/tabs/OverviewTab.tsx">
/**
 * Overview tab component for site details page.
 * Displays key metrics, statistics, and actions for a monitored site.
 */
import { FaListOl } from "react-icons/fa";
import { FiTrash2 } from "react-icons/fi";
import { MdAccessTime, MdBolt, MdSpeed, MdOutlineFactCheck } from "react-icons/md";
import { CHECK_INTERVALS, TIMEOUT_CONSTRAINTS } from "../../../constants";
import { logger } from "../../../services";
import {
    ThemedText,
    ThemedButton,
    StatusIndicator,
    ThemedCard,
    ThemedBadge,
    ThemedProgress,
    ThemedSelect,
    ThemedInput,
    useTheme,
    useAvailabilityColors,
} from "../../../theme";
import { Monitor } from "../../../types";
import { getIntervalLabel } from "../../../utils";
/**
 * Get response time text color for styling
 */
function getResponseTimeTextColor(responseTime: number): string
/**
 * Props for the OverviewTab component.
 */
interface OverviewTabProperties {
    /** Average response time across all checks */
    readonly avgResponseTime: number;
    /** Fastest recorded response time */
    readonly fastestResponse: number;
    /** Function to format response time for display */
    readonly formatResponseTime: (time: number) => string;
    /** Handler for monitor check interval changes */
    readonly handleIntervalChange: (e: React.ChangeEvent<HTMLSelectElement>) => void;
    /** Handler for removing the monitor */
    readonly handleRemoveMonitor: () => Promise<void>;
    /** Handler for saving interval changes */
    readonly handleSaveInterval: () => Promise<void>;
    /** Handler for saving timeout changes */
    readonly handleSaveTimeout: () => Promise<void>;
    /** Handler for monitor timeout changes */
    readonly handleTimeoutChange: (e: React.ChangeEvent<HTMLInputElement>) => void;
    /** Whether the check interval has been changed */
    readonly intervalChanged: boolean;
    /** Whether any async operation is in progress */
    readonly isLoading: boolean;
    /** Local state value for check interval */
    readonly localCheckInterval: number;
    /** Local state value for timeout */
    readonly localTimeout: number;
    /** Handler for immediate check trigger */
    readonly onCheckNow: () => void;
    /** Currently selected monitor */
    readonly selectedMonitor: Monitor;
    /** Slowest recorded response time */
    readonly slowestResponse: number;
    /** Whether the timeout has been changed */
    readonly timeoutChanged: boolean;
    /** Total number of checks performed */
    readonly totalChecks: number;
    /** Uptime percentage as a string */
    readonly uptime: string;
}
⋮----
/** Average response time across all checks */
⋮----
/** Fastest recorded response time */
⋮----
/** Function to format response time for display */
⋮----
/** Handler for monitor check interval changes */
⋮----
/** Handler for removing the monitor */
⋮----
/** Handler for saving interval changes */
⋮----
/** Handler for saving timeout changes */
⋮----
/** Handler for monitor timeout changes */
⋮----
/** Whether the check interval has been changed */
⋮----
/** Whether any async operation is in progress */
⋮----
/** Local state value for check interval */
⋮----
/** Local state value for timeout */
⋮----
/** Handler for immediate check trigger */
⋮----
/** Currently selected monitor */
⋮----
/** Slowest recorded response time */
⋮----
/** Whether the timeout has been changed */
⋮----
/** Total number of checks performed */
⋮----
/** Uptime percentage as a string */
⋮----
/**
 * Overview tab component displaying site monitoring statistics and metrics.
 *
 * Features:
 * - Uptime percentage with visual progress indicator
 * - Response time statistics (average, fastest, slowest)
 * - Total checks counter
 * - Monitor status indicator
 * - Site removal action
 *
 * @param props - Component props containing metrics and handlers
 * @returns JSX element displaying overview information
 */
⋮----
// Map availability variant to progress/badge variant
const mapAvailabilityToBadgeVariant = (availability: number): "success" | "warning" | "error" =>
⋮----
// Icon colors configuration
const getIconColors = () =>
/**
     * Get response time color based on value
     */
const getResponseTimeColor = (responseTime: number): string =>
⋮----
{/* Key Metrics Grid */}
⋮----
{/* Performance Metrics */}
⋮----

⋮----
{/* Quick Actions */}
⋮----
{/* Interval Control */}
⋮----
{/* Timeout Control */}
⋮----
{/* Check Now Button */}
⋮----
{/* Remove Monitor Button */}
</file>

<file path="src/components/SiteDetails/tabs/SettingsTab.tsx">
/* eslint-disable @typescript-eslint/no-unnecessary-condition -- will be adding multiple monitor types soon */
/**
 * Settings tab component for configuring site monitoring parameters.
 * Provides interface for modifying site settings, intervals, and performing site management actions.
 */
import React, { useEffect, useState } from "react";
import { FiTrash2, FiSave } from "react-icons/fi";
import { MdSettings, MdTimer, MdInfoOutline, MdDangerous } from "react-icons/md";
import { CHECK_INTERVALS, RETRY_CONSTRAINTS, TIMEOUT_CONSTRAINTS } from "../../../constants";
import { logger } from "../../../services";
import { ThemedText, ThemedButton, ThemedCard, ThemedBadge, ThemedInput, ThemedSelect, useTheme } from "../../../theme";
import { Site, Monitor } from "../../../types";
import { calculateMaxDuration, getIntervalLabel } from "../../../utils";
import { getMonitorTypeConfig } from "../../../utils/monitorTypeHelper";
/**
 * Helper function to format retry attempts text.
 * @param attempts - Number of retry attempts
 * @returns Formatted retry attempts description
 */
function formatRetryAttemptsText(attempts: number): string
/**
 * Component that displays the identifier label for a monitor type.
 */
function IdentifierLabel(
⋮----
const loadLabel = async () =>
⋮----
/**
 * Generate a display label for the identifier field based on monitor type.
 */
async function getIdentifierLabel(selectedMonitor: Monitor): Promise<string>
⋮----
// Generate label based on primary field(s)
⋮----
// Fallback to first field
⋮----
// Fallback to hardcoded labels
⋮----
/**
 * Generate a display identifier based on the monitor type.
 * Uses the monitor registry to format the display value appropriately.
 */
function getDisplayIdentifier(currentSite: Site, selectedMonitor: Monitor): string
⋮----
// Try to get the primary value for display
⋮----
// Fallback to site identifier
⋮----
/**
 * Props for the SettingsTab component.
 */
interface SettingsTabProperties {
    /** Current site being configured */
    readonly currentSite: Site;
    /** Handler for monitor check interval changes */
    readonly handleIntervalChange: (e: React.ChangeEvent<HTMLSelectElement>) => void;
    /** Handler for removing/deleting the site */
    readonly handleRemoveSite: () => Promise<void>;
    /** Handler for saving interval changes */
    readonly handleSaveInterval: () => void;
    /** Handler for saving site name changes */
    readonly handleSaveName: () => Promise<void>;
    /** Handler for saving retry attempts changes */
    readonly handleSaveRetryAttempts: () => Promise<void>;
    /** Handler for saving timeout changes */
    readonly handleSaveTimeout: () => Promise<void>;
    /** Handler for monitor retry attempts changes */
    readonly handleRetryAttemptsChange: (e: React.ChangeEvent<HTMLInputElement>) => void;
    /** Handler for monitor timeout changes */
    readonly handleTimeoutChange: (e: React.ChangeEvent<HTMLInputElement>) => void;
    /** Whether there are unsaved changes pending */
    readonly hasUnsavedChanges: boolean;
    /** Whether the check interval has been modified */
    readonly intervalChanged: boolean;
    /** Whether any async operation is in progress */
    readonly isLoading: boolean;
    /** Local state value for check interval */
    readonly localCheckInterval: number;
    /** Local state value for site name */
    readonly localName: string;
    /** Local state value for retry attempts */
    readonly localRetryAttempts: number;
    /** Local state value for timeout in seconds (converted to ms when saving) */
    readonly localTimeout: number;
    /** Currently selected monitor being configured */
    readonly selectedMonitor: Monitor;
    /** Function to update local site name state */
    readonly setLocalName: (name: string) => void;
    /** Whether the retry attempts have been changed */
    readonly retryAttemptsChanged: boolean;
    /** Whether the timeout has been changed */
    readonly timeoutChanged: boolean;
}
⋮----
/** Current site being configured */
⋮----
/** Handler for monitor check interval changes */
⋮----
/** Handler for removing/deleting the site */
⋮----
/** Handler for saving interval changes */
⋮----
/** Handler for saving site name changes */
⋮----
/** Handler for saving retry attempts changes */
⋮----
/** Handler for saving timeout changes */
⋮----
/** Handler for monitor retry attempts changes */
⋮----
/** Handler for monitor timeout changes */
⋮----
/** Whether there are unsaved changes pending */
⋮----
/** Whether the check interval has been modified */
⋮----
/** Whether any async operation is in progress */
⋮----
/** Local state value for check interval */
⋮----
/** Local state value for site name */
⋮----
/** Local state value for retry attempts */
⋮----
/** Local state value for timeout in seconds (converted to ms when saving) */
⋮----
/** Currently selected monitor being configured */
⋮----
/** Function to update local site name state */
⋮----
/** Whether the retry attempts have been changed */
⋮----
/** Whether the timeout has been changed */
⋮----
/**
 * Settings tab component providing site configuration interface.
 *
 * Features:
 * - Site name editing with validation
 * - Monitor check interval configuration
 * - Monitor status and information display
 * - Site removal with confirmation
 * - Unsaved changes tracking and warnings
 * - Real-time settings validation
 *
 * @param props - Component props containing site data and handlers
 * @returns JSX element displaying settings interface
 */
⋮----
// Icon colors configuration
const getIconColors = () => (
⋮----
const loggedHandleSaveName = async () =>
const loggedHandleSaveInterval = () =>
const loggedHandleRemoveSite = async () =>
const loggedHandleSaveTimeout = async () =>
const loggedHandleSaveRetryAttempts = async () =>
⋮----
{/* Site Configuration */}
⋮----
{/* Site Name */}
⋮----
onChange=
⋮----
{/* Site Identifier */}
⋮----
{/* Monitoring Configuration */}
⋮----
{/* Check Interval */}
⋮----
{/* Timeout Configuration */}
⋮----
{/* Retry Attempts Configuration */}
⋮----

⋮----
{/* Total monitoring time indicator */}
⋮----
{/* Site Information */}
⋮----
{/* Danger Zone */}
</file>

<file path="src/components/SiteDetails/tabs/SiteOverviewTab.tsx">
/**
 * Site Overview tab component for displaying comprehensive site information.
 * Provides an overview of the entire site including all monitors, general statistics,
 * and site-level actions.
 */
import { FiSettings } from "react-icons/fi";
import { MdDomain, MdMonitorHeart, MdSpeed, MdOutlineFactCheck } from "react-icons/md";
import {
    ThemedText,
    ThemedButton,
    ThemedBadge,
    ThemedCard,
    StatusIndicator,
    ThemedProgress,
    useTheme,
    useAvailabilityColors,
} from "../../../theme";
import { Site, Monitor } from "../../../types";
import { getSiteDisplayStatus, formatResponseTime, formatDuration } from "../../../utils";
/**
 * Get status text for monitor
 */
function getMonitorStatusText(monitor: Monitor): string
/**
 * Get monitor badge variant
 */
function getMonitorBadgeVariant(monitor: Monitor): "success" | "warning" | "error"
/**
 * Get response time text color for styling
 */
function getResponseTimeTextColor(responseTime: number): string
/**
 * Props for the SiteOverviewTab component
 */
interface SiteOverviewTabProperties {
    /** The site object to display overview for */
    readonly site: Site;
    /** Average response time across all monitors */
    readonly avgResponseTime: number;
    /** Handler for removing the site */
    readonly handleRemoveSite: () => Promise<void>;
    /** Handler for starting site-level monitoring */
    readonly handleStartSiteMonitoring: () => Promise<void>;
    /** Handler for stopping site-level monitoring */
    readonly handleStopSiteMonitoring: () => Promise<void>;
    /** Whether any async operation is in progress */
    readonly isLoading: boolean;
    /** Total number of checks across all monitors */
    readonly totalChecks: number;
    /** Total uptime percentage across all monitors */
    readonly uptime: number;
}
⋮----
/** The site object to display overview for */
⋮----
/** Average response time across all monitors */
⋮----
/** Handler for removing the site */
⋮----
/** Handler for starting site-level monitoring */
⋮----
/** Handler for stopping site-level monitoring */
⋮----
/** Whether any async operation is in progress */
⋮----
/** Total number of checks across all monitors */
⋮----
/** Total uptime percentage across all monitors */
⋮----
/**
 * Site Overview tab component that displays comprehensive site information.
 *
 * Features:
 * - Site metadata (name, creation date, identifier)
 * - Monitor summary with individual statuses
 * - Aggregate statistics across all monitors
 * - Site-level monitoring controls
 * - Quick actions for site management
 *
 * @param props - Component props
 * @returns JSX element containing the site overview
 */
⋮----
// Calculate site-level statistics
⋮----
/**
     * Get status variant for theming based on uptime percentage
     */
const getUptimeVariant = (percentage: number): "success" | "warning" | "error" =>
// Icon colors configuration
const getIconColors = () =>
⋮----
// Use getColor to safely access theme colors with proper validation
⋮----
/**
     * Get response time color based on value
     */
const getResponseTimeColor = (responseTime: number): string =>
⋮----
{/* Site Overview Metrics */}
⋮----
<ThemedText size="xl" weight="bold" className=
⋮----
{/* Site Information */}
⋮----
{/* Monitor Details */}
⋮----
<ThemedBadge variant=

⋮----
{/* Site Actions */}
</file>

<file path="src/hooks/site/useSiteActions.ts">
import { useCallback } from "react";
import { logger } from "../../services";
import { useSitesStore, useUIStore } from "../../stores";
import { Monitor, Site } from "../../types";
interface SiteActionsResult {
    // Action handlers
    handleStartMonitoring: () => void;
    handleStopMonitoring: () => void;
    handleCheckNow: () => void;
    handleCardClick: () => void;
}
⋮----
// Action handlers
⋮----
/**
 * Hook to handle site-related actions like checking status and monitoring
 * Integrated with logger and state management for proper tracking
 *
 * @param site - The site object to act upon
 * @param monitor - The specific monitor to use for actions
 * @returns Object containing action handler functions
 */
export function useSiteActions(site: Site, monitor: Monitor | undefined): SiteActionsResult
⋮----
// Start monitoring the site with proper logging
⋮----
// Stop monitoring the site with proper logging
⋮----
// Perform an immediate status check with enhanced logging
⋮----
// Handle async operation with proper error handling
⋮----
// Don't re-throw here since this is a fire-and-forget operation
⋮----
// Handle clicking on the site card to show details with navigation logging
</file>

<file path="src/hooks/useSelectedSite.ts">
/**
 * Custom hook for managing selected site state across store boundaries.
 *
 * @remarks
 * Provides a clean interface for accessing the currently selected site by
 * coordinating between the UI store (which tracks selection) and the sites
 * store (which contains site data). This hook properly handles cross-store
 * dependencies without creating tight coupling between stores.
 *
 * The hook automatically updates when either the selected site ID changes
 * or when the sites data is updated, ensuring consistent state.
 *
 * @returns The currently selected site object, or undefined if no site is selected
 *
 * @example
 * ```typescript
 * function SiteDetailsComponent() {
 *   const selectedSite = useSelectedSite();
 *
 *   if (!selectedSite) {
 *     return <div>No site selected</div>;
 *   }
 *
 *   return <div>Site: {selectedSite.name}</div>;
 * }
 * ```
 *
 * @public
 */
import { useMemo } from "react";
import type { Site } from "../types";
import { useSitesStore, useUIStore } from "../stores";
/**
 * Hook to get the currently selected site from coordinated store data.
 *
 * @returns The selected site object or undefined if no selection exists
 *
 * @remarks
 * This hook efficiently combines data from the UI store (selection state) and
 * sites store (site data) using useMemo to prevent unnecessary recalculations.
 * The memoization ensures the hook only recalculates when the selected site ID
 * or sites array actually changes.
 */
export function useSelectedSite(): Site | undefined
</file>

<file path="src/stores/sites/utils/fileDownload.ts">
/**
 * File backup utility for handling file download operations.
 * Provides utilities for browser-based file downloads.
 */
export interface FileDownloadOptions {
    /** The file buffer to download */
    buffer: ArrayBuffer;
    /** The filename for the download */
    fileName: string;
    /** The MIME type of the file */
    mimeType?: string;
}
⋮----
/** The file buffer to download */
⋮----
/** The filename for the download */
⋮----
/** The MIME type of the file */
⋮----
/**
 * Helper function to create and trigger download.
 *
 * @param buffer - File data as ArrayBuffer
 * @param fileName - Name for the downloaded file
 * @param mimeType - MIME type for the file
 */
function createAndTriggerDownload(buffer: ArrayBuffer, fileName: string, mimeType: string): void
⋮----
// Safe DOM manipulation
⋮----
// No need to check if body exists; it's always present in browser environments
⋮----
// Fallback: just click without DOM manipulation
⋮----
/**
 * Triggers a file download in the browser
 */
export function downloadFile(options: FileDownloadOptions): void
⋮----
// Re-throw specific errors for better test coverage
⋮----
// Only try fallback for DOM-related errors
⋮----
/**
 * Generates a default backup filename with timestamp
 */
export function generateBackupFileName(prefix = "backup", extension = "sqlite"): string
/**
 * Handles downloading SQLite backup data as a file
 * @param downloadFn - Function that returns the backup data as Uint8Array
 * @throws Error if download fails or browser APIs are not available
 */
export async function handleSQLiteBackupDownload(downloadFunction: () => Promise<Uint8Array>): Promise<void>
⋮----
// Get the backup data
⋮----
// Validate the backup data
⋮----
// Create blob from the backup data
⋮----
// Create object URL
// URL.createObjectURL is always available in modern browsers
⋮----
// Create anchor element for download
⋮----
// Trigger download
⋮----
// Log the click error for debugging and add context
⋮----
// Re-throw with more context
⋮----
// Clean up object URL
</file>

<file path="src/stores/sites/utils/statusUpdateHandler.ts">
/**
 * Status update handler utility for managing site status updates.
 * Provides optimized incremental updates and fallback mechanisms.
 */
import type { Site, StatusUpdate } from "../../types";
import { logStoreAction, waitForElectronAPI } from "../../utils";
export interface StatusUpdateHandlerOptions {
    /** Function to get current sites */
    getSites: () => Site[];
    /** Function to set sites */
    setSites: (sites: Site[]) => void;
    /** Function to trigger full sync */
    fullSyncFromBackend: () => Promise<void>;
    /** Optional callback for additional processing */
    onUpdate?: (update: StatusUpdate) => void;
}
⋮----
/** Function to get current sites */
⋮----
/** Function to set sites */
⋮----
/** Function to trigger full sync */
⋮----
/** Optional callback for additional processing */
⋮----
/**
 * Creates a status update handler with optimized incremental updates
 */
export function createStatusUpdateHandler(options: StatusUpdateHandlerOptions)
⋮----
// Call the optional callback first
⋮----
// Smart incremental update - use the payload data directly
⋮----
// Use the complete updated site data from the backend
⋮----
return site; // Keep other sites unchanged
⋮----
// Check if the site was actually found and updated
⋮----
// Update store state efficiently
⋮----
// Site not found in current state - trigger full sync as fallback
⋮----
// Fallback to full sync on any processing error
⋮----
/**
 * Manages status update subscriptions
 */
export class StatusUpdateManager {
⋮----
/**
     * Subscribe to status updates and monitoring events
     */
async subscribe(
        handler: (update: StatusUpdate) => Promise<void>,
        fullSyncHandler?: () => Promise<void>
): Promise<void>
⋮----
// If already subscribed, unsubscribe first to avoid duplicates
⋮----
// Always wait for electronAPI to be ready before subscribing
⋮----
// Subscribe to status updates
⋮----
// Subscribe to monitoring state changes
⋮----
/**
     * Unsubscribe from status updates and monitoring events
     */
unsubscribe(): void
⋮----
// Remove all listeners for the update-status channel
⋮----
/**
     * Check if currently subscribed
     */
isSubscribed(): boolean
</file>

<file path="src/theme/ThemeManager.ts">
/**
 * ThemeManager class for handling theme selection, system preference detection,
 * and theme switching throughout the application.
 *
 * Note: Empty constructor and no-op functions are intentional design patterns.
 */
/* eslint-disable @typescript-eslint/no-empty-function */
import { themes } from "./themes";
import { Theme, ThemeName } from "./types";
/**
 * Singleton service for managing application themes.
 * Handles theme selection, system preference detection, and automatic switching.
 */
export class ThemeManager {
⋮----
/** Singleton instance */
⋮----
/** Private constructor to enforce singleton pattern */
private constructor()
/**
     * Get the singleton instance of ThemeManager.
     * Creates the instance if it doesn't exist.
     *
     * @returns ThemeManager singleton instance
     */
public static getInstance(): ThemeManager
/**
     * Get theme by name, with automatic system theme detection.
     * Handles "system" theme by detecting user's OS preference.
     *
     * @param name - Theme name to retrieve
     * @returns Theme object containing colors, typography, and spacing
     */
getTheme(name: ThemeName): Theme
⋮----
// eslint-disable-next-line security/detect-object-injection -- always light or dark
⋮----
/**
     * Get system theme preference from OS/browser settings.
     * Uses CSS media query to detect dark mode preference.
     *
     * @returns "dark" if user prefers dark mode, "light" otherwise
     */
getSystemThemePreference(): "light" | "dark"
/**
     * Listen for system theme changes and call callback when detected.
     * Useful for automatic theme switching when user changes OS settings.
     *
     * @param callback - Function to call when system theme changes
     * @returns Cleanup function to remove the event listener
     */
onSystemThemeChange(callback: (isDark: boolean) => void): () => void
⋮----
const handler = (e: MediaQueryListEvent)
⋮----
// Return cleanup function
⋮----
/**
     * Apply theme to document
     */
applyTheme(theme: Theme): void
/**
     * Apply color CSS custom properties
     */
private applyColors(root: HTMLElement, colors: Theme["colors"]): void
/**
     * Apply typography CSS custom properties
     */
private applyTypography(root: HTMLElement, typography: Theme["typography"]): void
/**
     * Apply spacing CSS custom properties
     */
private applySpacing(root: HTMLElement, spacing: Theme["spacing"]): void
/**
     * Apply shadow CSS custom properties
     */
private applyShadows(root: HTMLElement, shadows: Theme["shadows"]): void
/**
     * Apply border radius CSS custom properties
     */
private applyBorderRadius(root: HTMLElement, borderRadius: Theme["borderRadius"]): void
/**
     * Apply theme classes to document elements
     */
private applyThemeClasses(theme: Theme): void
⋮----
// Set theme class on body
⋮----
// Set dark mode class for Tailwind CSS
⋮----
/**
     * Create a custom theme based on an existing theme
     */
createCustomTheme(baseTheme: Theme, overrides: Partial<Theme>): Theme
/**
     * Get all available theme names
     */
getAvailableThemes(): ThemeName[]
/**
     * Validate if theme name is valid
     */
isValidThemeName(name: string): name is ThemeName
/**
     * Generate CSS variables string for a theme
     */
generateCSSVariables(theme: Theme): string
⋮----
// Colors
⋮----
// Typography
⋮----
// Spacing
⋮----
// Shadows
⋮----
// Border radius
</file>

<file path="src/theme/useTheme.ts">
/**
 * Theme management hook providing theme state, controls, and utility functions.
 * Handles theme switching, system theme detection, and provides color/styling utilities.
 */
/* eslint-disable unicorn/consistent-function-scoping -- Hook functions must remain inside hooks for context access */
import { useEffect, useState, useCallback } from "react";
import type { StatusType } from "../constants";
import { useSettingsStore } from "../stores";
import { themeManager } from "./ThemeManager";
import { Theme, ThemeName } from "./types";
/**
 * Main theme hook providing comprehensive theme management functionality.
 *
 * Features:
 * - Current theme state and switching
 * - System theme detection and synchronization
 * - Status-based color utilities
 * - Availability color mapping
 * - CSS variable management
 *
 * @returns Object containing theme state, setters, and utility functions
 */
export function useTheme()
⋮----
const [themeVersion, setThemeVersion] = useState(0); // Force re-renders
// Memoized getCurrentTheme to satisfy useEffect deps and avoid unnecessary re-renders
⋮----
// Update theme when settings or systemTheme change
⋮----
setThemeVersion((previous) => previous + 1); // Force re-render of all themed components
⋮----
// Listen for system theme changes
⋮----
// Set initial system theme
⋮----
// Change theme
const setTheme = (themeName: ThemeName) =>
// Toggle between light and dark
const toggleTheme = () =>
// Get theme-aware color
const getColor = (path: string): string =>
⋮----
// eslint-disable-next-line security/detect-object-injection -- Object.hasOwn ensures safety
⋮----
// Get status color
const getStatusColor = (status: StatusType): string =>
⋮----
// Only allow known status keys
⋮----
// eslint-disable-next-line security/detect-object-injection -- currentTheme.colors.status is validated against allowedStatuses
⋮----
// Fallback to a safe color if status is invalid
⋮----
// Get available themes
⋮----
themeVersion, // Include for forcing re-renders
⋮----
/**
 * Utility hook for accessing specific values from the current theme.
 * @param selector - Function that extracts a value from the theme
 * @returns The selected value from the current theme
 */
export function useThemeValue<T>(selector: (theme: Theme) => T): T
/**
 * Hook for accessing theme-aware status colors.
 * @returns Object containing status colors from the current theme
 */
export function useStatusColors()
/**
 * Hook for theme-aware CSS classes using CSS custom properties.
 * Provides utility functions for generating dynamic CSS classes based on the current theme.
 * @returns Object with methods for generating background, text, and status classes
 */
export function useThemeClasses()
⋮----
const getBackgroundClass = (variant: "primary" | "secondary" | "tertiary" = "primary") =>
const getTextClass = (variant: "primary" | "secondary" | "tertiary" | "inverse" = "primary") =>
const getBorderClass = (variant: "primary" | "secondary" | "focus" = "primary") =>
const getSurfaceClass = (variant: "base" | "elevated" | "overlay" = "base") =>
const getStatusClass = (status: "up" | "down" | "pending" | "unknown" | "paused") =>
⋮----
// Hook for availability-based colors
export function useAvailabilityColors()
⋮----
const getAvailabilityColor = (percentage: number): string =>
⋮----
// Clamp percentage between 0 and 100
⋮----
// Use theme colors for consistency
⋮----
return currentTheme.colors.status.up; // Excellent
⋮----
return currentTheme.colors.success; // Very good
⋮----
return currentTheme.colors.status.up; // Good
⋮----
return currentTheme.colors.status.pending; // Fair (warning)
⋮----
return currentTheme.colors.warning; // Warning
⋮----
return currentTheme.colors.error; // Poor
⋮----
return currentTheme.colors.status.down; // Critical
⋮----
const getAvailabilityVariant = (percentage: number): "success" | "warning" | "danger" =>
const getAvailabilityDescription = (percentage: number): string =>
</file>

<file path="electron/constants.ts">
/**
 * Backend constants for the Uptime Watcher application.
 *
 * @remarks
 * Contains monitoring defaults, timeouts, and configuration values used throughout
 * the backend process.
 *
 * @packageDocumentation
 */
/**
 * Default timeout for HTTP requests in milliseconds.
 * @defaultValue 10000
 */
⋮----
/**
 * Default check interval for new monitors in milliseconds.
 * @defaultValue 300000
 */
⋮----
/**
 * User agent string for HTTP requests.
 * @defaultValue "Uptime-Watcher/1.0"
 */
⋮----
/**
 * Retry backoff configuration for failed operations.
 * @remarks Uses exponential backoff to avoid overwhelming failing services.
 */
⋮----
/** Initial delay in milliseconds before first retry */
⋮----
/** Maximum delay in milliseconds between retries */
⋮----
/**
 * Default number of history records to retain per monitor.
 * @defaultValue 500
 */
⋮----
/**
 * Event name for status updates.
 * @defaultValue "status-update"
 */
</file>

<file path="electron/events/TypedEventBus.ts">
/**
 * Type-safe event bus with middleware support and debugging capabilities.
 *
 * @remarks
 * Enhances the standard Node.js EventEmitter with compile-time type safety,
 * middleware processing, correlation tracking, and comprehensive logging.
 * Ensures events are properly typed and provides rich debugging information.
 *
 * @example
 * ```typescript
 * interface MyEvents {
 *   'user:login': { userId: string; timestamp: number };
 *   'data:updated': { table: string; records: number };
 * }
 *
 * const bus = new TypedEventBus<MyEvents>('app-events');
 * bus.onTyped('user:login', (data) => {
 *   console.log(`User ${data.userId} logged in at ${data.timestamp}`);
 * });
 * await bus.emitTyped('user:login', { userId: '123', timestamp: Date.now() });
 * ```
 *
 * @packageDocumentation
 */
import { EventEmitter } from "node:events";
import { generateCorrelationId, logger } from "../utils/index";
/**
 * Middleware function for event processing.
 *
 * @param event - Name of the event being processed
 * @param data - Event data payload
 * @param next - Function to call to continue to the next middleware
 *
 * @remarks
 * Middleware can modify event data, add logging, collect metrics, or perform
 * other cross-cutting concerns. Call `next()` to continue processing or throw
 * an error to stop the middleware chain.
 *
 * @example
 * ```typescript
 * const loggingMiddleware: EventMiddleware = async (event, data, next) => {
 *   console.log(`Processing event: ${event}`);
 *   await next();
 *   console.log(`Completed event: ${event}`);
 * };
 * ```
 */
export type EventMiddleware<T = unknown> = (
    event: string,
    data: T,
    next: () => void | Promise<void>
) => void | Promise<void>;
/**
 * Enhanced event bus with type safety and middleware support.
 *
 * @remarks
 * Provides compile-time type checking for events, automatic correlation tracking,
 * middleware processing, and comprehensive debugging capabilities. Events are
 * processed through a middleware chain before emission.
 *
 * Features:
 * - **Type Safety**: Compile-time checking of event names and data
 * - **Middleware Support**: Pluggable processing pipeline
 * - **Correlation Tracking**: Automatic correlation IDs for debugging
 * - **Rich Metadata**: Timestamps, bus IDs, and diagnostic information
 * - **Error Handling**: Graceful error handling in middleware chain
 *
 * @typeParam EventMap - Map of event names to their data types
 *
 * @public
 */
// eslint-disable-next-line unicorn/prefer-event-target -- EventEmitter required for Node.js specific features
export class TypedEventBus<EventMap extends Record<string, unknown>> extends EventEmitter {
⋮----
/**
     * Create a new typed event bus.
     *
     * @param name - Optional name for the bus (used in logging and diagnostics)
     *
     * @remarks
     * If no name is provided, a unique correlation ID will be generated.
     * The bus is configured with a reasonable max listener limit for development use.
     */
constructor(name?: string)
⋮----
// Set max listeners to prevent warnings in development
⋮----
/**
     * Register middleware to process events before emission.
     *
     * @param middleware - Middleware function to register
     *
     * @remarks
     * Middleware is executed in registration order. Each middleware must call
     * `next()` to continue the chain or throw an error to abort processing.
     */
use(middleware: EventMiddleware): void
/**
     * Remove a specific middleware from the processing chain.
     *
     * @param middleware - The middleware function to remove
     * @returns `true` if middleware was found and removed, `false` otherwise
     */
removeMiddleware(middleware: EventMiddleware): boolean
/**
     * Clear all registered middleware.
     *
     * @remarks
     * Removes all middleware functions from the processing chain.
     * Events will be emitted directly without middleware processing.
     */
clearMiddleware(): void
/**
     * Emit a typed event through the middleware chain.
     *
     * @param event - The event name (must be a key in EventMap)
     * @param data - The event data (must match the type for this event)
     *
     * @throws {@link Error} When middleware processing fails
     *
     * @remarks
     * Guarantees type safety between event name and data. The event is processed
     * through all registered middleware before being emitted to listeners.
     * Automatic metadata is added including correlation ID, timestamp, and bus ID.
     */
async emitTyped<K extends keyof EventMap>(event: K, data: EventMap[K]): Promise<void>
⋮----
// Process through middleware chain
⋮----
// Emit the actual event with enhanced data
⋮----
/**
     * Register a typed event listener with guaranteed type safety.
     *
     * @param event - The event name to listen for
     * @param listener - Function to call when the event is emitted
     * @returns This event bus instance for chaining
     *
     * @remarks
     * The listener receives the original event data plus automatically added metadata.
     * TypeScript will enforce that the listener signature matches the event data type.
     */
onTyped<K extends keyof EventMap>(
        event: K,
        listener: (data: EventMap[K] & { _meta: EventMetadata }) => void
): this
/**
     * Register a one-time typed event listener.
     *
     * @param event - The event name to listen for
     * @param listener - Function to call when the event is emitted (called only once)
     * @returns This event bus instance for chaining
     *
     * @remarks
     * The listener is automatically removed after the first time the event is emitted.
     */
onceTyped<K extends keyof EventMap>(
        event: K,
        listener: (data: EventMap[K] & { _meta: EventMetadata }) => void
): this
/**
     * Remove typed event listener(s).
     *
     * @param event - The event name
     * @param listener - Specific listener to remove, or undefined to remove all listeners
     * @returns This event bus instance for chaining
     *
     * @remarks
     * If no listener is specified, all listeners for the event are removed.
     */
offTyped<K extends keyof EventMap>(
        event: K,
        listener?: (data: EventMap[K] & { _meta: EventMetadata }) => void
): this
/**
     * Process event through middleware chain.
     *
     * @param eventName - Name of the event being processed
     * @param data - Event data payload
     * @param correlationId - Unique ID for tracking this event emission
     *
     * @throws {@link Error} When any middleware in the chain throws
     *
     * @remarks
     * Executes middleware in registration order. If any middleware throws an error,
     * the chain is aborted and the error is propagated to the caller.
     */
private async processMiddleware(eventName: string, data: unknown, correlationId: string): Promise<void>
⋮----
const processNext = async (currentIndex: number): Promise<void> =>
⋮----
// eslint-disable-next-line security/detect-object-injection
⋮----
/**
     * Get diagnostic information about the event bus.
     *
     * @returns Diagnostic data including listener counts and middleware information
     *
     * @remarks
     * Provides runtime information useful for debugging and monitoring.
     * Includes listener counts per event, middleware count, and configuration.
     */
getDiagnostics(): EventBusDiagnostics
⋮----
/**
 * Metadata automatically added to all emitted events.
 *
 * @remarks
 * Provides debugging and tracking information automatically added to every event.
 * Available in all event listeners under the `_meta` property.
 *
 * @public
 */
export interface EventMetadata {
    /** Unique identifier for tracking this specific event emission */
    correlationId: string;
    /** Identifier of the event bus that emitted this event */
    busId: string;
    /** Unix timestamp when the event was emitted */
    timestamp: number;
    /** Name of the event that was emitted */
    eventName: string;
}
⋮----
/** Unique identifier for tracking this specific event emission */
⋮----
/** Identifier of the event bus that emitted this event */
⋮----
/** Unix timestamp when the event was emitted */
⋮----
/** Name of the event that was emitted */
⋮----
/**
 * Diagnostic information about an event bus instance.
 *
 * @remarks
 * Provides runtime insights into event bus configuration and usage.
 * Useful for debugging, monitoring, and performance analysis.
 *
 * @public
 */
export interface EventBusDiagnostics {
    /** Unique identifier for this event bus instance */
    busId: string;
    /** Number of registered middleware functions */
    middlewareCount: number;
    /** Number of listeners registered for each event */
    listenerCounts: Record<string, number>;
    /** Maximum number of listeners allowed per event */
    maxListeners: number;
}
⋮----
/** Unique identifier for this event bus instance */
⋮----
/** Number of registered middleware functions */
⋮----
/** Number of listeners registered for each event */
⋮----
/** Maximum number of listeners allowed per event */
⋮----
/**
 * Utility function to create a typed event bus instance.
 *
 * @param name - Optional name for the bus
 * @returns A new TypedEventBus instance
 *
 * @remarks
 * Convenience factory function for creating typed event bus instances.
 * Equivalent to `new TypedEventBus<EventMap>(name)`.
 *
 * @example
 * ```typescript
 * interface AppEvents {
 *   'user:login': { userId: string };
 * }
 *
 * const bus = createTypedEventBus<AppEvents>('main-bus');
 * ```
 */
export function createTypedEventBus<EventMap extends Record<string, unknown>>(name?: string): TypedEventBus<EventMap>
</file>

<file path="electron/services/database/utils/databaseSchema.ts">
import { Database } from "node-sqlite3-wasm";
import { logger } from "../../../utils/index";
import { generateMonitorTableSchema } from "./dynamicSchema";
/**
 * Database schema management utilities.
 *
 * @remarks
 * Provides functions for creating database tables, indexes, and setting up
 * validation frameworks. All table creation operations are idempotent using
 * "IF NOT EXISTS" clauses.
 */
/**
 * Create all required database tables if they don't exist.
 *
 * @param db - SQLite database instance
 * @throws When table creation fails
 *
 * @remarks
 * Creates the following tables:
 * - sites: Site configuration and monitoring status
 * - monitors: Monitor configuration and runtime data (dynamic schema)
 * - history: Historical monitoring data
 * - settings: Application configuration
 * - stats: Runtime statistics
 * - logs: Application logs
 */
export function createDatabaseTables(db: Database): void
⋮----
// Sites table
⋮----
// Monitors table with dynamic schema based on monitor type registry
⋮----
// History table
⋮----
// Settings table
⋮----
// Stats table
⋮----
// Logs table
⋮----
/**
 * Create database indexes for better query performance.
 *
 * @param db - SQLite database instance
 * @throws When index creation fails
 *
 * @remarks
 * Creates the following indexes:
 * - idx_monitors_site_identifier: Fast site-based monitor queries
 * - idx_monitors_type: Monitor type filtering
 * - idx_history_monitor_id: Fast history lookups by monitor
 * - idx_history_timestamp: Time-based history queries
 */
export function createDatabaseIndexes(db: Database): void
⋮----
// Index on monitor site_identifier for faster site queries
⋮----
// Index on monitor type for monitor type queries
⋮----
// Index on history monitor_id for faster history queries
⋮----
// Index on history timestamp for time-based queries
⋮----
/**
 * Setup monitor type validation framework.
 *
 * @throws When validation setup fails
 *
 * @remarks
 * Future versions will integrate with MonitorTypeRegistry to provide
 * runtime validation of monitor types. Currently sets up the foundation
 * for extensible type validation.
 */
export function setupMonitorTypeValidation(): void
⋮----
// This would integrate with the MonitorTypeRegistry
// For now, we'll add a basic validation framework
// Future versions could add a CHECK constraint or trigger
</file>

<file path="electron/services/monitoring/HttpMonitor.ts">
/**
 * HTTP/HTTPS monitoring service for web endpoint health checks.
 *
 * @remarks
 * Provides comprehensive HTTP monitoring capabilities with advanced Axios features
 * for optimal performance and reliability. Supports precise response time measurement,
 * per-monitor timeout configuration, and intelligent status code interpretation.
 *
 * Key features:
 * - Precise response time measurement using performance.now()
 * - Per-monitor timeout configuration support
 * - Intelligent status code handling (2xx/4xx = up, 5xx = down)
 * - Connection pooling with HTTP/HTTPS agents
 * - Request/response size limits for security
 * - Comprehensive error handling with network detection
 * - Retry logic for transient failures
 *
 * @example
 * ```typescript
 * const httpMonitor = new HttpMonitor({ timeout: 5000 });
 * const result = await httpMonitor.check({
 *   id: "mon_1",
 *   type: "http",
 *   url: "https://example.com",
 *   status: "pending",
 *   // ... other monitor properties
 * });
 * console.log(`Status: ${result.status}, Response time: ${result.responseTime}ms`);
 * ```
 *
 * @packageDocumentation
 */
import { AxiosInstance } from "axios";
import { DEFAULT_REQUEST_TIMEOUT, RETRY_BACKOFF, USER_AGENT } from "../../constants";
import { isDev } from "../../electronUtils";
import { Site } from "../../types";
import { logger, withRetry } from "../../utils/index";
import { IMonitorService, MonitorCheckResult, MonitorConfig } from "./types";
import { determineMonitorStatus, handleCheckError, createHttpClient, createErrorResult } from "./utils";
/**
 * Declaration merging to extend Axios types with timing metadata.
 *
 * @remarks
 * Extends Axios request/response interfaces to support precise timing measurements
 * through request interceptors and response metadata.
 */
⋮----
/** Extended request config with timing metadata */
interface InternalAxiosRequestConfig {
        metadata?: {
            /** High-precision start time for response time calculation */
            startTime: number;
        };
    }
⋮----
/** High-precision start time for response time calculation */
⋮----
/** Extended response with calculated response time */
interface AxiosResponse {
        /** Calculated response time in milliseconds */
        responseTime?: number;
    }
⋮----
/** Calculated response time in milliseconds */
⋮----
/** Extended error with response time (if available) */
interface AxiosError {
        /** Response time at point of failure (if available) */
        responseTime?: number;
    }
⋮----
/** Response time at point of failure (if available) */
⋮----
/**
 * Service for performing HTTP/HTTPS monitoring checks.
 *
 * @remarks
 * Implements the IMonitorService interface to provide HTTP endpoint monitoring
 * with advanced features for reliability and performance. Uses Axios with custom
 * interceptors for precise timing and comprehensive error handling.
 *
 * The service is designed for monitoring use cases where response time accuracy
 * and failure detection are critical. It includes intelligent status code
 * interpretation suitable for uptime monitoring scenarios.
 */
export class HttpMonitor implements IMonitorService {
⋮----
/** Configuration for HTTP monitoring behavior */
⋮----
/** Axios instance with custom interceptors and configuration */
⋮----
/**
     * Initialize the HTTP monitor with optional configuration.
     *
     * @param config - Optional configuration overrides for HTTP monitoring
     *
     * @remarks
     * Creates an Axios instance with optimized settings for monitoring,
     * including timing interceptors, appropriate timeouts, and security limits.
     */
constructor(config: MonitorConfig =
⋮----
// Create Axios instance with advanced configuration (best practices)
⋮----
/**
     * Get the monitor type this service handles.
     */
public getType(): Site["monitors"][0]["type"]
/**
     * Perform an HTTP health check on the given monitor.
     * Uses per-monitor retry attempts and timeout configuration.
     */
public async check(monitor: Site["monitors"][0]): Promise<MonitorCheckResult>
/**
     * Perform health check with retry logic.
     */
private async performHealthCheckWithRetry(
        url: string,
        timeout: number,
        maxRetries: number
): Promise<MonitorCheckResult>
⋮----
// Convert maxRetries (additional attempts) to totalAttempts for withRetry utility
⋮----
/**
     * Perform a single health check attempt without retry logic.
     */
private async performSingleHealthCheck(url: string, timeout: number): Promise<MonitorCheckResult>
⋮----
// Determine status based on HTTP status code
⋮----
/**
     * Make the actual HTTP request using Axios.
     */
private async makeRequest(url: string, timeout: number)
⋮----
// Use our configured Axios instance with specific timeout override
⋮----
/**
     * Update the configuration for this monitor.
     * Recreates the Axios instance with updated configuration.
     */
public updateConfig(config: Partial<MonitorConfig>): void
⋮----
// Recreate Axios instance with updated configuration
⋮----
/**
     * Get the current configuration.
     */
public getConfig(): MonitorConfig
</file>

<file path="electron/services/monitoring/MonitorFactory.ts">
/* eslint-disable @typescript-eslint/no-extraneous-class */
import { Site } from "../../types";
import { IMonitorService, MonitorConfig } from "./types";
import { isValidMonitorType, getRegisteredMonitorTypes, getMonitorServiceFactory } from "./MonitorTypeRegistry";
/**
 * Factory for creating and managing monitor services.
 * Uses the registry's service factories for complete automation.
 */
export class MonitorFactory {
⋮----
/**
     * Get the appropriate monitor service for the given monitor type.
     *
     * @param type - Monitor type string
     * @param config - Optional monitor configuration
     * @returns Monitor service instance
     * @throws Error if monitor type is not supported
     */
public static getMonitor(type: Site["monitors"][0]["type"], config?: MonitorConfig): IMonitorService
⋮----
// Validate monitor type using registry
⋮----
// Get factory from registry
⋮----
// Get or create service instance
⋮----
/**
     * Update configuration for all monitor types.
     */
public static updateConfig(config: MonitorConfig): void
⋮----
// Update config for all initialized monitor instances
⋮----
/**
     * Get all available monitor types from registry.
     */
public static getAvailableTypes(): string[]
/**
     * Clear all cached service instances.
     * Useful for testing or configuration reloading.
     */
public static clearCache(): void
</file>

<file path="electron/UptimeOrchestrator.ts">
/**
 * Core uptime monitoring orchestrator and application coordinator.
 *
 * @remarks
 * The UptimeOrchestrator serves as the central coordination point for all monitoring
 * operations in the application. It uses a service-based architecture to coordinate
 * between specialized managers (DatabaseManager, MonitorManager, SiteManager) and
 * provides a unified API for uptime monitoring functionality.
 *
 * Key responsibilities:
 * - Coordinate operations between specialized managers
 * - Provide unified API for frontend interactions
 * - Handle internal event communication between components
 * - Manage application lifecycle and initialization
 * - Ensure proper error handling and logging across all operations
 *
 * The orchestrator extends TypedEventBus to provide type-safe event communication
 * between the frontend and backend, as well as internal component coordination.
 *
 * @example
 * ```typescript
 * const orchestrator = new UptimeOrchestrator();
 * await orchestrator.initialize();
 *
 * // Add a new site
 * const site = await orchestrator.addSite({
 *   identifier: "site_123",
 *   name: "My Website",
 *   monitors: [...],
 *   monitoring: true
 * });
 *
 * // Start monitoring
 * await orchestrator.startMonitoring();
 * ```
 *
 * @packageDocumentation
 */
import type { UptimeEvents } from "./events/eventTypes";
import { DEFAULT_HISTORY_LIMIT } from "./constants";
import { TypedEventBus, createLoggingMiddleware, createErrorHandlingMiddleware } from "./events";
import { DatabaseManager, MonitorManager, SiteManager } from "./managers";
import { DatabaseService, SiteRepository, MonitorRepository, HistoryRepository, SettingsRepository } from "./services";
import { Site, StatusUpdate, Monitor } from "./types";
import { logger } from "./utils";
/**
 * Combined event interface for the orchestrator.
 *
 * @remarks
 * Supports both internal manager events and public frontend events,
 * providing a unified event system for the entire application.
 */
type OrchestratorEvents = UptimeEvents;
/**
 * Data structure for internal start monitoring request events.
 *
 * @remarks Internal use only for coordinating between managers.
 */
interface StartMonitoringRequestData {
    /** Site identifier for the monitoring request */
    identifier: string;
    /** Specific monitor ID to start (optional) */
    monitorId: string;
}
⋮----
/** Site identifier for the monitoring request */
⋮----
/** Specific monitor ID to start (optional) */
⋮----
/**
 * Data structure for internal stop monitoring request events.
 *
 * @remarks Internal use only for coordinating between managers.
 */
interface StopMonitoringRequestData {
    /** Site identifier for the monitoring request */
    identifier: string;
    /** Specific monitor ID to stop (optional) */
    monitorId: string;
}
⋮----
/** Site identifier for the monitoring request */
⋮----
/** Specific monitor ID to stop (optional) */
⋮----
/**
 * Data structure for internal monitoring status check events.
 *
 * @remarks Internal use only for coordinating between managers.
 */
interface IsMonitoringActiveRequestData {
    /** Site identifier for the status check */
    identifier: string;
    /** Specific monitor ID to check (optional) */
    monitorId: string;
}
⋮----
/** Site identifier for the status check */
⋮----
/** Specific monitor ID to check (optional) */
⋮----
/**
 * Data structure for internal monitor restart events.
 *
 * @remarks Internal use only for coordinating between managers.
 */
interface RestartMonitoringRequestData {
    /** Site identifier for the restart request */
    identifier: string;
    /** Monitor configuration for restart */
    monitor: Monitor;
}
⋮----
/** Site identifier for the restart request */
⋮----
/** Monitor configuration for restart */
⋮----
/**
 * Data structure for internal sites cache update events.
 *
 * @remarks Internal use only for coordinating between managers.
 */
interface UpdateSitesCacheRequestData {
    /** Updated sites array for cache synchronization */
    sites: Site[];
}
⋮----
/** Updated sites array for cache synchronization */
⋮----
/**
 * Data structure for history limit update events.
 *
 * @remarks Internal use only for coordinating between managers.
 */
interface HistoryLimitUpdatedData {
    /** New history retention limit */
    limit: number;
}
⋮----
/** New history retention limit */
⋮----
interface SiteEventData {
    site: Site;
    timestamp: number;
    identifier?: string;
    updatedFields?: string[];
}
interface MonitorStatusChangedData {
    siteId: string;
    monitor: Monitor;
    site: Site;
    newStatus: string;
    previousStatus: string;
    timestamp: number;
}
interface SystemErrorData {
    error: Error;
    context: string;
}
/**
 * Core uptime monitoring orchestrator that coordinates specialized managers.
 *
 * This class serves as a lightweight coordinator that delegates operations to:
 * - SiteManager: Site CRUD operations and cache management
 * - MonitorManager: Monitoring operations and scheduling
 * - DatabaseManager: Database operations and data management
 *
 * Uses TypedEventBus to provide real-time updates to the renderer process with type safety.
 *
 * Events emitted:
 * - status-update: When monitor status changes
 * - site-monitor-down: When a monitor goes down
 * - site-monitor-up: When a monitor comes back up
 * - db-error: When database operations fail
 *
 * @example
 * ```typescript
 * const orchestrator = new UptimeOrchestrator();
 * orchestrator.on('status-update', (data) => console.log(data));
 * await orchestrator.addSite({ identifier: 'example', monitors: [...] });
 * orchestrator.startMonitoring();
 * ```
 */
export class UptimeOrchestrator extends TypedEventBus<OrchestratorEvents> {
⋮----
// Manager instances
⋮----
constructor()
⋮----
// Set up middleware for the event bus
⋮----
// Initialize repositories
⋮----
// Initialize managers with event-driven dependencies
⋮----
// Now update SiteManager with MonitorManager integration
⋮----
// Set up event-driven communication between managers
⋮----
/**
     * Set up event handlers for inter-manager communication.
     */
private setupEventHandlers(): void
⋮----
// Handle site manager internal events
⋮----
// Emit response event with the result
⋮----
// Emit response event with the result
⋮----
// Check if the monitor is actively running in the scheduler
⋮----
// For this implementation, we'll emit the response event with the result
⋮----
// Use the MonitorScheduler's restartMonitor method which is designed for this exact use case
⋮----
// Emit response event with the result
⋮----
// Handle database manager internal events
⋮----
// CRITICAL: Set up monitoring for each loaded site
// This ensures sites loaded from database get proper monitoring setup
⋮----
// Respond with sites from cache
⋮----
// Forward internal manager events to public typed events for renderer process
⋮----
// Transform typed events to simple events for ApplicationService
⋮----
// Emit the simple status-update event that ApplicationService expects
⋮----
site: data.site, // Use complete site data from the event
⋮----
// Also emit monitor up/down events
⋮----
site: data.site, // Use complete site data from the event
⋮----
site: data.site, // Use complete site data from the event
⋮----
// Transform system error events
⋮----
/**
     * Initialize the orchestrator and all its managers.
     */
public async initialize(): Promise<void>
// Site Management Operations
public async getSites(): Promise<Site[]>
public getSitesFromCache(): Site[]
public async addSite(siteData: Site): Promise<Site>
⋮----
// Set up monitoring for the new site
⋮----
public async removeSite(identifier: string): Promise<boolean>
public async removeMonitor(siteIdentifier: string, monitorId: string): Promise<boolean>
⋮----
// Stop monitoring for this specific monitor first
⋮----
// Remove the monitor through the site manager
⋮----
public async updateSite(identifier: string, updates: Partial<Site>): Promise<Site>
// Monitoring Operations
public async startMonitoring(): Promise<void>
public async stopMonitoring(): Promise<void>
public async startMonitoringForSite(identifier: string, monitorId?: string): Promise<boolean>
public async stopMonitoringForSite(identifier: string, monitorId?: string): Promise<boolean>
public async checkSiteManually(identifier: string, monitorId?: string): Promise<StatusUpdate | null>
// Database Operations
public async exportData(): Promise<string>
public async importData(data: string): Promise<boolean>
public async downloadBackup(): Promise<
public async refreshSites(): Promise<Site[]>
// History Management
public async setHistoryLimit(limit: number): Promise<void>
public getHistoryLimit(): number
// Status Information
public isMonitoringActive(): boolean
</file>

<file path="electron/utils/database/DataBackupService.ts">
/**
 * Service for data backup operations.
 * Provides a testable, dependency-injected service for backup management.
 */
import { UptimeEvents, TypedEventBus } from "../../events/index";
import { DatabaseService } from "../../services/index";
import { Logger, SiteCacheInterface, SiteLoadingError } from "./interfaces";
/**
 * Configuration for data backup operations.
 */
export interface DataBackupConfig {
    eventEmitter: TypedEventBus<UptimeEvents>;
    databaseService: DatabaseService;
    logger: Logger;
}
/**
 * Service for handling data backup operations.
 * Separates data operations from side effects for better testability.
 */
export class DataBackupService {
⋮----
constructor(config: DataBackupConfig)
/**
     * Download SQLite database backup.
     * Pure data operation that returns backup buffer and filename.
     */
async downloadDatabaseBackup(): Promise<
⋮----
/**
 * Orchestrates the complete data backup process.
 * Coordinates backup operations with side effects.
 */
export class DataBackupOrchestrator {
⋮----
constructor(dataBackupService: DataBackupService)
/**
     * Download database backup.
     * Coordinates the complete backup process.
     */
async downloadBackup(): Promise<
/**
     * Refresh sites from cache.
     * Simple operation that returns sites from the provided cache.
     */
refreshSitesFromCache(siteCache: SiteCacheInterface): Promise<
</file>

<file path="electron/utils/database/interfaces.ts">
/**
 * Interfaces for database utilities to support dependency injection and testing.
 */
import { UptimeEvents, TypedEventBus } from "../../events/index";
import { SiteRepository, MonitorRepository, HistoryRepository, SettingsRepository } from "../../services/index";
import { Site } from "../../types";
/**
 * Logger interface abstraction.
 */
export interface Logger {
    debug(message: string, ...args: unknown[]): void;
    error(message: string, error?: unknown, ...args: unknown[]): void;
    info(message: string, ...args: unknown[]): void;
    warn(message: string, ...args: unknown[]): void;
}
⋮----
debug(message: string, ...args: unknown[]): void;
error(message: string, error?: unknown, ...args: unknown[]): void;
info(message: string, ...args: unknown[]): void;
warn(message: string, ...args: unknown[]): void;
⋮----
/**
 * Configuration for site loading operations.
 */
export interface SiteLoadingConfig {
    /** Repository dependencies */
    repositories: {
        site: SiteRepository;
        monitor: MonitorRepository;
        history: HistoryRepository;
        settings: SettingsRepository;
    };
    /** Logger instance */
    logger: Logger;
    /** Typed event emitter for error handling */
    eventEmitter: TypedEventBus<UptimeEvents>;
}
⋮----
/** Repository dependencies */
⋮----
/** Logger instance */
⋮----
/** Typed event emitter for error handling */
⋮----
/**
 * Configuration for site writing operations.
 */
export interface SiteWritingConfig {
    /** Repository dependencies */
    repositories: {
        site: SiteRepository;
        monitor: MonitorRepository;
    };
    /** Logger instance */
    logger: Logger;
}
⋮----
/** Repository dependencies */
⋮----
/** Logger instance */
⋮----
/**
 * Configuration for monitoring operations.
 */
export interface MonitoringConfig {
    /** Function to start monitoring for a site/monitor */
    startMonitoring: (identifier: string, monitorId: string) => Promise<boolean>;
    /** Function to stop monitoring for a site/monitor */
    stopMonitoring: (identifier: string, monitorId: string) => Promise<boolean>;
    /** Function to set history limit */
    setHistoryLimit: (limit: number) => void;
    /** Function to setup new monitors for a site */
    setupNewMonitors: (site: Site, newMonitorIds: string[]) => Promise<void>;
}
⋮----
/** Function to start monitoring for a site/monitor */
⋮----
/** Function to stop monitoring for a site/monitor */
⋮----
/** Function to set history limit */
⋮----
/** Function to setup new monitors for a site */
⋮----
/**
 * Site cache interface with advanced cache management capabilities.
 */
export interface SiteCacheInterface {
    get(identifier: string): Site | undefined;
    set(identifier: string, site: Site): void;
    delete(identifier: string): boolean;
    clear(): void;
    size(): number;
    entries(): IterableIterator<[string, Site]>;
    /** Invalidate cache entry and emit invalidation event */
    invalidate(identifier: string): void;
    /** Invalidate all cache entries */
    invalidateAll(): void;
    /** Check if cache entry exists */
    has(identifier: string): boolean;
    /** Get all cached sites as array */
    getAll(): Site[];
    /** Bulk update cache with new data */
    bulkUpdate(sites: Site[]): void;
}
⋮----
get(identifier: string): Site | undefined;
set(identifier: string, site: Site): void;
delete(identifier: string): boolean;
clear(): void;
size(): number;
entries(): IterableIterator<[string, Site]>;
/** Invalidate cache entry and emit invalidation event */
invalidate(identifier: string): void;
/** Invalidate all cache entries */
invalidateAll(): void;
/** Check if cache entry exists */
has(identifier: string): boolean;
/** Get all cached sites as array */
getAll(): Site[];
/** Bulk update cache with new data */
bulkUpdate(sites: Site[]): void;
⋮----
/**
 * Advanced implementation of ISiteCache with invalidation support.
 */
export class SiteCache implements SiteCacheInterface {
⋮----
/**
     * Register callback for cache invalidation events.
     *
     * @param callback - Function to call when cache is invalidated
     * @returns Cleanup function to remove the callback
     */
public onInvalidation(callback: (identifier?: string) => void): () => void
get(identifier: string): Site | undefined
set(identifier: string, site: Site): void
delete(identifier: string): boolean
clear(): void
size(): number
entries(): IterableIterator<[string, Site]>
invalidate(identifier: string): void
invalidateAll(): void
has(identifier: string): boolean
getAll(): Site[]
bulkUpdate(sites: Site[]): void
private notifyInvalidation(identifier?: string): void
⋮----
// Silently handle callback errors to prevent cache corruption
⋮----
/**
 * Custom error types for better error handling.
 */
export class SiteNotFoundError extends Error {
⋮----
constructor(identifier: string)
⋮----
export class SiteCreationError extends Error {
⋮----
constructor(identifier: string, cause?: Error)
⋮----
export class SiteUpdateError extends Error {
export class SiteDeletionError extends Error {
export class SiteLoadingError extends Error {
⋮----
constructor(message: string, cause?: Error)
</file>

<file path="electron/utils/operationalHooks.ts">
/**
 * Operational hooks utility for standardizing error handling, retries, and event emission.
 * Provides consistent patterns for async operations with observability.
 */
import { TypedEventBus } from "../events/TypedEventBus";
import { UptimeEvents } from "../events/eventTypes";
import { logger } from "./logger";
/**
 * Configuration for operational hooks.
 */
export interface OperationalHooksConfig<T = unknown> {
    /**
     * Name of the operation for logging and event emission.
     */
    operationName: string;
    /**
     * Maximum number of retry attempts.
     * @defaultValue 3
     */
    maxRetries?: number;
    /**
     * Initial delay between retries in milliseconds.
     * @defaultValue 100
     */
    initialDelay?: number;
    /**
     * Backoff strategy for retry delays.
     * @defaultValue "exponential"
     */
    backoff?: "linear" | "exponential";
    /**
     * Event emitter for operation events.
     */
    eventEmitter?: TypedEventBus<UptimeEvents>;
    /**
     * Context data to include in events.
     */
    context?: Record<string, unknown>;
    /**
     * Callback when retry is attempted.
     */
    onRetry?: (attempt: number, error: Error) => void | Promise<void>;
    /**
     * Callback when operation succeeds.
     */
    onSuccess?: (result: T) => void | Promise<void>;
    /**
     * Callback when operation fails permanently.
     */
    onFailure?: (error: Error, attempts: number) => void | Promise<void>;
    /**
     * Whether to emit events for this operation.
     * @defaultValue true
     */
    emitEvents?: boolean;
    /**
     * Whether to throw on final failure.
     * @defaultValue true
     */
    throwOnFailure?: boolean;
}
⋮----
/**
     * Name of the operation for logging and event emission.
     */
⋮----
/**
     * Maximum number of retry attempts.
     * @defaultValue 3
     */
⋮----
/**
     * Initial delay between retries in milliseconds.
     * @defaultValue 100
     */
⋮----
/**
     * Backoff strategy for retry delays.
     * @defaultValue "exponential"
     */
⋮----
/**
     * Event emitter for operation events.
     */
⋮----
/**
     * Context data to include in events.
     */
⋮----
/**
     * Callback when retry is attempted.
     */
⋮----
/**
     * Callback when operation succeeds.
     */
⋮----
/**
     * Callback when operation fails permanently.
     */
⋮----
/**
     * Whether to emit events for this operation.
     * @defaultValue true
     */
⋮----
/**
     * Whether to throw on final failure.
     * @defaultValue true
     */
⋮----
/**
 * Emit operation start event safely.
 */
async function emitStartEvent(
    eventEmitter: TypedEventBus<UptimeEvents>,
    operationName: string,
    startTime: number,
    context: Record<string, unknown>
): Promise<void>
/**
 * Handle successful operation completion.
 */
async function handleSuccess<T>(
    result: T,
    config: OperationalHooksConfig<T>,
    operationName: string,
    startTime: number,
    attempt: number,
    operationId: string
): Promise<T>
⋮----
// Call success callback
⋮----
// Emit success event
⋮----
/**
 * Handle operation failure.
 */
async function handleFailure<T>(
    error: Error,
    config: OperationalHooksConfig<T>,
    operationName: string,
    startTime: number,
    attempt: number,
    operationId: string
): Promise<T>
⋮----
// Emit failure event
⋮----
/**
 * Handle retry attempt.
 */
async function handleRetry<T>(
    error: Error,
    config: OperationalHooksConfig<T>,
    operationName: string,
    attempt: number,
    operationId: string
): Promise<void>
/**
 * Wraps an async operation with retry logic, error handling, and event emission.
 */
export async function withOperationalHooks<T>(
    operation: () => Promise<T>,
    config: OperationalHooksConfig<T>
): Promise<T>
⋮----
// Emit operation start event
⋮----
// If this was the last attempt, handle failure
⋮----
// Handle retry
⋮----
// This should never be reached, but TypeScript needs it
⋮----
/**
 * Calculate retry delay based on attempt number and backoff strategy.
 */
function calculateDelay(attempt: number, initialDelay: number, backoff: "linear" | "exponential"): number
/**
 * Generate a unique operation ID for tracking.
 */
function generateOperationId(): string
/**
 * Specialized wrapper for database operations with common patterns.
 */
export async function withDatabaseOperation<T>(
    operation: () => Promise<T>,
    operationName: string,
    eventEmitter?: TypedEventBus<UptimeEvents>,
    context?: Record<string, unknown>
): Promise<T>
/**
 * Specialized wrapper for cache operations with background loading.
 */
export async function withCacheOperation<T>(
    operation: () => Promise<T>,
    operationName: string,
    eventEmitter?: TypedEventBus<UptimeEvents>,
    context?: Record<string, unknown>
): Promise<T>
⋮----
maxRetries: 1, // Cache operations typically don't retry
⋮----
throwOnFailure: false, // Cache operations should not throw
</file>

<file path="src/App.tsx">
/**
 * Main App component for Uptime Watcher application.
 * Manages global state, modals, notifications, and renders the main application layout.
 */
import { useEffect, useState } from "react";
import type { StatusUpdate } from "./types";
import { AddSiteForm, SiteList, Header, Settings, SiteDetails } from "./components";
import { UI_DELAYS } from "./constants";
import { useBackendFocusSync, useSelectedSite } from "./hooks";
import { logger } from "./services";
import { ErrorBoundary, useErrorStore, useSettingsStore, useSitesStore, useUIStore, useUpdatesStore } from "./stores";
import { ThemeProvider, ThemedBox, ThemedText, ThemedButton, useTheme } from "./theme";
/**
 * Main application component that serves as the root of the Uptime Watcher app.
 *
 * Features:
 * - Global state management via focused Zustand stores
 * - Theme management with light/dark mode support
 * - Modal management (Settings, Site Details)
 * - Error and update notifications
 * - Loading states with delayed overlay
 * - Real-time status updates subscription
 * - Focus-based backend synchronization
 *
 * @returns The main App component JSX
 */
⋮----
// Error store
⋮----
// Sites store
⋮----
// Settings store
⋮----
// UI store
⋮----
// Updates store
⋮----
// Delayed loading state to prevent flash for quick operations
⋮----
/**
     * Only show loading overlay if loading takes more than 100ms
     * This prevents flash for quick operations while still providing feedback for longer ones
     */
⋮----
/**
     * Initialize the application and set up status update subscriptions.
     * This effect handles:
     * - Development logging
     * - App initialization
     * - Status update subscription with smart incremental updates
     * - Cleanup on component unmount
     */
⋮----
const initializeApp = async () =>
⋮----
// Get fresh references to avoid stale closures
⋮----
// Initialize both stores
⋮----
// Subscribe to status updates
⋮----
// Optional callback for additional processing if needed
⋮----
// Cleanup
⋮----
}, []); // Empty dependency array - this should only run once
// Focus-based state synchronization (disabled by default for performance)
useBackendFocusSync(false); // Set to true to enable focus-based backend sync
⋮----
{/* Global Loading Overlay */}
⋮----
{/* Global Error Notification */}
⋮----
{/* Update Notification */}
⋮----
applyUpdate();
⋮----
{/* Main content */}
⋮----
{/* Sidebar */}
⋮----
{/* Settings Modal */}
⋮----
{/* Site Details Modal */}
</file>

<file path="src/components/AddSiteForm/AddSiteForm.tsx">
/**
 * AddSiteForm component for creating new sites and adding monitors to existing sites.
 * Provides a comprehensive form with validation and flexible configuration options.
 * Supports both HTTP and port monitoring types, with customizable check intervals.
 */
import React, { useState, useEffect, useCallback } from "react";
import { UI_DELAYS, CHECK_INTERVALS } from "../../constants";
import { logger } from "../../services";
import { useErrorStore, useSitesStore } from "../../stores";
import { ThemedBox, ThemedText, ThemedButton, useTheme } from "../../theme";
import type { MonitorType } from "../../types";
import { generateUuid } from "../../utils/data/generateUuid";
import { TextField, SelectField, RadioGroup } from "./FormFields";
import { useDynamicHelpText } from "../dynamic-monitor-ui";
import { DynamicMonitorFields } from "./DynamicMonitorFields";
import { handleSubmit } from "./Submit";
import { useAddSiteForm } from "../SiteDetails/useAddSiteForm";
import { useMonitorTypes } from "../../hooks/useMonitorTypes";
/**
 * Main form component for adding new monitoring sites or monitors.
 *
 * Features:
 * - Create new sites with monitors
 * - Add monitors to existing sites
 * - Support for HTTP and port monitoring
 * - Form validation and error handling
 * - Configurable check intervals
 * - Responsive design with loading states
 *
 * The component uses a custom hook (useAddSiteForm) for state management
 * and modular sub-components for form fields and submission handling.
 *
 * @returns JSX element containing the complete add site form
 */
⋮----
// Load monitor types from backend
⋮----
// Use our custom hook for form state management
⋮----
// Get dynamic help text for the current monitor type
⋮----
// Delayed loading state for button spinner (100ms delay)
⋮----
return () => {}; // Return empty cleanup function for consistency
⋮----
// Memoized submit handler
⋮----
onSuccess: resetForm, // Reset form on successful submission
⋮----
// Memoized error clear handler
⋮----
{/* Add mode toggle */}
⋮----
{/* Existing site selector */}
⋮----
{/* Site Name (only for new site) */}
⋮----
{/* Show generated UUID (for new site) */}
⋮----
{/* Monitor Type Selector */}
⋮----
{/* Dynamic Monitor Fields */}
⋮----
{/* Error Message */}
</file>

<file path="src/components/AddSiteForm/Submit.tsx">
/**
 * Form submission handling utilities for the AddSiteForm component.
 *
 * @remarks
 * Provides validation and submission logic for creating new sites or adding
 * monitors to existing sites. Supports HTTP and port monitor types with
 * comprehensive validation and error handling.
 *
 * @packageDocumentation
 */
import type { Logger } from "../../services/logger";
import type { Monitor, MonitorType } from "../../types";
import type { AddSiteFormState, AddSiteFormActions } from "../SiteDetails/useAddSiteForm";
import { DEFAULT_REQUEST_TIMEOUT, RETRY_CONSTRAINTS } from "../../constants";
import { validateMonitorData } from "../../utils/monitorValidation";
import { getMonitorTypeConfig } from "../../utils/monitorTypeHelper";
/**
 * Store actions interface for form submission operations.
 *
 * @remarks
 * Defines the required store methods needed for form submission. This interface
 * decouples the submission logic from specific store implementations, making
 * the code more testable and flexible.
 */
interface StoreActions {
    /** Add a monitor to an existing site */
    addMonitorToSite: (siteId: string, monitor: Monitor) => Promise<void>;
    /** Clear any existing error state */
    clearError: () => void;
    /** Create a new site with monitors */
    createSite: (siteData: { identifier: string; monitors: Monitor[]; name?: string }) => Promise<void>;
}
⋮----
/** Add a monitor to an existing site */
⋮----
/** Clear any existing error state */
⋮----
/** Create a new site with monitors */
⋮----
/**
 * Properties interface for form submission handling.
 *
 * @remarks
 * Combines form state, actions, and store methods for the submission handler.
 */
type FormSubmitProperties = AddSiteFormState &
    Pick<AddSiteFormActions, "setFormError"> &
    StoreActions & {
        /** UUID generator function for creating unique identifiers */
        generateUuid: () => string;
        /** Logger instance for debugging and error tracking */
        logger: Logger;
        /** Optional callback executed after successful submission */
        onSuccess?: () => void;
    };
⋮----
/** UUID generator function for creating unique identifiers */
⋮----
/** Logger instance for debugging and error tracking */
⋮----
/** Optional callback executed after successful submission */
⋮----
/**
 * Validates the add mode selection and site information.
 *
 * @param addMode - Mode of adding ("new" or "existing")
 * @param name - Site name for new sites
 * @param selectedExistingSite - Selected existing site identifier
 * @returns Array of validation error messages
 */
function validateAddMode(addMode: string, name: string, selectedExistingSite: string): string[]
/**
 * Builds monitor data object dynamically based on monitor type configuration.
 *
 * @param monitorType - Type of monitor
 * @param formData - Form data containing field values
 * @returns Monitor data object with type-specific fields
 */
async function buildMonitorData(
    monitorType: MonitorType,
    formData: { url: string; host: string; port: string }
): Promise<Record<string, unknown>>
⋮----
// Dynamically map form fields to monitor data based on field definitions
⋮----
// Convert value based on field type
⋮----
// eslint-disable-next-line security/detect-object-injection -- fieldName comes from trusted monitor config
⋮----
// eslint-disable-next-line security/detect-object-injection -- fieldName comes from trusted monitor config
⋮----
// Fallback to hardcoded mapping if config is unavailable
⋮----
// Fallback to hardcoded mapping
⋮----
/**
 * Validates monitor type-specific configuration using backend registry.
 *
 * @param monitorType - Type of monitor
 * @param url - URL for HTTP monitors
 * @param host - Host for port monitors
 * @param port - Port for port monitors
 * @returns Promise resolving to array of validation error messages
 */
async function validateMonitorType(monitorType: string, url: string, host: string, port: string): Promise<string[]>
⋮----
// Build monitor data object dynamically
⋮----
// Use backend registry validation
⋮----
/**
 * Validates check interval configuration.
 *
 * @param checkInterval - Check interval in milliseconds
 * @returns Array of validation error messages
 */
function validateCheckInterval(checkInterval: number): string[]
/**
 * Creates a monitor object based on the form data.
 */
async function createMonitor(properties: FormSubmitProperties): Promise<Monitor>
⋮----
monitoring: true, // Default to monitoring enabled
responseTime: -1, // Sentinel value for never checked
retryAttempts: RETRY_CONSTRAINTS.DEFAULT, // Explicit default retry attempts
⋮----
timeout: DEFAULT_REQUEST_TIMEOUT, // Explicit default timeout
⋮----
// Add type-specific fields dynamically using monitor config
⋮----
// Copy the type-specific fields to the monitor object
⋮----
// Skip the type field as it's already set
// eslint-disable-next-line security/detect-object-injection -- key comes from trusted monitor config
⋮----
/**
 * Submits a new site with monitor.
 */
async function submitNewSite(properties: FormSubmitProperties, monitor: Monitor): Promise<void>
⋮----
monitoring: true, // Default to monitoring enabled
name: trimmedName || "Unnamed Site", // Provide default name
⋮----
/**
 * Adds monitor to existing site.
 */
async function addToExistingSite(properties: FormSubmitProperties, monitor: Monitor): Promise<void>
/**
 * Performs the actual submission based on add mode.
 */
async function performSubmission(properties: FormSubmitProperties, monitor: Monitor): Promise<void>
/**
 * Handles form submission for adding sites or monitors.
 *
 * Performs comprehensive validation based on add mode and monitor type:
 * - For new sites: validates site name and monitor configuration
 * - For existing sites: validates site selection and monitor configuration
 * - For HTTP monitors: validates URL format and protocol
 * - For port monitors: validates host and port number
 *
 * @param e - Form submission event
 * @param props - Form state, actions, and dependencies
 * @returns Promise that resolves when submission is complete
 *
 * @example
 * ```tsx
 * const handleFormSubmit = (e: React.FormEvent) => {
 *   handleSubmit(e, {
 *     ...formState,
 *     ...formActions,
 *     ...storeActions,
 *     generateUuid,
 *     logger,
 *     onSuccess: () => setIsVisible(false)
 *   });
 * };
 * ```
 */
export async function handleSubmit(event: React.FormEvent, properties: FormSubmitProperties)
⋮----
// Log submission start
⋮----
// Collect all validation errors
⋮----
// Handle validation failures
⋮----
host: host.slice(0, 50), // Truncate for privacy
⋮----
name: name.slice(0, 50), // Truncate for privacy
⋮----
url: url.slice(0, 50), // Truncate for privacy
⋮----
setFormError(validationErrors[0]); // Show first error
</file>

<file path="src/components/SiteDetails/SiteDetails.tsx">
/**
 * Site details view component with comprehensive tabbed interface.
 *
 * @remarks
 * This component provides a detailed view of a single site's monitoring data,
 * statistics, and configuration options. It uses a composition pattern with
 * specialized child components for maintainability and clear separation of concerns.
 *
 * The component integrates multiple advanced features:
 * - Real-time status monitoring and visualization
 * - Historical data charts with Chart.js integration
 * - Analytics and performance metrics
 * - Configuration management for monitoring settings
 * - Responsive design with theme support
 *
 * Uses custom hooks for state management and Chart.js for data visualization
 * with zoom, pan, and time-based charting capabilities.
 *
 * @param site - Site object containing monitoring data and configuration
 *
 * @example
 * ```tsx
 * <SiteDetails
 *   site={{
 *     identifier: "site-123",
 *     name: "My Website",
 *     monitors: [],
 *     monitoring: true
 *   }}
 * />
 * ```
 *
 * @public
 */
import {
    Chart as ChartJS,
    CategoryScale,
    LinearScale,
    PointElement,
    LineElement,
    BarElement,
    Title,
    Tooltip,
    Legend,
    TimeScale,
    Filler,
    DoughnutController,
    ArcElement,
} from "chart.js";
import zoomPlugin from "chartjs-plugin-zoom";
import { useMemo, useState } from "react";
⋮----
import { useSiteDetails } from "../../hooks/site/useSiteDetails";
import { ChartConfigService } from "../../services/chartConfig";
import { ThemedBox, useTheme } from "../../theme";
import { Site } from "../../types";
import { formatStatusWithIcon } from "../../utils/status";
import { formatResponseTime, formatFullTimestamp, formatDuration } from "../../utils/time";
⋮----
import { SiteDetailsHeader } from "./SiteDetailsHeader";
import { SiteDetailsNavigation } from "./SiteDetailsNavigation";
import { AnalyticsTab, HistoryTab, OverviewTab, SettingsTab, SiteOverviewTab } from "./tabs";
// Register Chart.js components
⋮----
/** Props for the SiteDetails component */
interface SiteDetailsProperties {
    /** The site object to display details for */
    readonly site: Site;
    /** Callback function to close the site details view */
    readonly onClose: () => void;
}
⋮----
/** The site object to display details for */
⋮----
/** Callback function to close the site details view */
⋮----
/**
 * Gets a descriptive label for availability percentage.
 *
 * @param percentage - Availability percentage (0-100)
 * @returns Description string ("Excellent", "Good", or "Poor")
 */
function getAvailabilityDescription(percentage: number): string
/**
 * Site details component with tabbed interface for comprehensive site monitoring.
 * Provides overview, history, analytics, and settings views for a monitored site.
 *
 * Uses composition pattern with specialized tab components and custom hooks for
 * state management and data fetching.
 *
 * @param props - Component props
 * @returns JSX element containing the site details interface
 *
 * @example
 * ```tsx
 * <SiteDetails
 *   site={selectedSite}
 *   onClose={() => setSelectedSite(null)}
 * />
 * ```
 */
⋮----
// Use our custom hook to get all the data and functionality we need
⋮----
// UI state
⋮----
// Analytics
⋮----
// Site data
⋮----
// Handlers
⋮----
// Name state
⋮----
// Interval state
⋮----
// Store actions
⋮----
// Create chart config service instance
⋮----
// Chart configurations using the service
⋮----
// Chart data using analytics
⋮----
/**
     * Handle keyboard events for modal accessibility
     * @param event - Keyboard event
     */
const handleKeyDown = (event: React.KeyboardEvent) =>
// Don't render if site doesn't exist
⋮----
// eslint-disable-next-line unicorn/no-null -- React components can return null
⋮----
{/* Tab Content */}
</file>

<file path="src/components/SiteDetails/tabs/HistoryTab.tsx">
/**
 * History tab component for displaying monitor check history.
 * Provide    // Dropdown options: 25, 50, 100, All (clamped to backendLimit and available history)
    const maxShow = Math.min(backendLimit, historyLength); pagination, and detailed history records view.
 */
import { useState, useEffect, useRef } from "react";
import { FiFilter } from "react-icons/fi";
import { MdHistory } from "react-icons/md";
import { logger } from "../../../services";
import { useSettingsStore } from "../../../stores";
import { ThemedText, ThemedButton, StatusIndicator, ThemedCard, ThemedSelect, useTheme } from "../../../theme";
import { StatusHistory, Monitor } from "../../../types";
import { DetailLabel } from "../../dynamic-monitor-ui";
/**
 * Get the formatted label for filter buttons
 * @param filter - The filter type
 * @returns The formatted label for the filter button
 */
function getFilterButtonLabel(filter: "all" | "up" | "down"): string
/**
 * Props for the HistoryTab component.
 */
interface HistoryTabProperties {
    /** Function to format timestamps for display */
    readonly formatFullTimestamp: (timestamp: number) => string;
    /** Function to format response times for display */
    readonly formatResponseTime: (time: number) => string;
    /** Function to format status with appropriate icons */
    readonly formatStatusWithIcon: (status: string) => string;
    /** Currently selected monitor to display history for */
    readonly selectedMonitor: Monitor;
}
⋮----
/** Function to format timestamps for display */
⋮----
/** Function to format response times for display */
⋮----
/** Function to format status with appropriate icons */
⋮----
/** Currently selected monitor to display history for */
⋮----
/**
 * History tab component displaying paginated monitor check history.
 *
 * Features:
 * - Filterable history by status (all, up, down)
 * - Configurable display limits with pagination
 * - Detailed history records with timestamps and response times
 * - Export functionality for history data
 * - User action logging for analytics
 *
 * @param props - Component props containing formatting functions and monitor data
 * @returns JSX element displaying history interface
 */
⋮----
// Track the last monitor ID we logged for to prevent duplicate logging
⋮----
// Icon colors configuration
const getIconColors = () => (
⋮----
// Dropdown options: 25, 50, 100, All (clamped to backendLimit and available history)
⋮----
// Always include 'All' if there are fewer than backendLimit
⋮----
// Default to 50, but never more than backendLimit or available history
⋮----
// Log when history tab is viewed - only when monitor actually changes
⋮----
// eslint-disable-next-line react-hooks/exhaustive-deps -- intentionally exclude selectedMonitor.history to prevent re-logging on history updates
⋮----
// Helper to render details with label using dynamic formatting
function renderDetails(record: StatusHistory)
⋮----
// eslint-disable-next-line unicorn/no-null -- React components can return null
⋮----
{/* History Controls */}
⋮----
{/* History List */}
⋮----
</file>

<file path="src/stores/sites/useSiteOperations.ts">
/**
 * Site operations module.
 * Handles CRUD operations for sites and monitor management.
 *
 * Note: Empty clearError and setLoading functions are intentional in withErrorHandling calls
 * as error handling is managed centrally by the store infrastructure.
 */
import type { Monitor, MonitorType, Site } from "../../types";
import { ERROR_MESSAGES } from "../types";
import { logStoreAction, withErrorHandling } from "../utils";
import { MonitoringService, SiteService } from "./services";
import { normalizeMonitor, updateMonitorInSite, handleSQLiteBackupDownload } from "./utils";
export interface SiteOperationsActions {
    /** Initialize sites data from backend */
    initializeSites: () => Promise<{ success: boolean; sitesLoaded: number; message: string }>;
    /** Create a new site */
    createSite: (siteData: {
        identifier: string;
        name?: string;
        monitors?: Monitor[];
        monitoring?: boolean;
    }) => Promise<void>;
    /** Delete a site */
    deleteSite: (identifier: string) => Promise<void>;
    /** Modify an existing site */
    modifySite: (identifier: string, updates: Partial<Site>) => Promise<void>;
    /** Add a monitor to an existing site */
    addMonitorToSite: (siteId: string, monitor: Monitor) => Promise<void>;
    /** Remove a monitor from a site */
    removeMonitorFromSite: (siteId: string, monitorId: string) => Promise<void>;
    /** Update site check interval */
    updateSiteCheckInterval: (siteId: string, monitorId: string, interval: number) => Promise<void>;
    /** Update monitor retry attempts */
    updateMonitorRetryAttempts: (siteId: string, monitorId: string, retryAttempts: number) => Promise<void>;
    /** Update monitor timeout */
    updateMonitorTimeout: (siteId: string, monitorId: string, timeout: number) => Promise<void>;
    /** Download SQLite backup */
    downloadSQLiteBackup: () => Promise<void>;
}
⋮----
/** Initialize sites data from backend */
⋮----
/** Create a new site */
⋮----
/** Delete a site */
⋮----
/** Modify an existing site */
⋮----
/** Add a monitor to an existing site */
⋮----
/** Remove a monitor from a site */
⋮----
/** Update site check interval */
⋮----
/** Update monitor retry attempts */
⋮----
/** Update monitor timeout */
⋮----
/** Download SQLite backup */
⋮----
export interface SiteOperationsDependencies {
    getSites: () => Site[];
    addSite: (site: Site) => void;
    removeSite: (identifier: string) => void;
    setSites: (sites: Site[]) => void;
    syncSitesFromBackend: () => Promise<void>;
}
export const createSiteOperationsActions = (deps: SiteOperationsDependencies): SiteOperationsActions => (
⋮----
// Get the current site
⋮----
// Allow multiple monitors of the same type
⋮----
// Default to HTTP monitor if none provided
⋮----
// Construct a complete Site object
⋮----
monitoring: siteData.monitoring ?? true, // Default to monitoring enabled
name: siteData.name ?? "Unnamed Site", // Provide default name
⋮----
// Stop monitoring for all monitors of this site before deleting
// Filter out null/undefined values to handle corrupted data
⋮----
// Log but do not block deletion if stopping fails
⋮----
// Get the current site
⋮----
// Check if this is the only monitor - prevent removal if so
⋮----
// Stop monitoring for this specific monitor first
⋮----
// Log but do not block removal if stopping fails
⋮----
// Remove the monitor via backend
⋮----
// Refresh site data from backend
⋮----
// Only update if retryAttempts is defined
⋮----
// Only update if timeout is defined
</file>

<file path="src/stores/sites/useSitesStore.ts">
/**
 * Main sites store for managing site data and operations using modular architecture.
 *
 * @remarks
 * This store uses a modular composition pattern to separate concerns and improve
 * testability. Instead of a monolithic store, it composes smaller, focused modules:
 *
 * - `useSitesState`: Core state management and data manipulation
 * - `useSiteOperations`: CRUD operations for sites and monitors
 * - `useSiteMonitoring`: Monitoring lifecycle and status management
 * - `useSiteSync`: Backend synchronization and data consistency
 *
 * Each module is independently testable and has clear responsibilities, making
 * the codebase more maintainable and easier to understand.
 *
 * @example
 * ```typescript
 * import { useSitesStore } from './stores';
 *
 * function MyComponent() {
 *   const { sites, addSite, startMonitoring } = useSitesStore();
 *
 *   const handleAddSite = async () => {
 *     const newSite = await addSite({ name: 'Example Site', monitors: [] });
 *     await startMonitoring();
 *   };
 *
 *   return <div>{sites.length} sites</div>;
 * }
 * ```
 *
 * @packageDocumentation
 */
import { create } from "zustand";
import type { SitesStore } from "./types";
import { createSiteMonitoringActions } from "./useSiteMonitoring";
import { createSiteOperationsActions } from "./useSiteOperations";
import { createSitesStateActions, initialSitesState } from "./useSitesState";
import { createSiteSyncActions } from "./useSiteSync";
/**
 * Main sites store combining all site-related functionality.
 *
 * @remarks
 * Creates a Zustand store that composes multiple action modules to provide
 * a complete interface for site management. The store uses dependency injection
 * to share common functions between modules while maintaining clear boundaries.
 *
 * @public
 */
⋮----
// Create state actions
⋮----
// Shared getSites function - eliminates duplication and improves testability
const getSites = ()
// Create sync actions (needed by other modules)
⋮----
// Create monitoring actions
⋮----
// Create operations actions
⋮----
// Initial state
⋮----
// State actions
⋮----
// Operations actions
⋮----
// Monitoring actions
⋮----
// Sync actions
</file>

<file path="src/types.ts">
/**
 * Type definitions for the Uptime Watcher application frontend.
 *
 * @remarks
 * Data structures for sites, monitors, status updates, and Electron API communication.
 *
 * @packageDocumentation
 */
/**
 * Application update status types for the auto-updater.
 */
export type UpdateStatus = "idle" | "checking" | "available" | "downloading" | "downloaded" | "error";
// Re-export MonitorType from electron types to avoid duplication
⋮----
import type { MonitorType } from "../electron/types";
/**
 * Monitor interface representing a single monitoring endpoint.
 *
 * @remarks
 * Represents a single monitoring endpoint that can check either HTTP/HTTPS URLs
 * or TCP port connectivity. Each monitor maintains its current status, performance
 * metrics, and historical data.
 *
 * For HTTP monitors, the `url` property is required and `host`/`port` are undefined.
 * For port monitors, the `host` and `port` properties are required and `url` is undefined.
 *
 * @example
 * ```typescript
 * // HTTP monitor example
 * const httpMonitor: Monitor = {
 *   id: "mon_123",
 *   type: "http",
 *   status: "up",
 *   url: "https://example.com",
 *   responseTime: 250,
 *   monitoring: true,
 *   checkInterval: 300000,
 *   timeout: 10000,
 *   retryAttempts: 3,
 *   history: []
 * };
 *
 * // Port monitor example
 * const portMonitor: Monitor = {
 *   id: "mon_456",
 *   type: "port",
 *   status: "down",
 *   host: "example.com",
 *   port: 80,
 *   responseTime: -1,
 *   monitoring: true,
 *   checkInterval: 300000,
 *   timeout: 10000,
 *   retryAttempts: 3,
 *   history: []
 * };
 * ```
 */
export interface Monitor {
    /** Unique identifier for this monitor (UUID or database-generated ID) */
    id: string;
    /** Type of monitoring to perform */
    type: MonitorType;
    /** Current operational status of the monitor */
    status: "up" | "down" | "pending" | "paused";
    /** URL endpoint for HTTP monitors (required for type "http", undefined for others) */
    url?: string;
    /** Hostname or IP address for port monitors (required for type "port", undefined for others) */
    host?: string;
    /** Port number for port monitors (required for type "port", undefined for others) */
    port?: number;
    /** Last recorded response time in milliseconds (-1 if check failed or not yet checked) */
    responseTime: number;
    /** Timestamp of the most recent check attempt (undefined if never checked) */
    lastChecked?: Date;
    /** Array of historical check results ordered chronologically */
    history: StatusHistory[];
    /** Whether this monitor is actively being checked */
    monitoring: boolean;
    /** Check interval in milliseconds for this specific monitor */
    checkInterval: number;
    /** Request timeout in milliseconds for this monitor */
    timeout: number;
    /** Number of retry attempts before marking as down for this monitor */
    retryAttempts: number;
}
⋮----
/** Unique identifier for this monitor (UUID or database-generated ID) */
⋮----
/** Type of monitoring to perform */
⋮----
/** Current operational status of the monitor */
⋮----
/** URL endpoint for HTTP monitors (required for type "http", undefined for others) */
⋮----
/** Hostname or IP address for port monitors (required for type "port", undefined for others) */
⋮----
/** Port number for port monitors (required for type "port", undefined for others) */
⋮----
/** Last recorded response time in milliseconds (-1 if check failed or not yet checked) */
⋮----
/** Timestamp of the most recent check attempt (undefined if never checked) */
⋮----
/** Array of historical check results ordered chronologically */
⋮----
/** Whether this monitor is actively being checked */
⋮----
/** Check interval in milliseconds for this specific monitor */
⋮----
/** Request timeout in milliseconds for this monitor */
⋮----
/** Number of retry attempts before marking as down for this monitor */
⋮----
/**
 * Site interface representing a monitored service with one or more monitors.
 *
 * @remarks
 * A site represents a logical grouping of monitors for a single service or website.
 * Each site can have multiple monitors checking different aspects (HTTP endpoints,
 * port connectivity, etc.) and maintains its own monitoring state.
 *
 * @example
 * ```typescript
 * const exampleSite: Site = {
 *   identifier: "site_abc123",
 *   name: "My Website",
 *   monitoring: true,
 *   monitors: [
 *     {
 *       id: "mon_1",
 *       type: "http",
 *       url: "https://example.com",
 *       status: "up",
 *       // ... other monitor properties
 *     },
 *     {
 *       id: "mon_2",
 *       type: "port",
 *       host: "example.com",
 *       port: 443,
 *       status: "up",
 *       // ... other monitor properties
 *     }
 *   ]
 * };
 * ```
 */
export interface Site {
    /** Unique identifier for the site (UUID, used as the primary key) */
    identifier: string;
    /** Human-readable display name for the site */
    name: string;
    /** Array of monitors associated with this site */
    monitors: Monitor[];
    /** Whether monitoring is active for this site (affects all monitors) */
    monitoring: boolean;
}
⋮----
/** Unique identifier for the site (UUID, used as the primary key) */
⋮----
/** Human-readable display name for the site */
⋮----
/** Array of monitors associated with this site */
⋮----
/** Whether monitoring is active for this site (affects all monitors) */
⋮----
/**
 * Historical status record for tracking uptime/downtime over time.
 *
 * @remarks
 * Records the result of a single monitor check for historical analysis.
 * Used to build uptime charts, calculate availability percentages, and
 * track performance trends over time.
 *
 * Note: Does not include "pending" status as historical records only
 * capture actual check outcomes, not transitional states.
 */
export interface StatusHistory {
    /** Unix timestamp (in milliseconds) when this status was recorded */
    timestamp: number;
    /** Status result at this point in time */
    status: "up" | "down" | "paused";
    /** Response time in milliseconds (-1 if check failed) */
    responseTime: number;
    /** Optional diagnostic details about the check (error messages, HTTP status codes, etc.) */
    details?: string;
}
⋮----
/** Unix timestamp (in milliseconds) when this status was recorded */
⋮----
/** Status result at this point in time */
⋮----
/** Response time in milliseconds (-1 if check failed) */
⋮----
/** Optional diagnostic details about the check (error messages, HTTP status codes, etc.) */
⋮----
/**
 * Status update payload sent from backend to frontend via IPC.
 *
 * @remarks
 * Contains the updated site data and optional previous status for comparison.
 * Used to notify the frontend when monitor status changes occur, enabling
 * real-time UI updates and status change notifications.
 */
export interface StatusUpdate {
    /** Updated site data with current monitor statuses */
    site: Site;
    /** Previous status for change detection and transition logic */
    previousStatus?: "up" | "down" | "pending" | "paused";
}
⋮----
/** Updated site data with current monitor statuses */
⋮----
/** Previous status for change detection and transition logic */
⋮----
/**
 * Electron API interface exposed to the renderer process.
 *
 * @remarks
 * Provides secure communication between the React frontend and Electron main process
 * through the contextBridge. All backend operations are accessed through this API
 * which is available as `window.electronAPI` in the renderer process.
 *
 * The API is organized by functional domains for better maintainability and type safety:
 * - `data`: Import/export and backup operations
 * - `events`: Event listening and management
 * - `monitoring`: Monitor control operations
 * - `settings`: Application configuration
 * - `sites`: Site and monitor CRUD operations
 * - `system`: System-level operations
 */
⋮----
interface Window {
        electronAPI: {
            /**
             * Data management operations for import, export, and backup.
             */
            data: {
                /** Export all application data as JSON string */
                exportData: () => Promise<string>;
                /** Import application data from JSON string */
                importData: (data: string) => Promise<boolean>;
                /** Download SQLite database backup as binary data */
                downloadSQLiteBackup: () => Promise<{ buffer: ArrayBuffer; fileName: string }>;
            };
            /**
             * Event management for real-time updates and communication.
             */
            events: {
                /** Register callback for monitor status updates */
                onStatusUpdate: (callback: (update: StatusUpdate) => void) => void;
                /** Register callback for monitoring started events */
                onMonitoringStarted: (callback: (data: { siteId: string; monitorId: string }) => void) => void;
                /** Register callback for monitoring stopped events */
                onMonitoringStopped: (callback: (data: { siteId: string; monitorId: string }) => void) => void;
                /** Register callback for test events (development/debugging) */
                onTestEvent: (callback: (data: unknown) => void) => void;
                /** Remove all listeners for a specific event */
                removeAllListeners: (event: string) => void;
            };
            /**
             * Monitoring control operations for starting and stopping checks.
             */
            monitoring: {
                /** Start monitoring for all configured sites */
                startMonitoring: () => Promise<void>;
                /** Stop monitoring for all sites */
                stopMonitoring: () => Promise<void>;
                /** Start monitoring for a specific site or monitor */
                startMonitoringForSite: (siteId: string, monitorId?: string) => Promise<void>;
                /** Stop monitoring for a specific site or monitor */
                stopMonitoringForSite: (siteId: string, monitorId?: string) => Promise<void>;
            };
            /**
             * Application settings and configuration management.
             */
            settings: {
                /** Get current history retention limit */
                getHistoryLimit: () => Promise<number>;
                /** Update history retention limit */
                updateHistoryLimit: (limit: number) => Promise<void>;
            };
            /**
             * Site and monitor CRUD operations.
             */
            sites: {
                /** Retrieve all configured sites with their monitors */
                getSites: () => Promise<Site[]>;
                /** Add a new site with its monitors */
                addSite: (site: Site) => Promise<Site>;
                /** Remove a site and all its monitors */
                removeSite: (id: string) => Promise<void>;
                /** Update site configuration */
                updateSite: (id: string, updates: Partial<Site>) => Promise<void>;
                /** Perform immediate manual check for a specific monitor */
                checkSiteNow: (siteId: string, monitorId: string) => Promise<void>;
                /** Remove a specific monitor from a site */
                removeMonitor: (siteIdentifier: string, monitorId: string) => Promise<void>;
            };
            /**
             * Monitor type registry and configuration operations.
             */
            monitorTypes: {
                /** Get all available monitor type configurations */
                getMonitorTypes: () => Promise<
                    {
                        type: string;
                        displayName: string;
                        description: string;
                        version: string;
                        fields: {
                            name: string;
                            label: string;
                            type: "text" | "number" | "url";
                            required: boolean;
                            placeholder?: string;
                            helpText?: string;
                            min?: number;
                            max?: number;
                        }[];
                    }[]
                >;
                /** Validate monitor data using backend registry */
                validateMonitorData: (
                    type: string,
                    data: unknown
                ) => Promise<{
                    success: boolean;
                    errors: string[];
                }>;
            };
            /**
             * System-level operations and utilities.
             */
            system: {
                /** Quit application and install pending update */
                quitAndInstall: () => void;
                /** Open URL in external browser */
                openExternal: (url: string) => void;
            };
        };
    }
⋮----
/**
             * Data management operations for import, export, and backup.
             */
⋮----
/** Export all application data as JSON string */
⋮----
/** Import application data from JSON string */
⋮----
/** Download SQLite database backup as binary data */
⋮----
/**
             * Event management for real-time updates and communication.
             */
⋮----
/** Register callback for monitor status updates */
⋮----
/** Register callback for monitoring started events */
⋮----
/** Register callback for monitoring stopped events */
⋮----
/** Register callback for test events (development/debugging) */
⋮----
/** Remove all listeners for a specific event */
⋮----
/**
             * Monitoring control operations for starting and stopping checks.
             */
⋮----
/** Start monitoring for all configured sites */
⋮----
/** Stop monitoring for all sites */
⋮----
/** Start monitoring for a specific site or monitor */
⋮----
/** Stop monitoring for a specific site or monitor */
⋮----
/**
             * Application settings and configuration management.
             */
⋮----
/** Get current history retention limit */
⋮----
/** Update history retention limit */
⋮----
/**
             * Site and monitor CRUD operations.
             */
⋮----
/** Retrieve all configured sites with their monitors */
⋮----
/** Add a new site with its monitors */
⋮----
/** Remove a site and all its monitors */
⋮----
/** Update site configuration */
⋮----
/** Perform immediate manual check for a specific monitor */
⋮----
/** Remove a specific monitor from a site */
⋮----
/**
             * Monitor type registry and configuration operations.
             */
⋮----
/** Get all available monitor type configurations */
⋮----
/** Validate monitor data using backend registry */
⋮----
/**
             * System-level operations and utilities.
             */
⋮----
/** Quit application and install pending update */
⋮----
/** Open URL in external browser */
</file>

<file path="electron/services/application/ApplicationService.ts">
import { app } from "electron";
import { StatusUpdate, Site } from "../../types";
import { logger } from "../../utils/index";
import { ServiceContainer } from "../ServiceContainer";
/**
 * Main application service that orchestrates all other services.
 * Handles application lifecycle and service coordination.
 *
 * @remarks
 * Uses dependency injection through ServiceContainer to manage all services
 * and their dependencies. Provides proper initialization order and cleanup.
 */
export class ApplicationService {
⋮----
constructor()
⋮----
// Get service container instance
⋮----
/**
     * Setup application-level event handlers.
     */
private setupApplication(): void
/**
     * Handle app ready event.
     */
private async onAppReady(): Promise<void>
⋮----
// Initialize all services through the container
⋮----
// Create main window
⋮----
// Setup event handlers
⋮----
// Setup auto-updater
⋮----
/**
     * Setup auto-updater with callbacks.
     */
private setupAutoUpdater(): void
/**
     * Setup event handlers for uptime monitoring events.
     */
private setupUptimeEventHandlers(): void
⋮----
// Forward monitoring start/stop events to renderer
⋮----
/**
     * Cleanup resources before application shutdown.
     */
public async cleanup(): Promise<void>
⋮----
// Cleanup IPC handlers
⋮----
// Stop monitoring
⋮----
// Close windows
</file>

<file path="electron/services/ipc/IpcService.ts">
import { ipcMain, BrowserWindow } from "electron";
import { isDev } from "../../electronUtils";
import { UptimeOrchestrator } from "../../index";
import { logger } from "../../utils/index";
import { AutoUpdaterService } from "../updater/index";
import { Site } from "../../types";
import { getAllMonitorTypeConfigs, validateMonitorDataAdvanced } from "../monitoring/MonitorTypeRegistry";
/**
 * Inter-Process Communication service for Electron main-renderer communication.
 *
 * @remarks
 * Manages all IPC handlers between the main process and renderer processes,
 * organized by functional domains (sites, monitoring, data, system).
 * Provides a secure interface for the frontend to interact with backend services.
 */
export class IpcService {
⋮----
/**
     * Create a new IPC service instance.
     *
     * @param uptimeOrchestrator - Core orchestrator for monitoring operations
     * @param autoUpdaterService - Service for handling application updates
     */
constructor(uptimeOrchestrator: UptimeOrchestrator, autoUpdaterService: AutoUpdaterService)
/**
     * Initialize all IPC handlers organized by functional domain.
     *
     * @remarks
     * Sets up handlers for:
     * - Site management (CRUD operations)
     * - Monitoring control (start/stop operations)
     * - Data management (import/export/backup)
     * - System operations (updates, quit)
     */
public setupHandlers(): void
/**
     * Setup IPC handlers for site management operations.
     *
     * @remarks
     * Handles site CRUD operations:
     * - `add-site`: Create new site with monitors
     * - `remove-site`: Delete site and all associated data
     * - `get-sites`: Retrieve all configured sites
     * - `update-site`: Modify existing site configuration
     * - `remove-monitor`: Delete specific monitor from site
     */
private setupSiteHandlers(): void
/**
     * Setup IPC handlers for monitoring control operations.
     *
     * @remarks
     * Handles monitoring lifecycle operations:
     * - `start-monitoring`: Begin monitoring all configured sites
     * - `stop-monitoring`: Stop all monitoring activities
     * - `start-monitoring-for-site`: Start monitoring specific site/monitor
     * - `stop-monitoring-for-site`: Stop monitoring specific site/monitor
     * - `check-site-now`: Perform immediate manual check
     */
private setupMonitoringHandlers(): void
⋮----
// Runtime validation for type safety
⋮----
/**
     * Setup IPC handlers for data management operations.
     *
     * @remarks
     * Handles data persistence and backup operations:
     * - `export-data`: Export all configuration and history as JSON
     * - `import-data`: Import configuration from JSON data
     * - `update-history-limit`: Configure history retention policy
     * - `get-history-limit`: Retrieve current history retention setting
     * - `download-sqlite-backup`: Create and download database backup
     */
private setupDataHandlers(): void
/**
     * Setup IPC handlers for system-level operations.
     *
     * @remarks
     * Handles application lifecycle and system operations:
     * - `quit-and-install`: Quit application and install pending update
     */
private setupSystemHandlers(): void
/**
     * Setup IPC handlers for state synchronization operations.
     *
     * @remarks
     * Handles:
     * - `request-full-sync`: Manual full state synchronization request
     */
private setupStateSyncHandlers(): void
⋮----
// Get all sites and send to frontend
⋮----
// Emit state sync event to all renderer processes
⋮----
/**
     * Setup IPC handlers for monitor type registry operations.
     *
     * @remarks
     * Handles monitor type metadata operations:
     * - `get-monitor-types`: Get all available monitor type configurations
     */
private setupMonitorTypeHandlers(): void
⋮----
// Get all monitor type configs and strip out non-serializable data (Zod schemas and functions)
⋮----
fields: config.fields, // This is serializable
// Serialize uiConfig by excluding functions and keeping only data
⋮----
// Exclude functions, we'll recreate them on the frontend based on type
⋮----
// Exclude validationSchema as it contains Zod objects that can't be serialized
// Exclude serviceFactory as it contains function references
⋮----
// Use the advanced validation function with better validation
⋮----
/**
     * Clean up all IPC listeners.
     *
     * @remarks
     * Removes all registered IPC handlers to prevent memory leaks.
     * Should be called during application shutdown.
     */
public cleanup(): void
</file>

<file path="electron/services/notifications/NotificationService.ts">
import { Notification } from "electron";
import { Site } from "../../types";
import { logger } from "../../utils/index";
/**
 * Configuration options for the notification service.
 *
 * @remarks
 * Controls which types of monitor status change notifications are displayed
 * to the user. Both settings can be independently enabled or disabled.
 *
 * @public
 */
export interface NotificationConfig {
    /** Whether to show notifications when monitors go down */
    showDownAlerts: boolean;
    /** Whether to show notifications when monitors come back up */
    showUpAlerts: boolean;
}
⋮----
/** Whether to show notifications when monitors go down */
⋮----
/** Whether to show notifications when monitors come back up */
⋮----
/**
 * Service responsible for handling system notifications for monitor status changes.
 *
 * @remarks
 * Manages desktop notifications for monitor status changes using Electron's
 * Notification API. Provides configurable settings for different notification
 * types and handles platform compatibility checks.
 *
 * Features:
 * - **Configurable Alerts**: Control which types of status changes trigger notifications
 * - **Platform Detection**: Automatically detects if notifications are supported
 * - **Monitor Context**: Includes site name and monitor type in notification content
 * - **Urgency Levels**: Sets appropriate urgency for different notification types
 * - **Comprehensive Logging**: Logs all notification activities for debugging
 *
 * @example
 * ```typescript
 * const notificationService = new NotificationService({
 *   showDownAlerts: true,
 *   showUpAlerts: false
 * });
 *
 * // Show notification when a monitor goes down
 * notificationService.notifyMonitorDown(site, monitorId);
 * ```
 */
export class NotificationService {
⋮----
/**
     * Create a new notification service instance.
     *
     * @param config - Optional configuration for notification behavior
     *
     * @remarks
     * If no configuration is provided, both down and up alerts are enabled by default.
     * The configuration can be updated later using {@link NotificationService.updateConfig}.
     */
constructor(config?: NotificationConfig)
/**
     * Show a notification when a monitor goes down.
     *
     * @param site - The site containing the monitor that went down
     * @param monitorId - ID of the specific monitor that went down
     *
     * @remarks
     * Displays a critical urgency notification with site name and monitor type.
     * Automatically skipped if down alerts are disabled in configuration or
     * if notifications are not supported on the current platform.
     *
     * The notification includes:
     * - Site name for easy identification
     * - Monitor type (HTTP, port, etc.)
     * - Critical urgency level to ensure visibility
     */
public notifyMonitorDown(site: Site, monitorId: string): void
/**
     * Show a notification when a monitor comes back up.
     *
     * @param site - The site containing the monitor that came back up
     * @param monitorId - ID of the specific monitor that was restored
     *
     * @remarks
     * Displays a normal urgency notification indicating service restoration.
     * Automatically skipped if up alerts are disabled in configuration or
     * if notifications are not supported on the current platform.
     *
     * The notification includes:
     * - Site name for easy identification
     * - Monitor type (HTTP, port, etc.)
     * - Normal urgency level (less intrusive than down alerts)
     */
public notifyMonitorUp(site: Site, monitorId: string): void
/**
     * Update the notification configuration.
     *
     * @param config - Partial configuration object with settings to update
     *
     * @remarks
     * Allows runtime modification of notification behavior without creating
     * a new service instance. Only specified properties are updated; others
     * retain their current values.
     *
     * Changes take effect immediately for subsequent notifications.
     */
public updateConfig(config: Partial<NotificationConfig>): void
/**
     * Get the current notification configuration.
     *
     * @returns A copy of the current configuration
     *
     * @remarks
     * Returns a copy to prevent external modification of the internal configuration.
     * Use {@link NotificationService.updateConfig} to modify settings.
     */
public getConfig(): NotificationConfig
/**
     * Check if system notifications are supported on the current platform.
     *
     * @returns `true` if notifications are supported, `false` otherwise
     *
     * @remarks
     * Uses Electron's built-in platform detection to determine notification support.
     * On unsupported platforms, notification methods will log warnings instead
     * of attempting to display notifications.
     */
public isSupported(): boolean
</file>

<file path="electron/utils/database/historyLimitManager.ts">
/**
 * Utility for managing history limits in the database.
 */
import type { HistoryRepository, SettingsRepository, DatabaseService } from "../../services/index";
import { withDatabaseOperation } from "../operationalHooks";
interface Logger {
    debug: (message: string, ...args: unknown[]) => void;
    error: (message: string, error?: unknown, ...args: unknown[]) => void;
    info: (message: string, ...args: unknown[]) => void;
    warn: (message: string, ...args: unknown[]) => void;
}
/**
 * Parameters for setting history limit
 */
interface SetHistoryLimitParams {
    /**
     * The limit to set
     */
    limit: number;
    /**
     * Repository instances
     */
    repositories: {
        settings: SettingsRepository;
        history: HistoryRepository;
    };
    /**
     * Database service for transactions
     */
    databaseService: DatabaseService;
    /**
     * Callback to update the internal history limit
     */
    setHistoryLimit: (limit: number) => void;
    /**
     * Logger instance
     */
    logger?: Logger;
}
⋮----
/**
     * The limit to set
     */
⋮----
/**
     * Repository instances
     */
⋮----
/**
     * Database service for transactions
     */
⋮----
/**
     * Callback to update the internal history limit
     */
⋮----
/**
     * Logger instance
     */
⋮----
/**
 * Set the history retention limit and prune older history entries if needed.
 *
 * @param params - Parameters for setting history limit
 */
export async function setHistoryLimit(params: SetHistoryLimitParams): Promise<void>
⋮----
// Determine the appropriate limit value
⋮----
// Update the internal limit
⋮----
// Use single transaction for atomicity - either both operations succeed or both fail
⋮----
// Save to settings using internal method
⋮----
// Prune history for all monitors if limit > 0 using internal method
⋮----
/**
 * Get the current history limit.
 *
 * @param getHistoryLimit - Function to retrieve the current history limit
 * @returns The current history limit
 */
export function getHistoryLimit(getHistoryLimit: () => number): number
</file>

<file path="src/hooks/site/useSiteDetails.ts">
/**
 * Custom hook for managing site details state and operations
 *
 * Provides comprehensive state management for the site details view including:
 * - Site data and monitor information
 * - UI state (active tab, loading states)
 * - Site operations (start/stop monitoring, check now, update settings)
 * - Local state management for editable fields
 * - Integration with analytics data
 */
import { useEffect, useState, useCallback } from "react";
import { DEFAULT_CHECK_INTERVAL, DEFAULT_REQUEST_TIMEOUT_SECONDS } from "../../constants";
import { logger } from "../../services";
import { useErrorStore, useSitesStore, useUIStore } from "../../stores";
import { Site } from "../../types";
import { useSiteAnalytics } from "./useSiteAnalytics";
/** Props for the useSiteDetails hook */
interface UseSiteDetailsProperties {
    /** The site object to manage details for */
    site: Site;
}
⋮----
/** The site object to manage details for */
⋮----
/**
 * Hook for managing site details state and operations.
 *
 * Provides all necessary state and handlers for the site details view,
 * including monitor selection, monitoring controls, settings management,
 * and integration with analytics.
 *
 * @param props - Hook props containing the site to manage
 * @returns Object containing all site details state and handlers
 *
 * @example
 * ```tsx
 * function SiteDetails({ site }) {
 *   const {
 *     currentSite,
 *     selectedMonitor,
 *     isLoading,
 *     handleStartMonitoring,
 *     handleStopMonitoring,
 *     // ... other state and handlers
 *   } = useSiteDetails({ site });
 *
 *   // Use the state and handlers in your component
 * }
 * ```
 */
export function useSiteDetails(
⋮----
// Always call hooks first, use fallback for currentSite
⋮----
monitoring: true, // Default to monitoring enabled
⋮----
name: "Unnamed Site", // Provide default name
⋮----
// Find the selected monitor, and if it doesn't exist, update the selection to the first monitor
⋮----
// Use useEffect to handle stale monitor ID updates (avoid state updates during render)
⋮----
// If the selected monitor ID is stale (doesn't exist), update it to match the actual selected monitor
⋮----
// Check interval state
⋮----
// Timeout state (stored in seconds for UI, converted to ms when saving)
⋮----
// Retry attempts state
⋮----
// Site name state for settings
⋮----
// Update local state when monitor changes
⋮----
// Track name changes
⋮----
// Handler for check now
⋮----
// No auto-refresh - respect the monitor's configured interval
// Users can manually click "Check Now" if they want immediate updates
// Handler for monitor selection change
⋮----
// If current tab is an analytics tab, switch to the new monitor's analytics tab
⋮----
// Handler for site removal
⋮----
// Handler for monitor removal
⋮----
// Site-level monitoring handlers
⋮----
// First, update the site's monitoring field in the database
⋮----
// Then start the actual monitoring processes
⋮----
// First, update the site's monitoring field in the database
⋮----
// Then stop the actual monitoring processes
⋮----
// Monitoring handlers
⋮----
// Interval change handlers
⋮----
// Timeout change handlers
⋮----
// Work directly with seconds in the UI
⋮----
// Compare against the monitor's timeout converted to seconds
⋮----
// Convert seconds to milliseconds when saving to backend
⋮----
// Retry attempts change handlers
⋮----
// Name save handler
⋮----
// Use analytics hook
⋮----
// Check if site exists
⋮----
// UI state
⋮----
// Analytics
⋮----
// Site data
⋮----
// Handlers
⋮----
// Name state
⋮----
// Interval state
⋮----
// Store actions
</file>

<file path="electron/main.ts">
/**
 * Main entry point for the Electron application.
 *
 * @remarks
 * Configures logging and initializes the main application service.
 * Sets up proper shutdown handlers for graceful cleanup.
 *
 * @packageDocumentation
 */
import log from "electron-log/main";
import { app } from "electron";
import { ApplicationService, logger } from "./index";
// Configure electron-log for main process
// Enable preload mode for reliable logging in Electron's main process, especially with context isolation enabled
⋮----
log.transports.file.maxSize = 1024 * 1024 * 5; // 5MB max file size
⋮----
/**
 * Main application class that initializes and manages the Electron app.
 *
 * @remarks
 * Uses modular ApplicationService for clean separation of concerns and follows
 * the single responsibility principle. Handles application lifecycle management
 * including initialization, cleanup, and graceful shutdown.
 *
 * The class ensures that cleanup is performed only once even if multiple
 * shutdown events are triggered, preventing resource leaks and errors.
 */
class Main {
⋮----
/** Application service instance for managing app lifecycle and features */
⋮----
/**
     * Initialize the main application.
     *
     * @remarks
     * Sets up logging, creates application service, and configures cleanup handlers.
     * Establishes event listeners for both Node.js process events and Electron
     * app events to ensure proper cleanup in all shutdown scenarios.
     *
     * The cleanup is designed to be idempotent - safe to call multiple times
     * without side effects or errors.
     */
constructor()
⋮----
// Ensure cleanup is only called once to prevent double-cleanup errors
⋮----
const safeCleanup = () =>
// Setup cleanup on Node.js process exit to ensure graceful shutdown
⋮----
// Also handle Electron's will-quit event for robust cleanup
⋮----
// Start the application
// Create Main instance and keep reference alive to prevent garbage collection.
// This is intentional - we need the instance to persist for the lifetime of the application.
</file>

<file path="electron/managers/DatabaseManager.ts">
/**
 * Manages database operations including initialization, data management, and backups.
 * Handles database initialization, import/export, and backup operations.
 */
import { DEFAULT_HISTORY_LIMIT } from "../constants";
import { UptimeEvents, TypedEventBus } from "../events/index";
/**
 * Combined events interface for DatabaseManager.
 */
type DatabaseManagerEvents = UptimeEvents;
import { DatabaseService, SiteRepository, MonitorRepository, HistoryRepository, SettingsRepository } from "../services";
import { Site } from "../types";
import {
    initDatabase,
    getHistoryLimit as getHistoryLimitUtil,
    setHistoryLimit as setHistoryLimitUtil,
    createSiteLoadingOrchestrator,
    createSiteCache,
    createDataImportExportOrchestrator,
    createDataBackupOrchestrator,
    monitorLogger as logger,
} from "../utils";
export interface DatabaseManagerDependencies {
    eventEmitter: TypedEventBus<DatabaseManagerEvents>;
    repositories: {
        database: DatabaseService;
        site: SiteRepository;
        monitor: MonitorRepository;
        history: HistoryRepository;
        settings: SettingsRepository;
    };
}
/**
 * Manages database operations and data management.
 * Handles initialization, import/export, backup, and history management.
 * Uses the new service-based architecture for all operations.
 */
export class DatabaseManager {
⋮----
constructor(dependencies: DatabaseManagerDependencies)
/**
     * Initialize the database and load sites.
     */
public async initialize(): Promise<void>
⋮----
// Emit typed database initialized event
⋮----
duration: 0, // Database initialization duration not tracked yet
⋮----
// Don't throw here as the database initialization itself succeeded
⋮----
/**
     * Load sites from database and update cache.
     */
private async loadSites(): Promise<void>
⋮----
// Create the site cache
⋮----
// Create the site loading orchestrator
⋮----
// Create monitoring configuration
⋮----
// Emit history limit updated event
⋮----
// First update the cache so monitoring can find the sites
⋮----
// Then request monitoring start via events
⋮----
return true; // Always return true for the interface
⋮----
// Request monitoring stop via events
⋮----
return true; // Always return true for the interface
⋮----
// For database loading, we don't need to setup new monitors
// This is only used during site updates
⋮----
// Load sites using the new service-based architecture
⋮----
// Update the cache with loaded sites (final update to ensure consistency)
⋮----
/**
     * Export all application data to JSON string.
     */
public async exportData(): Promise<string>
⋮----
// Emit typed data exported event
⋮----
/**
     * Import data from JSON string.
     */
public async importData(data: string): Promise<boolean>
⋮----
// Emit typed data imported event
⋮----
/**
     * Download SQLite database backup.
     */
public async downloadBackup(): Promise<
⋮----
// Emit typed backup downloaded event
⋮----
/**
     * Refresh sites from database and update cache.
     */
public async refreshSites(): Promise<Site[]>
⋮----
// Load sites first
⋮----
// Then get them from cache
⋮----
// Emit typed sites refreshed event
⋮----
// Convert to Site[] format expected by the interface
⋮----
/**
     * Set history limit for monitor data retention.
     */
public async setHistoryLimit(limit: number): Promise<void>
⋮----
// Emit typed history limit updated event - fire and forget
⋮----
/**
     * Get current history limit.
     */
public getHistoryLimit(): number
</file>

<file path="electron/services/database/SettingsRepository.ts">
import { Database } from "node-sqlite3-wasm";
import { isDev } from "../../electronUtils";
import { logger, withDatabaseOperation } from "../../utils/index";
import { DatabaseService } from "./DatabaseService";
/**
 * Repository for managing application settings persistence.
 * Handles CRUD operations for settings in the database.
 */
export class SettingsRepository {
⋮----
constructor()
/**
     * Get the database instance.
     */
private getDb(): Database
/**
     * Get a setting by key.
     */
public async get(key: string): Promise<string | undefined>
⋮----
// eslint-disable-next-line @typescript-eslint/require-await
⋮----
/**
     * Set a setting value.
     */
public async set(key: string, value: string): Promise<void>
/**
     * Internal method to set a setting value within an existing transaction.
     * Use this method when you're already within a transaction context.
     */
public setInternal(db: Database, key: string, value: string): void
/**
     * Delete a setting by key.
     */
public async delete(key: string): Promise<void>
/**
     * Internal method to delete a setting by key within an existing transaction.
     * Use this method when you're already within a transaction context.
     */
public deleteInternal(db: Database, key: string): void
/**
     * Get all settings.
     */
public getAll(): Record<string, string>
/**
     * Clear all settings from the database.
     */
public async deleteAll(): Promise<void>
/**
     * Internal method to clear all settings from the database within an existing transaction.
     * Use this method when you're already within a transaction context.
     */
public deleteAllInternal(db: Database): void
/**
     * Bulk insert settings (for import functionality).
     * Uses a prepared statement and transaction for better performance.
     */
public async bulkInsert(settings: Record<string, string>): Promise<void>
/**
     * Internal method to bulk insert settings within an existing transaction.
     * Use this method when you're already within a transaction context.
     */
public bulkInsertInternal(db: Database, settings: Record<string, string>): void
⋮----
// Prepare the statement once for better performance
</file>

<file path="electron/types.ts">
/**
 * Type definitions for Electron main process.
 *
 * @remarks
 * Core data structures for site monitoring functionality.
 *
 * @packageDocumentation
 */
import type { MonitorType as RegistryMonitorType } from "./services/monitoring/MonitorTypeRegistry";
// Re-export for use throughout the application
export type MonitorType = RegistryMonitorType;
/**
 * Allowed status values for a monitor's current operational state.
 * @public
 */
export type MonitorStatus = "up" | "down" | "pending" | "paused";
/**
 * Allowed status values for historical check results.
 *
 * @remarks
 * Similar to {@link MonitorStatus} but excludes `"pending"` since historical
 * records only capture actual check outcomes, not transitional states.
 *
 * @public
 */
export type StatusHistoryStatus = "up" | "down" | "paused";
/**
 * Monitor configuration and state interface.
 *
 * @remarks
 * Represents a single monitoring endpoint that can check either HTTP/HTTPS URLs
 * or TCP port connectivity. Each monitor maintains its current status, performance
 * metrics, and historical data.
 *
 * @example
 * ```typescript
 * // HTTP monitor example
 * const httpMonitor: Monitor = {
 *   id: "mon_123",
 *   type: "http",
 *   status: "up",
 *   responseTime: 250,
 *   monitoring: true,
 *   url: "https://example.com",
 *   history: []
 * };
 *
 * // Port monitor example
 * const portMonitor: Monitor = {
 *   id: "mon_456",
 *   type: "port",
 *   status: "down",
 *   responseTime: -1,
 *   monitoring: true,
 *   host: "example.com",
 *   port: 80,
 *   history: []
 * };
 * ```
 *
 * @public
 */
export interface Monitor {
    /**
     * Unique identifier for this monitor.
     *
     * @remarks
     * Usually a UUID or database-generated ID converted to string.
     * Used for referencing this monitor across the application.
     */
    id: string;
    /**
     * Type of monitoring performed by this monitor.
     *
     * @see {@link MonitorType}
     */
    type: MonitorType;
    /**
     * Current operational status of the monitor.
     *
     * @remarks
     * Includes `"pending"` state for monitors that haven't been checked yet.
     *
     * @see {@link MonitorStatus}
     */
    status: MonitorStatus;
    /**
     * Last recorded response time in milliseconds.
     *
     * @remarks
     * - For successful checks: actual response time
     * - For failed checks: may be timeout value or -1
     * - For unchecked monitors: typically -1 as sentinel value
     *
     * @defaultValue -1
     */
    responseTime: number;
    /**
     * Timestamp of the most recent check attempt.
     *
     * @remarks
     * `undefined` for monitors that have never been checked.
     * Uses JavaScript Date object for consistent time handling.
     */
    lastChecked?: Date;
    /**
     * Array of historical check results.
     *
     * @remarks
     * Ordered chronologically from oldest to newest. May be empty for
     * new monitors. Typically limited to a maximum number of entries
     * for performance and storage efficiency.
     *
     * @see {@link StatusHistory}
     */
    history: StatusHistory[];
    /**
     * Whether this monitor is actively being checked.
     *
     * @remarks
     * When `false`, the monitor exists but checks are not performed.
     * Useful for temporarily disabling monitors without deleting them.
     *
     * @defaultValue true
     */
    monitoring: boolean;
    /**
     * URL endpoint for HTTP monitors.
     *
     * @remarks
     * Required for `type: "http"` monitors. Must be `undefined` for other types.
     * Should include protocol (http:// or https://).
     *
     * @example "https://api.example.com/health"
     */
    url?: string;
    /**
     * Hostname or IP address for port monitors.
     *
     * @remarks
     * Required for `type: "port"` monitors. Must be `undefined` for other types.
     * Can be domain name, IPv4, or IPv6 address.
     *
     * @example "example.com" | "192.168.1.1" | "::1"
     */
    host?: string;
    /**
     * Port number for port monitors.
     *
     * @remarks
     * Required for `type: "port"` monitors. Must be `undefined` for other types.
     * Valid range: 1-65535.
     *
     * @example 80 | 443 | 3000
     */
    port?: number;
    /**
     * Check interval in milliseconds (per-monitor override).
     *
     * @remarks
     * Defaults to global check interval if not specified.
     */
    checkInterval: number;
    /**
     * Request timeout in milliseconds for this monitor.
     *
     * @remarks
     * Defaults to global timeout value if not specified.
     */
    timeout: number;
    /**
     * Number of retry attempts before marking as down for this monitor.
     *
     * @remarks
     * - If set to `0`, no retries will be performed (the monitor will be marked as down after the first failure).
     * - Defaults to global retry attempts if not specified.
     * - Any positive integer specifies the number of additional attempts after the initial failure.
     */
    retryAttempts: number;
}
⋮----
/**
     * Unique identifier for this monitor.
     *
     * @remarks
     * Usually a UUID or database-generated ID converted to string.
     * Used for referencing this monitor across the application.
     */
⋮----
/**
     * Type of monitoring performed by this monitor.
     *
     * @see {@link MonitorType}
     */
⋮----
/**
     * Current operational status of the monitor.
     *
     * @remarks
     * Includes `"pending"` state for monitors that haven't been checked yet.
     *
     * @see {@link MonitorStatus}
     */
⋮----
/**
     * Last recorded response time in milliseconds.
     *
     * @remarks
     * - For successful checks: actual response time
     * - For failed checks: may be timeout value or -1
     * - For unchecked monitors: typically -1 as sentinel value
     *
     * @defaultValue -1
     */
⋮----
/**
     * Timestamp of the most recent check attempt.
     *
     * @remarks
     * `undefined` for monitors that have never been checked.
     * Uses JavaScript Date object for consistent time handling.
     */
⋮----
/**
     * Array of historical check results.
     *
     * @remarks
     * Ordered chronologically from oldest to newest. May be empty for
     * new monitors. Typically limited to a maximum number of entries
     * for performance and storage efficiency.
     *
     * @see {@link StatusHistory}
     */
⋮----
/**
     * Whether this monitor is actively being checked.
     *
     * @remarks
     * When `false`, the monitor exists but checks are not performed.
     * Useful for temporarily disabling monitors without deleting them.
     *
     * @defaultValue true
     */
⋮----
/**
     * URL endpoint for HTTP monitors.
     *
     * @remarks
     * Required for `type: "http"` monitors. Must be `undefined` for other types.
     * Should include protocol (http:// or https://).
     *
     * @example "https://api.example.com/health"
     */
⋮----
/**
     * Hostname or IP address for port monitors.
     *
     * @remarks
     * Required for `type: "port"` monitors. Must be `undefined` for other types.
     * Can be domain name, IPv4, or IPv6 address.
     *
     * @example "example.com" | "192.168.1.1" | "::1"
     */
⋮----
/**
     * Port number for port monitors.
     *
     * @remarks
     * Required for `type: "port"` monitors. Must be `undefined` for other types.
     * Valid range: 1-65535.
     *
     * @example 80 | 443 | 3000
     */
⋮----
/**
     * Check interval in milliseconds (per-monitor override).
     *
     * @remarks
     * Defaults to global check interval if not specified.
     */
⋮----
/**
     * Request timeout in milliseconds for this monitor.
     *
     * @remarks
     * Defaults to global timeout value if not specified.
     */
⋮----
/**
     * Number of retry attempts before marking as down for this monitor.
     *
     * @remarks
     * - If set to `0`, no retries will be performed (the monitor will be marked as down after the first failure).
     * - Defaults to global retry attempts if not specified.
     * - Any positive integer specifies the number of additional attempts after the initial failure.
     */
⋮----
/**
 * Site configuration containing multiple monitors.
 * Represents a logical grouping of monitors for a single service/website.
 */
export interface Site {
    /** Unique identifier for the site (UUID, used as the key everywhere) */
    identifier: string;
    /**
     * Display name for the site.
     *
     * @remarks
     * Defaults to "Unnamed Site" if not provided.
     */
    name: string;
    /**
     * Array of monitors associated with this site.
     *
     * @remarks
     * This array may be empty if the site has no monitors configured.
     */
    monitors: Monitor[];
    /**
     * Whether monitoring is active for this site.
     *
     * @remarks
     * Defaults to true for new sites.
     */
    monitoring: boolean;
}
⋮----
/** Unique identifier for the site (UUID, used as the key everywhere) */
⋮----
/**
     * Display name for the site.
     *
     * @remarks
     * Defaults to "Unnamed Site" if not provided.
     */
⋮----
/**
     * Array of monitors associated with this site.
     *
     * @remarks
     * This array may be empty if the site has no monitors configured.
     */
⋮----
/**
     * Whether monitoring is active for this site.
     *
     * @remarks
     * Defaults to true for new sites.
     */
⋮----
/**
 * Historical monitoring data point.
 * Records the result of a single monitor check.
 *
 * @remarks
 * The `status` property does not include `"pending"` because only actual check results are recorded in history.
 * `"pending"` is used in `Monitor.status` to indicate a monitor has not yet been checked, but is never stored in history.
 */
export interface StatusHistory {
    /** Timestamp when the check was performed */
    timestamp: number;
    /**
     * Result status of the check.
     *
     * @remarks
     * Does not include `"pending"`; only actual check outcomes are recorded.
     */
    status: StatusHistoryStatus;
    /** Response time in milliseconds */
    responseTime: number;
    /** Optional additional details about the check */
    details?: string;
}
⋮----
/** Timestamp when the check was performed */
⋮----
/**
     * Result status of the check.
     *
     * @remarks
     * Does not include `"pending"`; only actual check outcomes are recorded.
     */
⋮----
/** Response time in milliseconds */
⋮----
/** Optional additional details about the check */
⋮----
/**
 * Status update event payload.
 *
 * Represents a status update for a site, including the site data and the previous status.
 */
export interface StatusUpdate {
    site: Site;
    previousStatus?: MonitorStatus;
}
</file>

<file path="electron/utils/database/SiteWriterService.ts">
/**
 * Service for site writing operations.
 * Provides a testable, dependency-injected service for site creation, update, and deletion.
 */
import { Database } from "node-sqlite3-wasm";
import { DatabaseService, SiteRepository, MonitorRepository } from "../../services/index";
import { Site, Monitor } from "../../types";
import { withDatabaseOperation } from "../operationalHooks";
import { Logger, SiteCacheInterface, SiteWritingConfig, MonitoringConfig, SiteNotFoundError } from "./interfaces";
/**
 * Service for handling site writing operations.
 * Separates data operations from side effects for better testability.
 */
export class SiteWriterService {
⋮----
constructor(config: SiteWritingConfig &
/**
     * Create a new site in the database with its monitors.
     * Pure data operation without side effects.
     */
async createSite(siteData: Site): Promise<Site>
⋮----
// Use executeTransaction for atomic multi-step operation
⋮----
// Persist site to database using internal method
⋮----
// Remove all existing monitors for this site, then insert new ones
⋮----
// Create monitors and assign IDs using internal method
⋮----
/**
     * Update a site with new values.
     * Pure data operation without side effects.
     */
async updateSite(siteCache: SiteCacheInterface, identifier: string, updates: Partial<Site>): Promise<Site>
⋮----
// Validate input
⋮----
// Create updated site
⋮----
// Use executeTransaction for atomic multi-step operation
⋮----
// Persist to database using internal method
⋮----
// Update monitors if provided - UPDATE existing monitors instead of recreating
⋮----
/**
     * Delete a site and all its monitors from the database.
     * Pure data operation without side effects.
     */
async deleteSite(siteCache: SiteCacheInterface, identifier: string): Promise<boolean>
⋮----
// Remove from cache
⋮----
// Use executeTransaction for atomic multi-table deletion
⋮----
// Remove from database using internal methods
⋮----
/**
     * Handle monitoring state changes when monitor intervals are modified.
     * Side effect operation separated from data updates.
     */
async handleMonitorIntervalChanges(
        identifier: string,
        originalSite: Site,
        newMonitors: Site["monitors"],
        monitoringConfig: MonitoringConfig
): Promise<void>
⋮----
// Always handle monitor interval changes in both development and production
⋮----
// Always stop to clean up any existing scheduling
⋮----
// Only restart if the monitor was actually monitoring
⋮----
// Don't throw - this is a side effect operation that shouldn't fail the update
⋮----
/**
     * Validate that a site exists in the cache.
     */
private validateSiteExists(siteCache: SiteCacheInterface, identifier: string): Site
/**
     * Create updated site object with new values.
     */
private createUpdatedSite(siteCache: SiteCacheInterface, site: Site, updates: Partial<Site>): Site
/**
     * Update monitors preserving their history and IDs.
     * This method updates existing monitors and creates new ones as needed.
     */
private async updateMonitorsPreservingHistory(
        db: Database,
        siteIdentifier: string,
        newMonitors: Site["monitors"]
): Promise<void>
⋮----
// Process each monitor: update existing or create new
⋮----
// Clean up monitors that are no longer needed
⋮----
/**
     * Process monitor updates and creations.
     */
private processMonitorUpdates(
        db: Database,
        siteIdentifier: string,
        newMonitors: Site["monitors"],
        existingMonitors: Site["monitors"]
): void
/**
     * Process a single monitor: update if exists, create if new.
     */
private processIndividualMonitor(
        db: Database,
        siteIdentifier: string,
        newMonitor: Monitor,
        existingMonitors: Site["monitors"]
): void
/**
     * Handle a monitor that has an ID (existing or orphaned).
     */
private handleExistingMonitor(
        db: Database,
        siteIdentifier: string,
        newMonitor: Monitor,
        existingMonitors: Site["monitors"]
): void
/**
     * Update an existing monitor in the database.
     */
private updateExistingMonitor(
        db: Database,
        siteIdentifier: string,
        newMonitor: Monitor,
        existingMonitor: Monitor
): void
⋮----
return; // Safety check - should not happen in this context
⋮----
/**
     * Build the update data for a monitor, preserving existing state.
     */
private buildMonitorUpdateData(newMonitor: Monitor, existingMonitor: Monitor): Partial<Monitor>
⋮----
// Only update optional fields if they are defined
⋮----
/**
     * Create a new monitor in the database.
     */
private createNewMonitor(db: Database, siteIdentifier: string, newMonitor: Monitor, reason?: string): void
/**
     * Remove monitors that are no longer in the site configuration.
     */
private removeObsoleteMonitors(
        db: Database,
        siteIdentifier: string,
        newMonitors: Site["monitors"],
        existingMonitors: Site["monitors"]
): void
/**
     * Detect new monitors that were added to an existing site.
     * @param originalMonitors - The original monitors before update
     * @param updatedMonitors - The updated monitors after update
     * @returns Array of new monitor IDs
     */
public detectNewMonitors(originalMonitors: Site["monitors"], updatedMonitors: Site["monitors"]): string[]
⋮----
/**
 * Orchestrates site writing operations with monitoring side effects.
 * Coordinates data operations with monitoring state changes.
 */
export class SiteWritingOrchestrator {
⋮----
constructor(siteWriterService: SiteWriterService)
/**
     * Create a new site in the database.
     * Pure data operation delegated to the service.
     */
⋮----
/**
     * Delete a site from the database.
     * Pure data operation delegated to the service.
     */
⋮----
/**
     * Update a site with monitoring state handling.
     * Coordinates data updates with monitoring side effects.
     */
async updateSiteWithMonitoring(
        siteCache: SiteCacheInterface,
        identifier: string,
        updates: Partial<Site>,
        monitoringConfig: MonitoringConfig
): Promise<Site>
⋮----
// Get original site before update
⋮----
// Perform the update
⋮----
// Handle monitoring changes if monitors were updated
⋮----
// Detect and setup new monitors to ensure consistency with new site behavior
</file>

<file path="electron/utils/monitoring/monitorLifecycle.ts">
/**
 * Monitor lifecycle management utilities.
 * Consolidates monitor starting and stopping operations for better organization.
 */
import { UptimeEvents, TypedEventBus } from "../../events/index";
import { MonitorRepository, DatabaseService, MonitorScheduler } from "../../services/index";
import { Site } from "../../types";
import { SiteCacheInterface } from "../database/interfaces";
import { withDatabaseOperation } from "../operationalHooks";
interface Logger {
    debug: (message: string, ...args: unknown[]) => void;
    error: (message: string, error?: unknown, ...args: unknown[]) => void;
    info: (message: string, ...args: unknown[]) => void;
    warn: (message: string, ...args: unknown[]) => void;
}
/**
 * Configuration object for monitoring lifecycle functions.
 */
export interface MonitoringLifecycleConfig {
    sites: SiteCacheInterface;
    monitorScheduler: MonitorScheduler;
    monitorRepository: MonitorRepository;
    databaseService: DatabaseService;
    eventEmitter: TypedEventBus<UptimeEvents>;
    logger: Logger;
}
/**
 * Type for the monitoring lifecycle callback functions.
 */
export type MonitoringCallback = (identifier: string, monitorId?: string) => Promise<boolean>;
/**
 * Start monitoring for all sites.
 *
 * @param config - Configuration object with required dependencies
 * @param isMonitoring - Current monitoring state
 * @returns Promise<boolean> - New monitoring state
 */
export async function startAllMonitoring(config: MonitoringLifecycleConfig, isMonitoring: boolean): Promise<boolean>
⋮----
// Set all monitors to pending status and enable monitoring
⋮----
// Use operational hooks for database update
⋮----
/**
 * Stop all monitoring and return updated monitoring state.
 *
 * @param config - Configuration object with required dependencies
 * @returns boolean - New monitoring state (always false)
 */
export async function stopAllMonitoring(config: MonitoringLifecycleConfig): Promise<boolean>
⋮----
// Set all monitors to paused status
⋮----
// Use operational hooks for database update
⋮----
/**
 * Start monitoring for a specific site or monitor.
 *
 * @param config - Configuration object with required dependencies
 * @param identifier - Site identifier
 * @param monitorId - Optional monitor ID (if not provided, starts all monitors for the site)
 * @param callback - Callback function for recursive calls
 * @returns Promise<boolean> - True if monitoring was started successfully
 */
export async function startMonitoringForSite(
    config: MonitoringLifecycleConfig,
    identifier: string,
    monitorId?: string,
    callback?: MonitoringCallback
): Promise<boolean>
/**
 * Stop monitoring for a specific site or monitor.
 *
 * @param config - Configuration object with required dependencies
 * @param identifier - Site identifier
 * @param monitorId - Optional monitor ID (if not provided, stops all monitors for the site)
 * @param callback - Callback function for recursive calls
 * @returns Promise<boolean> - True if monitoring was stopped successfully
 */
export async function stopMonitoringForSite(
    config: MonitoringLifecycleConfig,
    identifier: string,
    monitorId?: string,
    callback?: MonitoringCallback
): Promise<boolean>
/**
 * Helper function to start monitoring for a specific monitor.
 */
async function startSpecificMonitor(
    config: MonitoringLifecycleConfig,
    site: Site,
    identifier: string,
    monitorId: string
): Promise<boolean>
⋮----
// Use operational hooks for database update
⋮----
/**
 * Helper function to stop monitoring for a specific monitor.
 */
async function stopSpecificMonitor(
    config: MonitoringLifecycleConfig,
    site: Site,
    identifier: string,
    monitorId: string
): Promise<boolean>
⋮----
// Use operational hooks for database update
⋮----
/**
 * Helper function to start or stop monitoring for all monitors in a site.
 */
async function processAllSiteMonitors(
    config: MonitoringLifecycleConfig,
    site: Site,
    identifier: string,
    callback?: MonitoringCallback,
    useOptimisticLogic = true
): Promise<boolean>
⋮----
// If no callback is provided, we can't perform any operations
⋮----
// Process monitors sequentially to avoid database transaction conflicts
⋮----
// Log error but continue processing other monitors
⋮----
// For starting monitors, use optimistic logic (succeed if ANY monitor starts)
// For stopping monitors, use pessimistic logic (fail if ANY monitor fails to stop)
⋮----
/**
 * Helper function to start monitoring for all monitors in a site.
 */
async function startAllSiteMonitors(
    config: MonitoringLifecycleConfig,
    site: Site,
    identifier: string,
    callback?: MonitoringCallback
): Promise<boolean>
⋮----
return processAllSiteMonitors(config, site, identifier, callback, true); // Use optimistic logic for starting
⋮----
/**
 * Helper function to stop monitoring for all monitors in a site.
 */
async function stopAllSiteMonitors(
    config: MonitoringLifecycleConfig,
    site: Site,
    identifier: string,
    callback?: MonitoringCallback
): Promise<boolean>
⋮----
return processAllSiteMonitors(config, site, identifier, callback, false); // Use pessimistic logic for stopping
</file>

<file path="src/stores/utils.ts">
/**
 * Utility functions for store management and composition.
 *
 * @remarks
 * Provides common functionality for error handling, persistence, and store composition
 * across all Zustand stores in the application. These utilities ensure consistent
 * patterns for async operations, error states, and data persistence.
 *
 * @packageDocumentation
 */
import { BaseStore } from "./types";
import logger from "../services/logger";
/**
 * Creates a base store slice with common error handling functionality.
 *
 * @param set - Zustand set function for updating store state
 * @returns Object containing common store methods and initial state values
 *
 * @remarks
 * This function provides a standardized way to add error handling, loading states,
 * and error management to any Zustand store. It ensures consistent error handling
 * patterns across all stores in the application.
 *
 * @example
 * ```typescript
 * const useMyStore = create<MyStore>((set, get) => ({
 *   ...createBaseStore(set),
 *   // ... other store properties
 * }));
 * ```
 *
 * @public
 */
export const createBaseStore = <T extends BaseStore>(
    set: (partial: Partial<T>) => void
): Pick<T, "lastError" | "isLoading" | "setError" | "setLoading" | "clearError"> => (
/**
 * Wrapper for async operations with standardized error handling.
 *
 * @param operation - Async function to execute with error handling
 * @param store - Store instance with error handling methods
 * @returns Promise resolving to the operation result
 *
 * @throws Re-throws the original error after setting it in the store
 *
 * @remarks
 * This utility automatically manages loading states and error handling for async
 * operations. It sets loading to true at the start, clears any previous errors,
 * and properly handles both success and failure scenarios.
 *
 * The loading state is always cleared in the finally block, ensuring consistent
 * state management even if the operation throws an error.
 *
 * @example
 * ```typescript
 * const fetchData = async () => {
 *   return withErrorHandling(
 *     () => api.getData(),
 *     store
 *   );
 * };
 * ```
 *
 * @public
 */
export const withErrorHandling = async <T>(
    operation: () => Promise<T>,
    store: Pick<BaseStore, "setError" | "setLoading" | "clearError">
): Promise<T> =>
/**
 * Creates a persistence configuration for Zustand store persistence.
 *
 * @param name - Unique name for the persisted store data
 * @param partialize - Optional function to select which parts of state to persist
 * @returns Configuration object for zustand/middleware/persist
 *
 * @remarks
 * This utility creates a standardized persistence configuration that prefixes
 * all store names with 'uptime-watcher-' to avoid conflicts with other applications.
 * The partialize function allows selective persistence of store properties.
 *
 * @example
 * ```typescript
 * const useMyStore = create(
 *   persist(
 *     (set, get) => ({ }),
 *     createPersistConfig('my-store')
 *   )
 * );
 * ```
 *
 * @public
 */
export const createPersistConfig = <T>(name: string, partialize?: (state: T) => Partial<T>) => (
/**
 * Debounce utility for store actions with automatic cleanup.
 *
 * @param function_ - Function to debounce
 * @param wait - Wait time in milliseconds before executing
 * @returns Debounced version of the input function
 *
 * @remarks
 * This utility prevents rapid successive calls to expensive operations like
 * API requests or state updates. It uses a Map to track timeouts per unique
 * argument combination, allowing different argument sets to be debounced independently.
 *
 * @example
 * ```typescript
 * const debouncedSave = debounce(saveSettings, 500);
 * debouncedSave(newSettings); // Will only execute after 500ms of no new calls
 * ```
 *
 * @public
 */
export const debounce = <T extends unknown[]>(
    function_: (...arguments_: T) => void,
    wait: number
): ((...arguments_: T) => void) =>
/**
 * Logger utility for store actions in development mode.
 *
 * @param storeName - Name of the store performing the action
 * @param actionName - Name of the action being performed
 * @param data - Optional data associated with the action
 *
 * @remarks
 * This utility provides consistent logging for store actions during development.
 * It only logs when NODE_ENV is set to 'development' to avoid performance
 * impact in production builds.
 *
 * @example
 * ```typescript
 * logStoreAction('SitesStore', 'addSite', { id: 'site-123' });
 * ```
 *
 * @public
 */
export const logStoreAction = (storeName: string, actionName: string, data?: unknown) =>
/**
 * Utility function to wait for electronAPI to be available.
 *
 * @param maxAttempts - Maximum number of polling attempts
 * @param baseDelay - Base delay in milliseconds for exponential backoff
 * @returns Promise that resolves when electronAPI is available
 *
 * @throws Error when electronAPI is not available after maximum attempts
 *
 * @remarks
 * Polls for the API with exponential backoff to handle timing issues during
 * application startup. This is necessary because the preload script may not
 * have finished executing when React components first mount.
 *
 * @defaultValue maxAttempts - 50
 * @defaultValue baseDelay - 100
 *
 * @example
 * ```typescript
 * try {
 *   await waitForElectronAPI();
 *   // Safe to use window.electronAPI
 * } catch (error) {
 *   console.error('ElectronAPI not available:', error);
 * }
 * ```
 *
 * @public
 */
export async function waitForElectronAPI(maxAttempts = 50, baseDelay = 100): Promise<void>
⋮----
// eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
⋮----
return; // API is ready
⋮----
// window.electronAPI not available yet
⋮----
// Wait with exponential backoff
</file>

<file path="electron/events/eventTypes.ts">
/**
 * Type definitions for all events in the Uptime Watcher application.
 *
 * @remarks
 * Provides compile-time type safety for event data across the application.
 * Events are organized by domain (site, monitor, database, system) and include
 * comprehensive metadata for debugging and auditing purposes.
 *
 * @packageDocumentation
 */
import type { Monitor, Site, StatusUpdate } from "../types";
/**
 * Reason for an event occurrence.
 *
 * @public
 */
export type EventReason = "user" | "error" | "shutdown";
/**
 * Source that triggered an event.
 *
 * @public
 */
export type EventSource = "user" | "import" | "migration" | "system";
/**
 * Severity level of an event for prioritization.
 *
 * @public
 */
export type EventSeverity = "low" | "medium" | "high" | "critical";
/**
 * Runtime environment where event occurred.
 *
 * @public
 */
export type EventEnvironment = "development" | "production" | "test";
/**
 * Category for grouping related events.
 *
 * @public
 */
export type EventCategory = "database" | "monitoring" | "ui" | "system";
/**
 * Type of monitoring check that triggered an event.
 *
 * @public
 */
export type EventCheckType = "scheduled" | "manual";
/**
 * What triggered a monitoring or system event.
 *
 * @public
 */
export type EventTriggerType = "manual" | "scheduled" | "shutdown";
/**
 * Comprehensive event map for the Uptime Watcher application.
 *
 * @remarks
 * Defines all events that can be emitted throughout the application lifecycle,
 * organized by functional domains. Each event includes strongly typed data
 * for compile-time safety and comprehensive metadata for debugging.
 *
 * Event Categories:
 * - **Site Events**: Site CRUD operations and lifecycle
 * - **Monitor Events**: Individual monitor status and operations
 * - **Database Events**: Data persistence and backup operations
 * - **System Events**: Application lifecycle and errors
 * - **Internal Events**: Manager-to-manager communication
 * - **Performance Events**: Metrics and warnings
 *
 * @public
 */
export interface UptimeEvents extends Record<string, unknown> {
    // Site events
    "site:added": {
        site: Site;
        timestamp: number;
        source: "user" | "import" | "migration";
    };
    "site:updated": {
        site: Site;
        previousSite: Site;
        timestamp: number;
        updatedFields: string[];
    };
    "site:removed": {
        siteId: string;
        siteName: string;
        timestamp: number;
        cascade: boolean;
    };
    // Monitor events
    "monitor:added": {
        monitor: Monitor;
        siteId: string;
        timestamp: number;
    };
    "monitor:status-changed": {
        monitor: Monitor;
        newStatus: string;
        previousStatus: string;
        responseTime?: number;
        site: Site;
        siteId: string;
        timestamp: number;
    };
    "monitor:removed": {
        monitorId: string;
        siteId: string;
        timestamp: number;
    };
    "monitor:check-completed": {
        monitorId: string;
        siteId: string;
        result: StatusUpdate;
        timestamp: number;
        checkType: "scheduled" | "manual";
    };
    // Database events
    "database:transaction-completed": {
        operation: string;
        duration: number;
        timestamp: number;
        success: boolean;
        recordsAffected?: number;
    };
    "database:backup-created": {
        fileName: string;
        size: number;
        timestamp: number;
        triggerType: "manual" | "scheduled" | "shutdown";
    };
    // System events
    "system:startup": {
        version: string;
        timestamp: number;
        environment: "development" | "production" | "test";
    };
    "system:shutdown": {
        timestamp: number;
        reason: "user" | "error" | "update";
        uptime: number;
    };
    "system:error": {
        error: Error;
        context: string;
        timestamp: number;
        severity: "low" | "medium" | "high" | "critical";
        recovery?: string;
    };
    // Monitoring service events
    "monitoring:started": {
        siteCount: number;
        monitorCount: number;
        timestamp: number;
    };
    "monitoring:stopped": {
        reason: "user" | "error" | "shutdown";
        timestamp: number;
        activeMonitors: number;
    };
    // Configuration events
    "config:changed": {
        setting: string;
        oldValue: unknown;
        newValue: unknown;
        timestamp: number;
        source: "user" | "system" | "migration";
    };
    // Performance events
    "performance:metric": {
        metric: string;
        value: number;
        unit: string;
        timestamp: number;
        category: "database" | "monitoring" | "ui" | "system";
    };
    "performance:warning": {
        metric: string;
        threshold: number;
        actual: number;
        timestamp: number;
        suggestion?: string;
    };
    // Internal events for manager-to-manager communication
    "internal:site:added": {
        identifier: string;
        site: Site;
        operation: "added";
        timestamp: number;
    };
    "internal:site:removed": {
        identifier: string;
        operation: "removed";
        timestamp: number;
    };
    "internal:site:updated": {
        identifier: string;
        site: Site;
        operation: "updated";
        timestamp: number;
        updatedFields?: string[];
    };
    "internal:site:cache-updated": {
        identifier: string;
        operation: "cache-updated";
        timestamp: number;
    };
    // Cache operation events
    "site:cache-updated": {
        identifier: string;
        operation: "background-load" | "cache-updated" | "manual-refresh";
        timestamp: number;
    };
    "site:cache-miss": {
        identifier: string;
        operation: "cache-lookup";
        timestamp: number;
        backgroundLoading: boolean;
    };
    // Database operation events
    "database:retry": {
        operation: string;
        attempt: number;
        timestamp: number;
        [key: string]: unknown;
    };
    "database:error": {
        operation: string;
        error: Error;
        timestamp: number;
        [key: string]: unknown;
    };
    "database:success": {
        operation: string;
        timestamp: number;
        duration?: number;
        [key: string]: unknown;
    };
    "internal:site:start-monitoring-requested": {
        identifier: string;
        monitorId?: string;
        operation: "start-monitoring-requested";
        timestamp: number;
    };
    "internal:site:stop-monitoring-requested": {
        identifier: string;
        monitorId?: string;
        operation: "stop-monitoring-requested";
        timestamp: number;
    };
    "internal:site:is-monitoring-active-requested": {
        identifier: string;
        monitorId: string;
        operation: "is-monitoring-active-requested";
        timestamp: number;
    };
    "internal:site:restart-monitoring-requested": {
        identifier: string;
        monitor: Monitor;
        operation: "restart-monitoring-requested";
        timestamp: number;
    };
    "internal:site:is-monitoring-active-response": {
        identifier: string;
        isActive: boolean;
        monitorId: string;
        operation: "is-monitoring-active-response";
        timestamp: number;
    };
    "internal:site:restart-monitoring-response": {
        identifier: string;
        monitorId: string;
        operation: "restart-monitoring-response";
        success: boolean;
        timestamp: number;
    };
    "internal:monitor:all-started": {
        operation: "all-started";
        timestamp: number;
        siteCount: number;
        monitorCount: number;
    };
    "internal:monitor:all-stopped": {
        operation: "all-stopped";
        timestamp: number;
        activeMonitors: number;
        reason: EventReason;
    };
    "internal:monitor:started": {
        identifier: string;
        monitorId?: string;
        operation: "started";
        timestamp: number;
    };
    "internal:monitor:stopped": {
        identifier: string;
        monitorId?: string;
        operation: "stopped";
        timestamp: number;
        reason: EventReason;
    };
    "internal:monitor:manual-check-completed": {
        identifier: string;
        monitorId?: string;
        result: StatusUpdate;
        operation: "manual-check-completed";
        timestamp: number;
    };
    "internal:monitor:site-setup-completed": {
        identifier: string;
        operation: "site-setup-completed";
        timestamp: number;
    };
    "internal:database:initialized": {
        operation: "initialized";
        timestamp: number;
        success: boolean;
    };
    "internal:database:history-limit-updated": {
        operation: "history-limit-updated";
        limit: number;
        timestamp: number;
    };
    "internal:database:data-exported": {
        operation: "data-exported";
        timestamp: number;
        success: boolean;
        fileName?: string;
    };
    "internal:database:data-imported": {
        operation: "data-imported";
        timestamp: number;
        success: boolean;
        recordCount?: number;
    };
    "internal:database:backup-downloaded": {
        operation: "backup-downloaded";
        timestamp: number;
        success: boolean;
        fileName?: string;
    };
    "internal:database:sites-refreshed": {
        operation: "sites-refreshed";
        timestamp: number;
        siteCount: number;
    };
    "internal:database:update-sites-cache-requested": {
        operation: "update-sites-cache-requested";
        sites?: Site[];
        timestamp: number;
    };
    "internal:database:get-sites-from-cache-requested": {
        operation: "get-sites-from-cache-requested";
        timestamp: number;
        sites?: Site[];
    };
    // State synchronization events
    "sites:state-synchronized": {
        action: "update" | "delete" | "bulk-sync";
        siteIdentifier?: string;
        timestamp: number;
        source?: "cache" | "database" | "frontend";
    };
    "cache:invalidated": {
        type: "site" | "monitor" | "all";
        identifier?: string;
        timestamp: number;
        reason: "update" | "delete" | "expiry" | "manual";
    };
}
⋮----
// Site events
⋮----
// Monitor events
⋮----
// Database events
⋮----
// System events
⋮----
// Monitoring service events
⋮----
// Configuration events
⋮----
// Performance events
⋮----
// Internal events for manager-to-manager communication
⋮----
// Cache operation events
⋮----
// Database operation events
⋮----
// State synchronization events
⋮----
/**
 * Event categories for filtering and middleware processing.
 */
⋮----
/**
 * Priority levels for events.
 */
⋮----
/**
 * Type guard to check if an event is of a specific category.
 */
export function isEventOfCategory(eventName: keyof UptimeEvents, category: keyof typeof EVENT_CATEGORIES): boolean
⋮----
// Check if the category exists in EVENT_CATEGORIES
⋮----
// eslint-disable-next-line security/detect-object-injection
⋮----
/**
 * Get the priority level of an event.
 */
export function getEventPriority(eventName: keyof UptimeEvents): keyof typeof EVENT_PRIORITIES
⋮----
return "MEDIUM"; // Default priority
</file>

<file path="electron/managers/MonitorManager.ts">
/**
 * Manages monitoring operations including scheduling and status checking.
 * Handles start/stop operations for individual monitors and sites.
 */
import { DEFAULT_CHECK_INTERVAL } from "../constants";
import { isDev } from "../electronUtils";
import { UptimeEvents, TypedEventBus } from "../events/index";
/**
 * Combined events interface for MonitorManager.
 */
type MonitorManagerEvents = UptimeEvents;
import { MonitorRepository, HistoryRepository, SiteRepository, DatabaseService, MonitorScheduler } from "../services";
import { Site, StatusUpdate } from "../types";
import { SiteCacheInterface } from "../utils/database/interfaces";
import {
    monitorLogger as logger,
    startAllMonitoring,
    startMonitoringForSite,
    stopAllMonitoring,
    stopMonitoringForSite,
    checkSiteManually,
    checkMonitor,
    withDatabaseOperation,
    MonitorCheckConfig,
} from "../utils";
export interface MonitorManagerDependencies {
    eventEmitter: TypedEventBus<MonitorManagerEvents>;
    repositories: {
        monitor: MonitorRepository;
        history: HistoryRepository;
        site: SiteRepository;
    };
    databaseService: DatabaseService;
    getHistoryLimit: () => number;
    getSitesCache: () => SiteCacheInterface;
}
/**
 * Manages monitoring operations and scheduling.
 * Handles monitoring lifecycle and status checks.
 */
export class MonitorManager {
⋮----
constructor(dependencies: MonitorManagerDependencies)
/**
     * Start monitoring for all sites.
     */
public async startMonitoring(): Promise<void>
⋮----
// Emit typed monitoring started event
⋮----
/**
     * Stop monitoring for all sites.
     */
public async stopMonitoring(): Promise<void>
⋮----
// Emit typed monitoring stopped event
⋮----
/**
     * Start monitoring for a specific site or monitor.
     */
public async startMonitoringForSite(identifier: string, monitorId?: string): Promise<boolean>
⋮----
// Emit monitoring started event
⋮----
/**
     * Stop monitoring for a specific site or monitor.
     */
public async stopMonitoringForSite(identifier: string, monitorId?: string): Promise<boolean>
⋮----
// Emit monitoring stopped event
⋮----
/**
     * Check a site manually and return status update.
     */
public async checkSiteManually(identifier: string, monitorId?: string): Promise<StatusUpdate | undefined>
⋮----
// Emit manual check completed event
⋮----
/**
     * Set up a new site for monitoring (initial checks, intervals, auto-start).
     */
public async setupSiteForMonitoring(site: Site): Promise<void>
⋮----
// Apply business rules for default intervals
⋮----
// Apply business rules for auto-starting monitoring
// Note: Initial checks are handled by MonitorScheduler when monitoring starts
⋮----
// Emit site setup completed event
⋮----
/**
     * Set up new monitors that were added to an existing site.
     * Ensures new monitors get the same treatment as monitors in new sites.
     */
public async setupNewMonitors(site: Site, newMonitorIds: string[]): Promise<void>
⋮----
// Filter to only the new monitors
⋮----
// Apply default intervals and perform setup for each new monitor
⋮----
/**
     * Set up individual new monitors (extracted for complexity reduction).
     */
private async setupIndividualNewMonitors(site: Site, newMonitors: Site["monitors"]): Promise<void>
⋮----
// Apply default intervals for new monitors that don't have one
⋮----
// Auto-start monitoring for new monitors if appropriate
// Note: Initial checks are handled by MonitorScheduler when monitoring starts
⋮----
/**
     * Auto-start monitoring for new monitors if appropriate.
     */
private async autoStartNewMonitors(site: Site, newMonitors: Site["monitors"]): Promise<void>
/**
     * Business logic: Apply default check intervals for monitors that don't have one.
     * This ensures all monitors have a check interval set according to business rules.
     */
private async applyDefaultIntervals(site: Site): Promise<void>
⋮----
// Use withDatabaseOperation for consistency and proper error handling
⋮----
/**
     * Business logic: Determine if a monitor should receive a default interval.
     */
private shouldApplyDefaultInterval(monitor: Site["monitors"][0]): boolean
/**
     * Business logic: Automatically start monitoring if appropriate according to business rules.
     */
private async autoStartMonitoringIfAppropriate(site: Site): Promise<void>
⋮----
// Site-level monitoring acts as a master switch
⋮----
// Only process sites that have monitors
⋮----
// Start only monitors that have monitoring enabled (respecting individual monitor states)
⋮----
/**
     * Check a specific monitor (private method for scheduled checks).
     * Implements the core monitoring logic with typed event emission.
     */
private async checkMonitor(site: Site, monitorId: string): Promise<StatusUpdate | undefined>
⋮----
// Use the utility function instead of duplicating logic
⋮----
/**
     * Handle scheduled monitor checks from the MonitorScheduler.
     */
private async handleScheduledCheck(siteIdentifier: string, monitorId: string): Promise<void>
/**
     * Check if monitoring is currently active.
     */
public isMonitoringActive(): boolean
/**
     * Check if a specific monitor is actively being monitored by the scheduler.
     */
public isMonitorActiveInScheduler(siteIdentifier: string, monitorId: string): boolean
/**
     * Restart monitoring for a specific monitor with updated configuration.
     * This is useful when monitor intervals change and need to be applied immediately.
     */
public restartMonitorWithNewConfig(siteIdentifier: string, monitor: Site["monitors"][0]): boolean
</file>

<file path="electron/services/database/utils/monitorMapper.ts">
/**
 * Monitor data mapping utilities.
 *
 * @remarks
 * Handles conversion between database rows and application monitor objects.
 * Uses dynamic schema based on monitor type registry for extensible monitor types.
 *
 * @packageDocumentation
 */
import { Site } from "../../../types";
import { DbValue } from "./valueConverters";
import { mapRowToMonitor, mapMonitorToRow, generateSqlParameters } from "./dynamicSchema";
/**
 * Convert database row to monitor object using dynamic schema.
 *
 * @param row - Database row data
 * @returns Converted monitor object
 *
 * @remarks
 * Uses dynamic mapping based on monitor type registry.
 * Automatically handles all monitor type specific fields.
 *
 * @public
 */
export function rowToMonitor(row: Record<string, unknown>): Site["monitors"][0]
⋮----
// Convert to Site monitor format with defaults
⋮----
history: [], // History will be loaded separately
⋮----
// Add lastChecked if available
⋮----
// Copy all dynamic fields (monitor type specific fields)
⋮----
// eslint-disable-next-line security/detect-object-injection
⋮----
/**
 * Build parameter array for monitor insertion using dynamic schema.
 */
export function buildMonitorParameters(siteIdentifier: string, monitor: Site["monitors"][0]): DbValue[]
⋮----
// Convert monitor to row format
⋮----
// Return values in the same order as columns
⋮----
// eslint-disable-next-line security/detect-object-injection
</file>

<file path="electron/utils/database/DataImportExportService.ts">
/**
 * Service for data import/export operations.
 * Provides a testable, dependency-injected service for application data management.
 */
import { Database } from "node-sqlite3-wasm";
import { UptimeEvents, TypedEventBus } from "../../events/index";
import {
    DatabaseService,
    HistoryRepository,
    MonitorRepository,
    SettingsRepository,
    SiteRepository,
} from "../../services/index";
import { Site, StatusHistory } from "../../types";
import { withDatabaseOperation } from "../operationalHooks";
import { Logger, SiteCacheInterface, SiteLoadingError } from "./interfaces";
/**
 * Type for imported site data structure.
 */
export interface ImportSite {
    identifier: string;
    name?: string;
    monitors?: Site["monitors"];
}
/**
 * Configuration for data import/export operations.
 */
export interface DataImportExportConfig {
    eventEmitter: TypedEventBus<UptimeEvents>;
    databaseService: DatabaseService;
    repositories: {
        history: HistoryRepository;
        monitor: MonitorRepository;
        settings: SettingsRepository;
        site: SiteRepository;
    };
    logger: Logger;
}
/**
 * Type guard for expected import data structure.
 */
function isImportData(obj: unknown): obj is
⋮----
// Optionally check each site for required properties
⋮----
/**
 * Service for handling data import/export operations.
 * Separates data operations from side effects for better testability.
 */
export class DataImportExportService {
⋮----
constructor(config: DataImportExportConfig)
/**
     * Export all application data as JSON string.
     * Pure data operation without side effects.
     */
async exportAllData(): Promise<string>
⋮----
// Export all sites and settings using repositories
⋮----
/**
     * Import data from JSON string.
     * Pure data operation that returns the imported data.
     */
async importDataFromJson(jsonData: string): Promise<
⋮----
// Parse and validate the JSON data
⋮----
// Use the top-level isImportData function
⋮----
/**
     * Import sites and settings into database.
     * Database operation that persists the imported data.
     */
async persistImportedData(sites: ImportSite[], settings: Record<string, string>): Promise<void>
⋮----
// Use executeTransaction for atomic multi-table operation
⋮----
// Clear existing data using internal methods
⋮----
// Import sites using bulk insert
⋮----
// Import monitors and history
⋮----
// Import settings using internal method
⋮----
/**
     * Import monitors with their history for all sites.
     * Private helper method for monitor data persistence.
     */
private async importMonitorsWithHistory(db: Database, sites: ImportSite[]): Promise<void>
⋮----
// Create monitors using the async bulkCreate method
⋮----
// Import history for the created monitors
⋮----
// Continue with other sites even if one fails
⋮----
/**
     * Import history for created monitors by matching with original monitors.
     * Private helper method for history data persistence.
     */
private importHistoryForMonitors(
        db: Database,
        createdMonitors: Site["monitors"],
        originalMonitors: Site["monitors"]
): void
⋮----
// Find the original monitor with matching properties to get its history
⋮----
/**
     * Import history for a specific monitor.
     * Private helper method for history data persistence.
     */
private importMonitorHistory(db: Database, monitorId: number, history: StatusHistory[]): void
⋮----
"" // No details available in import data
⋮----
/**
 * Orchestrates the complete data import/export process.
 * Coordinates data operations with side effects.
 */
export class DataImportExportOrchestrator {
⋮----
constructor(dataImportExportService: DataImportExportService)
/**
     * Export all application data.
     * Coordinates the complete export process.
     */
async exportData(): Promise<string>
/**
     * Import data and reload application state.
     * Coordinates the complete import process including cache refresh.
     */
async importData(
        jsonData: string,
        siteCache: SiteCacheInterface,
        onSitesReloaded: () => Promise<void>
): Promise<
⋮----
// Parse the import data
⋮----
// Persist to database
⋮----
// Clear cache and reload sites
</file>

<file path="electron/managers/SiteManager.ts">
/**
 * Site management coordinator for CRUD operations and cache synchronization.
 *
 * @remarks
 * The SiteManager serves as the primary interface for all site-related operations,
 * providing a unified API for site creation, updates, deletion, and monitoring
 * coordination. It maintains an in-memory cache for performance while ensuring
 * data consistency with the underlying database through transactional operations.
 *
 * Key responsibilities:
 * - **Site CRUD Operations**: Create, read, update, and delete site configurations
 * - **Cache Management**: Maintain synchronized in-memory cache for performance
 * - **Monitor Integration**: Coordinate with MonitorManager for monitoring operations
 * - **Event Communication**: Emit typed events for frontend and internal coordination
 * - **Data Persistence**: Ensure atomic database operations with transaction safety
 * - **Error Handling**: Provide comprehensive error handling and recovery mechanisms
 *
 * The manager uses dependency injection for testability and follows the repository
 * pattern for data access. All operations are designed to be atomic and maintain
 * data consistency across cache and database layers.
 *
 * @example
 * ```typescript
 * const siteManager = new SiteManager({
 *   siteRepository,
 *   monitorRepository,
 *   historyRepository,
 *   databaseService,
 *   eventEmitter,
 *   monitoringOperations
 * });
 *
 * // Add a new site
 * const site = await siteManager.addSite({
 *   identifier: "site_123",
 *   name: "My Website",
 *   monitors: [...],
 *   monitoring: true
 * });
 * ```
 *
 * @packageDocumentation
 */
import { UptimeEvents, TypedEventBus } from "../events/index";
import { SiteRepository, MonitorRepository, HistoryRepository, DatabaseService } from "../services/index";
import { Site } from "../types";
import { SiteCacheInterface, SiteCache } from "../utils/database/interfaces";
import {
    SiteWritingOrchestrator,
    createSiteWritingOrchestrator,
    createSiteRepositoryService,
    SiteRepositoryService,
    monitorLogger as logger,
} from "../utils";
import { configurationManager } from "../managers/index";
/**
 * Combined events interface for SiteManager.
 *
 * @remarks
 * Supports all uptime monitoring events for comprehensive event communication
 * between the SiteManager and other system components.
 */
type SiteManagerEvents = UptimeEvents;
/**
 * Interface for monitoring operations integration.
 *
 * @remarks
 * Defines the contract for monitoring operations that can be performed
 * in coordination with site management. This allows loose coupling between
 * the SiteManager and MonitorManager while enabling coordinated operations.
 */
export interface IMonitoringOperations {
    /** Start monitoring for a specific site and monitor */
    startMonitoringForSite: (identifier: string, monitorId: string) => Promise<boolean>;
    /** Stop monitoring for a specific site and monitor */
    stopMonitoringForSite: (identifier: string, monitorId: string) => Promise<boolean>;
    /** Update the global history limit setting */
    setHistoryLimit: (limit: number) => Promise<void>;
    /** Set up monitoring for newly created monitors */
    setupNewMonitors: (site: Site, newMonitorIds: string[]) => Promise<void>;
}
⋮----
/** Start monitoring for a specific site and monitor */
⋮----
/** Stop monitoring for a specific site and monitor */
⋮----
/** Update the global history limit setting */
⋮----
/** Set up monitoring for newly created monitors */
⋮----
/**
 * Dependency injection configuration for SiteManager.
 *
 * @remarks
 * Provides all required dependencies for SiteManager operation, including
 * repository services, database access, event communication, and optional
 * monitoring integration for coordinated operations.
 */
export interface SiteManagerDependencies {
    /** Site repository for database operations */
    siteRepository: SiteRepository;
    /** Monitor repository for monitor-related operations */
    monitorRepository: MonitorRepository;
    /** History repository for status history management */
    historyRepository: HistoryRepository;
    /** Database service for transaction management */
    databaseService: DatabaseService;
    /** Event emitter for system-wide communication */
    eventEmitter: TypedEventBus<SiteManagerEvents>;
    /** Optional MonitorManager dependency for coordinated operations */
    monitoringOperations?: IMonitoringOperations;
}
⋮----
/** Site repository for database operations */
⋮----
/** Monitor repository for monitor-related operations */
⋮----
/** History repository for status history management */
⋮----
/** Database service for transaction management */
⋮----
/** Event emitter for system-wide communication */
⋮----
/** Optional MonitorManager dependency for coordinated operations */
⋮----
/**
 * Manages site operations and maintains in-memory cache.
 *
 * @remarks
 * The SiteManager is the central coordinator for all site-related operations
 * in the uptime monitoring system. It provides a high-level API that abstracts
 * the complexity of database operations, cache management, and cross-component
 * coordination while ensuring data consistency and performance.
 *
 * The manager maintains a synchronized in-memory cache of all sites for fast
 * access patterns while ensuring all mutations go through proper database
 * transactions. Event emission keeps other system components informed of
 * site changes and enables reactive UI updates.
 */
export class SiteManager {
⋮----
/**
     * Create a new SiteManager instance.
     *
     * @param dependencies - Required dependencies for site management operations
     *
     * @remarks
     * Initializes the SiteManager with all required dependencies including repositories,
     * database service, event emitter, and optional monitoring operations. Creates
     * internal service orchestrators for coordinated operations and sets up the
     * in-memory cache for performance optimization.
     */
constructor(dependencies: SiteManagerDependencies)
⋮----
// Create the new service-based orchestrators
⋮----
/**
     * Initialize the SiteManager by loading all sites into cache.
     * This method should be called during application startup.
     */
public async initialize(): Promise<void>
/**
     * Get all sites from database with full monitor and history data.
     *
     * @returns Promise resolving to array of complete site objects
     *
     * @remarks
     * Retrieves all sites from the database including their associated monitors
     * and status history. This operation also updates the cache to ensure it
     * stays synchronized with the database. Use this method when you need
     * guaranteed fresh data or during cache refresh operations.
     *
     * @example
     * ```typescript
     * const allSites = await siteManager.getSites();
     * console.log(`Found ${allSites.length} sites`);
     * ```
     */
public async getSites(): Promise<Site[]>
⋮----
// Keep cache synchronized with database
⋮----
/**
     * Get sites from in-memory cache for fast access.
     *
     * @returns The current site cache instance
     *
     * @remarks
     * Returns the in-memory cache containing all sites for high-performance
     * access patterns. The cache is automatically synchronized with database
     * changes through event handling. Use this for internal operations and
     * when performance is critical.
     *
     * Internal use only - external components should use getSites() for
     * guaranteed fresh data or subscribe to cache update events.
     */
public getSitesFromCache(): Site[]
/**
     * Get the in-memory sites cache (for internal use by other managers).
     */
public getSitesCache(): SiteCacheInterface
/**
     * Add a new site to the database and cache.
     */
public async addSite(siteData: Site): Promise<Site>
⋮----
// Business validation
⋮----
// Use the new service-based approach to add site to database
⋮----
// Add to in-memory cache
⋮----
// Emit typed site added event
⋮----
/**
     * Business logic: Validate site data according to business rules.
     */
private validateSite(site: Site): void
/**
     * Remove a site from the database and cache.
     */
public async removeSite(identifier: string): Promise<boolean>
⋮----
// Get site name before removal for event (already removed from cache by service)
⋮----
// Emit typed site removed event
⋮----
/**
     * Create monitoring configuration for site operations.
     */
private createMonitoringConfig()
/**
     * Update a site in the database and cache.
     */
public async updateSite(identifier: string, updates: Partial<Site>): Promise<Site>
⋮----
// Get the current site before updating for event data
⋮----
// Create full monitoring configuration
⋮----
// Use the service with proper monitoring integration
⋮----
// Refresh the entire cache from database to ensure we have the latest monitor IDs
// This is especially important when monitors are added/updated
⋮----
// Get the refreshed site for the event
⋮----
// Emit typed site updated event
⋮----
/**
     * Update the sites cache with new data.
     */
public async updateSitesCache(sites: Site[]): Promise<void>
⋮----
// Emit cache updated event
⋮----
/**
     * Get a specific site from cache with smart background loading.
     */
public getSiteFromCache(identifier: string): Site | undefined
⋮----
// Emit cache miss event
⋮----
// Trigger background loading without blocking
⋮----
/**
     * Load a site in the background and update cache.
     */
private async loadSiteInBackground(identifier: string): Promise<void>
⋮----
// Silent failure for background operations - don't throw
⋮----
/**
     * Remove a monitor from a site.
     */
public async removeMonitor(siteIdentifier: string, monitorId: string): Promise<boolean>
⋮----
// Remove the monitor from the database using transaction
⋮----
// Refresh the cache by getting all sites (to ensure proper site structure)
⋮----
// Update cache
⋮----
// Find the updated site for the event
⋮----
// Emit internal site updated event
⋮----
/**
     * Execute monitor deletion.
     */
private async executeMonitorDeletion(monitorId: string): Promise<boolean>
⋮----
// MonitorRepository.delete() already handles its own transaction,
// so we don't need to wrap it in another transaction
</file>

<file path="electron/services/database/HistoryRepository.ts">
import { Database } from "node-sqlite3-wasm";
import { isDev } from "../../electronUtils";
import { StatusHistory } from "../../types";
import { logger, withDatabaseOperation } from "../../utils/index";
import { DatabaseService } from "./DatabaseService";
import {
    addHistoryEntry,
    deleteAllHistory,
    deleteHistoryByMonitorId,
    findHistoryByMonitorId,
    getHistoryCount,
    getLatestHistoryEntry,
    pruneHistoryForMonitor,
} from "./utils";
/**
 * Repository for managing history data persistence.
 * Handles CRUD operations for monitor history in the database.
 */
export class HistoryRepository {
⋮----
constructor()
/**
     * Get the database instance.
     */
private getDb(): Database
/**
     * Find all history entries for a specific monitor.
     */
public async findByMonitorId(monitorId: string): Promise<StatusHistory[]>
⋮----
// eslint-disable-next-line @typescript-eslint/require-await
⋮----
/**
     * Add a new history entry for a monitor.
     */
public async addEntry(monitorId: string, entry: StatusHistory, details?: string): Promise<void>
/**
     * Delete history entries for a specific monitor.
     */
public async deleteByMonitorId(monitorId: string): Promise<void>
/**
     * Prune old history entries for a monitor, keeping only the most recent entries.
     */
public async pruneHistory(monitorId: string, limit: number): Promise<void>
/**
     * Prune old history entries for all monitors.
     */
public async pruneAllHistory(limit: number): Promise<void>
⋮----
// Use executeTransaction for atomic multi-monitor operation
⋮----
/**
     * Get the count of history entries for a monitor.
     */
public getHistoryCount(monitorId: string): number
/**
     * Clear all history from the database.
     */
public deleteAll(): void
/**
     * Internal method to clear all history from the database within an existing transaction.
     * Use this method when you're already within a transaction context.
     */
public deleteAllInternal(db: Database): void
/**
     * Internal method to delete history entries for a specific monitor within an existing transaction.
     * Use this method when you're already within a transaction context.
     */
public deleteByMonitorIdInternal(db: Database, monitorId: string): void
/**
     * Internal method to add a new history entry for a monitor within an existing transaction.
     * Use this method when you're already within a transaction context.
     */
public addEntryInternal(db: Database, monitorId: string, entry: StatusHistory, details?: string): void
/**
     * Internal method to prune old history entries for all monitors within an existing transaction.
     * Use this method when you're already within a transaction context.
     */
public pruneAllHistoryInternal(db: Database, limit: number): void
⋮----
// Get all monitor IDs
⋮----
// Prune history for each monitor
⋮----
/**
     * Get the most recent history entry for a monitor.
     */
public getLatestEntry(monitorId: string): StatusHistory | undefined
/**
     * Bulk insert history entries (for import functionality).
     */
public async bulkInsert(
        monitorId: string,
        historyEntries: (StatusHistory & { details?: string })[]
): Promise<void>
⋮----
// Use executeTransaction for atomic bulk insert operation
⋮----
// Prepare the statement once for better performance
⋮----
/**
     * Internal method to prune old history entries for a specific monitor within an existing transaction.
     * Use this method when you're already within a transaction context.
     */
public pruneHistoryInternal(db: Database, monitorId: string, limit: number): void
</file>

<file path="electron/utils/database/SiteRepositoryService.ts">
/**
 * Site repository service for data operations and dependency injection.
 *
 * @remarks
 * Provides a testable, dependency-injected service layer for site data operations,
 * separating business logic from infrastructure concerns. Designed with the repository
 * pattern and service layer architecture to enable comprehensive testing and
 * maintainable code organization.
 *
 * Key features:
 * - **Dependency Injection**: Fully configurable with injected repositories and services
 * - **Separation of Concerns**: Pure data operations separated from side effects
 * - **Comprehensive Testing**: Designed for easy mocking and unit testing
 * - **Error Handling**: Standardized error handling with proper logging and types
 * - **Event Integration**: Coordinated event emission for reactive system behavior
 * - **Transaction Safety**: All operations use proper database transactions
 *
 * The service provides both data operations (SiteRepositoryService) and orchestration
 * logic (SiteLoadingOrchestrator) to handle complex workflows while maintaining
 * clean separation between pure functions and side effects.
 *
 * @example
 * ```typescript
 * const service = new SiteRepositoryService({
 *   repositories: { site, monitor, history, settings },
 *   logger,
 *   eventEmitter
 * });
 *
 * const sites = await service.getSitesFromDatabase();
 * ```
 *
 * @packageDocumentation
 */
import { UptimeEvents, TypedEventBus } from "../../events/index";
import { SiteRepository, MonitorRepository, HistoryRepository, SettingsRepository } from "../../services/index";
import { Site } from "../../types";
import { Logger, SiteCacheInterface, SiteLoadingConfig, MonitoringConfig, SiteLoadingError } from "./interfaces";
/**
 * Service for handling site repository operations.
 *
 * @remarks
 * Provides pure data operations for site management without side effects,
 * enabling easy testing and clean separation of concerns. All methods are
 * designed to be deterministic and focused on data transformation and
 * retrieval operations.
 *
 * The service abstracts repository complexity and provides a clean interface
 * for higher-level components while maintaining transaction safety and
 * comprehensive error handling throughout all operations.
 */
export class SiteRepositoryService {
⋮----
/**
     * Create a new SiteRepositoryService instance.
     *
     * @param config - Configuration with required dependencies
     *
     * @remarks
     * Initializes the service with injected dependencies for repositories,
     * logging, and event communication. All dependencies are required
     * for proper operation and comprehensive functionality.
     */
constructor(config: SiteLoadingConfig)
/**
     * Get sites from database with their monitors and history.
     *
     * @returns Promise resolving to array of complete site objects
     *
     * @throws SiteLoadingError When database operation fails
     *
     * @remarks
     * Performs a complete site loading operation including all associated
     * monitors and their status history. This is a pure data operation
     * without side effects, making it ideal for testing and composition.
     *
     * The operation builds complete site objects by fetching site metadata,
     * associated monitors, and historical data in an efficient manner while
     * maintaining proper error handling throughout the process.
     */
async getSitesFromDatabase(): Promise<Site[]>
/**
     * Load sites into cache.
     * Pure data operation that populates the cache.
     */
async loadSitesIntoCache(siteCache: SiteCacheInterface): Promise<void>
⋮----
// Emit typed error event
⋮----
/**
     * Load history limit setting from database.
     * Pure data operation without side effects.
     */
async getHistoryLimitSetting(): Promise<number | undefined>
/**
     * Apply history limit setting.
     * Side effect operation separated from data loading.
     */
async applyHistoryLimitSetting(monitoringConfig: MonitoringConfig): Promise<void>
/**
     * Build a site object with monitors and history.
     * Private helper method for data construction.
     */
private async buildSiteWithMonitorsAndHistory(siteRow: {
        identifier: string;
        name?: string | undefined;
}): Promise<Site>
⋮----
// Load history for each monitor
⋮----
monitoring: true, // Default to monitoring enabled
⋮----
name: siteRow.name ?? "Unnamed Site", // Provide default name
⋮----
/**
 * Orchestrates the complete site loading process.
 * Coordinates data loading with side effects.
 */
export class SiteLoadingOrchestrator {
⋮----
constructor(siteRepositoryService: SiteRepositoryService)
/**
     * Load sites from database and start monitoring.
     * Coordinates all aspects of site loading process.
     */
async loadSitesFromDatabase(
        siteCache: SiteCacheInterface,
        monitoringConfig: MonitoringConfig
): Promise<
⋮----
// Load sites data
⋮----
// Apply settings
⋮----
// Note: Auto-start monitoring is now handled by MonitorManager.setupSiteForMonitoring()
// No need to explicitly start monitoring here as it's handled during site setup
</file>

<file path="electron/services/database/MonitorRepository.ts">
/**
 * Database repository for monitor persistence and management.
 * Handles CRUD operations for site monitoring configurations.
 */
import { Database } from "node-sqlite3-wasm";
import { isDev } from "../../electronUtils";
import { Site } from "../../types";
import { logger, withDatabaseOperation } from "../../utils/index";
import { DatabaseService } from "./DatabaseService";
import {
    addBooleanField,
    addNumberField,
    addStringField,
    buildMonitorParameters,
    convertDateForDb,
    DbValue,
    rowToMonitor,
    generateSqlParameters,
    mapMonitorToRow,
} from "./utils";
/**
 * Repository for managing monitor data persistence.
 * Handles CRUD operations for monitors in the database.
 */
export class MonitorRepository {
⋮----
constructor()
/**
     * Get the database instance.
     */
private getDb(): Database
/**
     * Find all monitors for a specific site.
     */
public async findBySiteIdentifier(siteIdentifier: string): Promise<Site["monitors"]>
⋮----
// eslint-disable-next-line @typescript-eslint/require-await
⋮----
/**
     * Find a monitor by its identifier with resilient error handling.
     */
public async findByIdentifier(monitorId: string): Promise<Site["monitors"][0] | undefined>
⋮----
// Wrap synchronous operation in Promise to make it truly async
⋮----
/**
     * Create a new monitor and return its ID.
     * Uses transactions to ensure atomicity.
     */
public async create(siteIdentifier: string, monitor: Omit<Site["monitors"][0], "id">): Promise<string>
⋮----
// Generate dynamic SQL and parameters
⋮----
/**
     * Internal method to create a monitor within an existing transaction.
     * Use this method when you're already within a transaction context.
     */
public createInternal(db: Database, siteIdentifier: string, monitor: Omit<Site["monitors"][0], "id">): string
⋮----
// Generate dynamic SQL and parameters
⋮----
/**
     * Update an existing monitor.
     * Uses transactions to ensure atomicity.
     */
public async update(monitorId: string, monitor: Partial<Site["monitors"][0]>): Promise<void>
⋮----
// Build dynamic SQL based on provided fields to avoid overwriting with defaults
⋮----
// Add fields using helper methods
⋮----
// monitor.responseTime is always a number, so no need for unnecessary conditional
⋮----
/**
     * Update an existing monitor (internal version for use within existing transactions).
     * Does not create its own transaction.
     */
public updateInternal(db: Database, monitorId: string, monitor: Partial<Site["monitors"][0]>): void
⋮----
// Use dynamic row mapping to convert camelCase to snake_case
⋮----
// Only update fields that are actually provided and are primitive types
⋮----
// Skip 'enabled' field if monitoring state wasn't provided in the original monitor object
// This prevents status updates from accidentally disabling monitoring
⋮----
// Ensure we only bind primitive types that SQLite can handle
⋮----
/**
     * Delete a monitor and its history.
     * Uses a transaction to ensure atomicity.
     */
public async delete(monitorId: string): Promise<boolean>
/**
     * Internal method to delete a monitor and its history within an existing transaction.
     * This method should be called from within a database transaction.
     */
public deleteInternal(db: Database, monitorId: string): boolean
⋮----
// Delete history first (foreign key constraint)
⋮----
// Delete the monitor
⋮----
/**
     * Delete all monitors for a specific site.
     * Uses a transaction to ensure atomicity.
     */
public async deleteBySiteIdentifier(siteIdentifier: string): Promise<void>
/**
     * Internal method to delete all monitors for a specific site within an existing transaction.
     * This method should be called from within a database transaction.
     */
public deleteBySiteIdentifierInternal(db: Database, siteIdentifier: string): void
⋮----
// Get all monitor IDs for this site
⋮----
// Delete history for all monitors
⋮----
// Delete all monitors for this site
⋮----
/**
     * Get all monitor IDs.
     */
public getAllMonitorIds():
/**
     * Clear all monitors from the database.
     * Uses transactions to ensure atomicity.
     */
public async deleteAll(): Promise<void>
/**
     * Internal method to clear all monitors from the database within an existing transaction.
     * Use this method when you're already within a transaction context.
     */
public deleteAllInternal(db: Database): void
/**
     * Bulk create monitors (for import functionality).
     * Returns the created monitor with their new IDs.
     * Uses transactions to ensure atomicity.
     */
public async bulkCreate(siteIdentifier: string, monitors: Site["monitors"][0][]): Promise<Site["monitors"][0][]>
⋮----
// Use executeTransaction for atomic bulk create operation
⋮----
// Use RETURNING clause to get the ID directly from the insert
</file>

<file path="electron/services/database/SiteRepository.ts">
import { Database } from "node-sqlite3-wasm";
import { Site } from "../../types";
import { logger, withDatabaseOperation } from "../../utils/index";
import { DatabaseService } from "./DatabaseService";
import { HistoryRepository } from "./HistoryRepository";
import { MonitorRepository } from "./MonitorRepository";
/**
 * Repository for managing site data persistence.
 * Handles CRUD operations for sites in the database.
 */
export class SiteRepository {
⋮----
constructor()
/**
     * Get the database instance.
     */
private getDb(): Database
/**
     * Get all sites from the database (without monitors).
     */
public async findAll(): Promise<
        { identifier: string; name?: string | undefined; monitoring?: boolean | undefined }[]
    > {
        // eslint-disable-next-line @typescript-eslint/require-await
return withDatabaseOperation(async () =>
⋮----
// eslint-disable-next-line @typescript-eslint/require-await
⋮----
/**
     * Find a site by its identifier with resilient error handling.
     */
public async findByIdentifier(
        identifier: string
): Promise<
/**
     * Get a complete site by identifier with monitors and history.
     * This method returns a full Site object including all monitors and their history.
     */
public async getByIdentifier(identifier: string): Promise<Site | undefined>
⋮----
// Fetch monitors for this site
⋮----
// Load history for each monitor
⋮----
monitoring: siteRow.monitoring ?? true, // Default to true if not set
⋮----
/**
     * Create or update a site in the database.
     */
public async upsert(site: Pick<Site, "identifier" | "name" | "monitoring">): Promise<void>
/**
     * Internal method to create or update a site within an existing transaction.
     * Use this method when you're already within a transaction context.
     */
public upsertInternal(db: Database, site: Pick<Site, "identifier" | "name" | "monitoring">): void
⋮----
// Ensure all values are valid for SQLite
const identifier = site.identifier || ""; // Fallback for undefined/empty identifier
const name = site.name || "Unnamed Site"; // Fallback for undefined/empty name
const monitoring = site.monitoring ? 1 : 0; // Convert boolean to integer
⋮----
/**
     * Delete a site from the database.
     */
public async delete(identifier: string): Promise<boolean>
/**
     * Delete a site from the database (internal version for use within existing transactions).
     * @param db - Database connection
     * @param identifier - Site identifier
     * @returns boolean indicating if the site was deleted
     */
public deleteInternal(db: Database, identifier: string): boolean
/**
     * Check if a site exists by identifier.
     */
public async exists(identifier: string): Promise<boolean>
/**
     * Export all sites for backup/import functionality.
     */
public exportAll():
/**
     * Clear all sites from the database.
     */
public async deleteAll(): Promise<void>
/**
     * Internal method to clear all sites from the database within an existing transaction.
     * Use this method when you're already within a transaction context.
     */
public deleteAllInternal(db: Database): void
/**
     * Bulk insert sites (for import functionality).
     * Uses executeTransaction for atomic operation.
     */
public async bulkInsert(
        sites: { identifier: string; name?: string | undefined; monitoring?: boolean | undefined }[]
): Promise<void>
/**
     * Internal method to bulk insert sites within an existing transaction.
     * Use this method when you're already within a transaction context.
     */
public bulkInsertInternal(
        db: Database,
        sites: { identifier: string; name?: string | undefined; monitoring?: boolean | undefined }[]
): void
⋮----
// Prepare the statement once for better performance
⋮----
// Convert monitoring boolean to SQLite integer
let monitoringValue = 1; // Default to true (1) if not specified
</file>

<file path="electron/utils/monitoring/monitorStatusChecker.ts">
/**
 * Monitor status checking utilities for individual monitor health verification.
 *
 * @remarks
 * Provides comprehensive monitor checking capabilities with automatic status updates,
 * history tracking, and event emission. Extracted from UptimeMonitor for improved
 * modularity and maintainability with full transaction safety and error handling.
 *
 * Key features:
 * - **Individual Monitor Checks**: Perform health checks on specific monitors
 * - **Automatic Status Updates**: Update monitor status in database with transactions
 * - **History Tracking**: Maintain detailed history with configurable limits
 * - **Event Emission**: Emit typed events for status changes and notifications
 * - **Error Resilience**: Comprehensive error handling with proper logging
 * - **Cache Synchronization**: Keep in-memory cache synchronized with database
 *
 * @example
 * ```typescript
 * const config: MonitorCheckConfig = {
 *   repositories: { monitor, history, site },
 *   databaseService,
 *   sites: siteCache,
 *   eventEmitter,
 *   logger,
 *   historyLimit: 500
 * };
 *
 * const result = await checkMonitor(config, site, "monitor_123");
 * if (result) {
 *   console.log(`Monitor ${result.monitorId} is ${result.status}`);
 * }
 * ```
 *
 * @packageDocumentation
 */
import { UptimeEvents, TypedEventBus } from "../../events/index";
import {
    HistoryRepository,
    MonitorRepository,
    SiteRepository,
    DatabaseService,
    MonitorFactory,
} from "../../services/index";
import { Site, StatusHistory, StatusUpdate } from "../../types";
import { SiteCacheInterface } from "../database/interfaces";
import { withDatabaseOperation } from "../operationalHooks";
/**
 * Logger interface for monitor checking operations.
 *
 * @remarks
 * Standardized logging interface used throughout monitor checking utilities
 * to ensure consistent logging patterns and error reporting.
 */
interface Logger {
    debug: (message: string, ...args: unknown[]) => void;
    error: (message: string, error?: unknown, ...args: unknown[]) => void;
    info: (message: string, ...args: unknown[]) => void;
    warn: (message: string, ...args: unknown[]) => void;
}
/**
 * Configuration object for monitor checking functions.
 *
 * @remarks
 * Provides all necessary dependencies for monitor checking operations,
 * including repository access, database services, cache management,
 * and event emission capabilities. Designed for dependency injection
 * and comprehensive testing support.
 */
export interface MonitorCheckConfig {
    /** Repository services for database operations */
    repositories: {
        history: HistoryRepository;
        monitor: MonitorRepository;
        site: SiteRepository;
    };
    /** Database service for transaction management */
    databaseService: DatabaseService;
    /** In-memory site cache for performance optimization */
    sites: SiteCacheInterface;
    /** Typed event bus for high-level event communication */
    eventEmitter: TypedEventBus<UptimeEvents>;
    /** Logger instance for operation tracking */
    logger: Logger;
    /** Maximum number of history entries to retain per monitor */
    historyLimit: number;
}
⋮----
/** Repository services for database operations */
⋮----
/** Database service for transaction management */
⋮----
/** In-memory site cache for performance optimization */
⋮----
/** Typed event bus for high-level event communication */
⋮----
/** Logger instance for operation tracking */
⋮----
/** Maximum number of history entries to retain per monitor */
⋮----
/**
 * Check a specific monitor and update its status.
 *
 * @param config - Configuration object with required dependencies
 * @param site - Site containing the monitor to check
 * @param monitorId - ID of the monitor to check
 * @param isManualCheck - Whether this is a manual check (preserves paused state)
 * @returns Promise resolving to status update result or undefined if error occurs
 *
 * @remarks
 * Performs a comprehensive health check on the specified monitor, including:
 * - Monitor validation and existence verification
 * - Health check execution using appropriate monitor service
 * - Status comparison and change detection
 * - Database updates with transaction safety
 * - History tracking with automatic pruning
 * - Event emission for status changes and notifications
 * - Cache synchronization for performance
 *
 * For manual checks on paused monitors, the monitor status remains "paused"
 * but the actual check result is recorded in history for diagnostic purposes.
 *
 * The function is designed to be resilient to errors and will return undefined
 * if critical failures occur, while logging appropriate error messages for debugging.
 *
 * @example
 * ```typescript
 * const result = await checkMonitor(config, site, "monitor_123");
 * if (result) {
 *   console.log(`Monitor status: ${result.status}`);
 *   console.log(`Response time: ${result.responseTime}ms`);
 * }
 * ```
 */
export async function checkMonitor(
    config: MonitorCheckConfig,
    site: Site,
    monitorId: string,
    isManualCheck = false
): Promise<StatusUpdate | undefined>
⋮----
// Ensure monitor.id is present and valid before proceeding
⋮----
// Use the monitoring service to perform the check
const getCheckResult = async () =>
⋮----
// For manual checks, preserve the paused state but still record history
⋮----
// Update monitor with results (preserve paused status for manual checks)
⋮----
// Add to history (record the actual check result, not the preserved status)
⋮----
status: checkResult.status, // Always record the actual check result
⋮----
// Use operational hooks for database operations
⋮----
// Add history entry using internal method to avoid nested transactions
⋮----
// Smart history pruning: Only prune when necessary to avoid performance overhead
⋮----
// Use a buffer strategy: only prune when we exceed limit + buffer
// This reduces frequency of pruning operations while maintaining reasonable limits
const bufferSize = Math.max(Math.floor(config.historyLimit * 0.2), 5); // 20% buffer, min 5 entries
⋮----
// Get current count for this monitor (lightweight operation)
⋮----
// Update monitor with new status using internal method (we're already in a transaction)
⋮----
status: monitor.status, // This preserves paused status for manual checks
⋮----
// We just set lastChecked to 'now', so it's definitely defined
⋮----
// Convert Date object to timestamp for database storage
⋮----
return undefined; // Return early if database operations fail
⋮----
// Fetch fresh site data from database to ensure we have the latest history and monitor state
⋮----
// Update the in-memory cache with fresh data
⋮----
// Emit StatusUpdate as a typed event instead of old emit pattern
⋮----
// Emit typed monitor status changed event
⋮----
// Emit monitor state change events with proper typing
⋮----
/**
 * Check a site's monitor manually.
 *
 * @param config - Configuration object with required dependencies
 * @param identifier - Site identifier
 * @param monitorId - Optional monitor ID, uses first monitor if not provided
 * @returns Promise\<StatusUpdate | undefined\> - Status update result or undefined if error
 */
export async function checkSiteManually(
    config: MonitorCheckConfig,
    identifier: string,
    monitorId?: string
): Promise<StatusUpdate | undefined>
⋮----
// If no monitorId provided, use the first monitor's ID
⋮----
// Validate the monitor exists
⋮----
const result = await checkMonitor(config, site, targetMonitorId, true); // Mark as manual check
</file>

</files>
