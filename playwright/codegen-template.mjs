/**
 * Custom Playwright codegen template for better lint compliance
 *
 * This template automatically formats generated tests to match our lint
 * standards:
 *
 * - Proper describe blocks
 * - Semantic locators preferred
 * - Clean test titles
 * - TypeScript best practices
 * - No conditional logic in tests
 * - No raw locators
 */

// Template for generated test files
const testTemplate = `/**
 * Generated UI test for {{testName}}
 *
 * @remarks Auto-generated by Playwright codegen with custom template
 * @file Generated Playwright test
 */

import { test, expect } from "@playwright/test";

test.describe("{{testName}}", () => {
    test("{{testTitle}}", async ({ page }) => {
        {{testBody}}
    });
});
`;

// Comprehensive locator transformations for better semantic usage
/**
 * Maps raw Playwright locator strings to their semantic alternatives for
 * improved readability, maintainability, and lint compliance in generated test
 * code.
 *
 * @remarks
 * This object is used by the codegen template to automatically replace
 * non-semantic or brittle locators (e.g., CSS selectors, data-testid, roles)
 * with preferred semantic queries such as getByRole or getByTestId.
 *
 * @example // Converts: locator("button") => getByRole("button") // Converts:
 * locator("[data-testid='submit']") => getByTestId("submit")
 */
const locatorTransforms = {
    // Basic element transformations
    'locator("button")': 'getByRole("button")',
    'locator("input[type=text]")': 'getByRole("textbox")',
    'locator("input[type=email]")': 'getByRole("textbox", { name: /email/i })',
    'locator("input[type=password]")':
        'getByRole("textbox", { name: /password/i })',
    'locator("input[type=url]")': 'getByRole("textbox", { name: /url/i })',
    'locator("input[type=search]")': 'getByRole("searchbox")',
    'locator("textarea")': 'getByRole("textbox")',
    'locator("select")': 'getByRole("combobox")',
    'locator("a")': 'getByRole("link")',
    'locator("h1")': 'getByRole("heading", { level: 1 })',
    'locator("h2")': 'getByRole("heading", { level: 2 })',
    'locator("h3")': 'getByRole("heading", { level: 3 })',
    'locator("h4")': 'getByRole("heading", { level: 4 })',
    'locator("h5")': 'getByRole("heading", { level: 5 })',
    'locator("h6")': 'getByRole("heading", { level: 6 })',
    'locator("nav")': 'getByRole("navigation")',
    'locator("main")': 'getByRole("main")',
    'locator("dialog")': 'getByRole("dialog")',
    'locator("article")': 'getByRole("article")',
    'locator("section")': 'getByRole("region")',
    'locator("aside")': 'getByRole("complementary")',
    'locator("header")': 'getByRole("banner")',
    'locator("footer")': 'getByRole("contentinfo")',

    // Role-based transformations
    'locator("[role=button]")': 'getByRole("button")',
    'locator("[role=textbox]")': 'getByRole("textbox")',
    'locator("[role=link]")': 'getByRole("link")',
    'locator("[role=dialog]")': 'getByRole("dialog")',
    'locator("[role=menu]")': 'getByRole("menu")',
    'locator("[role=menuitem]")': 'getByRole("menuitem")',
    'locator("[role=tab]")': 'getByRole("tab")',
    'locator("[role=tabpanel]")': 'getByRole("tabpanel")',
    'locator("[role=tablist]")': 'getByRole("tablist")',
    'locator("[role=listbox]")': 'getByRole("listbox")',
    'locator("[role=option]")': 'getByRole("option")',
    'locator("[role=checkbox]")': 'getByRole("checkbox")',
    'locator("[role=radio]")': 'getByRole("radio")',
    'locator("[role=slider]")': 'getByRole("slider")',
    'locator("[role=spinbutton]")': 'getByRole("spinbutton")',
    'locator("[role=progressbar]")': 'getByRole("progressbar")',
    'locator("[role=status]")': 'getByRole("status")',
    'locator("[role=alert]")': 'getByRole("alert")',
    'locator("[role=banner]")': 'getByRole("banner")',
    'locator("[role=main]")': 'getByRole("main")',
    'locator("[role=navigation]")': 'getByRole("navigation")',
    'locator("[role=contentinfo]")': 'getByRole("contentinfo")',
    'locator("[role=complementary]")': 'getByRole("complementary")',
    'locator("[role=search]")': 'getByRole("search")',

    // Test ID transformations
    "locator(\"[data-testid='": 'getByTestId("',
    'locator("[data-testid="': 'getByTestId("',

    // Common class-based selectors to semantic alternatives
    'locator(".btn")': 'getByRole("button")',
    'locator(".button")': 'getByRole("button")',
    'locator(".link")': 'getByRole("link")',
    'locator(".input")': 'getByRole("textbox")',
    'locator(".form-control")': 'getByRole("textbox")',

    // Body/html replacements (often problematic)
    'locator("body")': 'locator("body")', // Keep as is but add comment
    'locator("html")': 'locator("html")', // Keep as is but add comment
};

/**
 * Maps raw Playwright test titles to improved, lint-compliant versions.
 *
 * @remarks
 * This object is used to automatically transform generated test titles into
 * more descriptive and standardized forms, improving readability and
 * consistency in test code.
 *
 * @example // Converts: test("Test login") => test("should test login") //
 * Converts: test("Verify user creation") => test("should verify user
 * creation")
 */
const titleTransforms = {
    'test("should': 'test("should', // Already good
    'test("Test': 'test("should test',
    'test("Verify': 'test("should verify',
    'test("Check': 'test("should check',
    'test("Click': 'test("should click',
    'test("Navigate': 'test("should navigate',
    'test("Enter': 'test("should enter',
    'test("Select': 'test("should select',
    'test("Submit': 'test("should submit',
    'test("Upload': 'test("should upload',
    'test("Download': 'test("should download',
};

/**
 * Post-processing function to apply all transformations
 *
 * @param codegenOutput - The generated test code to transform
 *
 * @returns The transformed, lint-compliant test code
 */
function applyLintCompliantTransforms(codegenOutput) {
    let transformed = codegenOutput;

    // Batch locator transformations using a single regex and replacer
    const locatorKeys = Object.keys(locatorTransforms).map((k) =>
        k.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")
    );
    if (locatorKeys.length > 0) {
        const locatorRegex = new RegExp(locatorKeys.join("|"), "g");
        transformed = transformed.replace(
            locatorRegex,
            (match) => locatorTransforms[match] ?? match
        );
    }

    // Batch title transformations using a single regex and replacer
    const titleKeys = Object.keys(titleTransforms).map((k) =>
        k.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")
    );
    if (titleKeys.length > 0) {
        const titleRegex = new RegExp(titleKeys.join("|"), "g");
        transformed = transformed.replace(
            titleRegex,
            (match) => titleTransforms[match] ?? match
        );
    }

    // Add describe block if missing and wrap all top-level test cases
    if (
        !transformed.includes("test.describe(") &&
        transformed.includes("test(")
    ) {
        // Find all import statements
        const importRegex = /^import.*?;$/gm;
        let lastImportMatch;
        let match;
        while ((match = importRegex.exec(transformed)) !== null) {
            lastImportMatch = match;
        }

        // Find all top-level test cases
        const testCaseRegex = /^test\([^]*?=>\s*{[^]*?}\s*\);?/gm;
        const testCases = [];
        let testMatch;
        while ((testMatch = testCaseRegex.exec(transformed)) !== null) {
            testCases.push({
                start: testMatch.index,
                end: testCaseRegex.lastIndex,
                code: testMatch[0],
            });
        }

        // Remove all top-level test cases from transformed
        let codeWithoutTests = transformed;
        for (let i = testCases.length - 1; i >= 0; i--) {
            codeWithoutTests =
                codeWithoutTests.slice(0, testCases[i].start) +
                codeWithoutTests.slice(testCases[i].end);
        }

        // Determine describe block name
        const firstTestTitleMatch =
            testCases.length > 0
                ? testCases[0].code.match(/test\("([^"]+)"/)
                : null;
        const describeName = firstTestTitleMatch
            ? firstTestTitleMatch[1]
                  .replace(/^should\s+/, "")
                  .replace(/\s+/g, " ")
            : "Generated Test";

        // Insert describe block after last import
        let insertionIndex = lastImportMatch
            ? lastImportMatch.index + lastImportMatch[0].length
            : 0;
        const describeBlock =
            `\n\ntest.describe("${describeName}", () => {\n` +
            testCases.map((tc) => tc.code).join("\n\n") +
            `\n});\n`;

        transformed =
            codeWithoutTests.slice(0, insertionIndex) +
            describeBlock +
            codeWithoutTests.slice(insertionIndex);
    }

    /**
     * Replace 'networkidle' with 'domcontentloaded' for waitForLoadState.
     * Rationale: 'networkidle' can be unreliable in modern SPAs and may cause
     * flaky tests. 'domcontentloaded' is generally sufficient for UI readiness
     * and is more stable. To change this behavior, update the
     * NETWORK_IDLE_REPLACEMENT constant below.
     */
    const NETWORK_IDLE_REPLACEMENT = "domcontentloaded";
    transformed = transformed.replace(
        /waitForLoadState\(['"]networkidle['"]\)/g,
        `waitForLoadState("${NETWORK_IDLE_REPLACEMENT}")`
    );

    // Add comments for body/html locators with consistent indentation
    transformed = transformed.replace(
        /^([ \t]*)page\.locator\(['"]body['"]\)/gm,
        (_, indent) =>
            `${indent}// TODO: Replace with semantic locator\n${indent}page.locator("body")`
    );
    transformed = transformed.replace(
        /^([ \t]*)page\.locator\(['"]html['"]\)/gm,
        (_, indent) =>
            `${indent}// TODO: Replace with semantic locator\n${indent}page.locator("html")`
    );

    return transformed;
}

export {
    testTemplate,
    locatorTransforms,
    titleTransforms,
    applyLintCompliantTransforms,
};
