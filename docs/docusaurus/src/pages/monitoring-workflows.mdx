---
title: Monitoring Workflows
description: Detailed monitoring workflows and processes for Uptime Watcher
---
{/* eslint-disable no-unused-vars,@eslint-community/eslint-comments/disable-enable-pair -- Layout component consumed by MDX JSX */}
import Layout from '@theme/Layout';
import Mermaid from '@theme/Mermaid';

export default function MonitoringWorkflows() {
  return (
    <Layout
      title="Monitoring Workflows"
      description="Detailed monitoring workflows and processes for Uptime Watcher"
    >
      <div className="container margin-vert--lg">
        <div className="row">
          <div className="col">

# Monitoring Workflows

This page showcases the various monitoring workflows and processes used in Uptime Watcher.

## Site Monitoring Lifecycle

This flowchart shows the complete lifecycle of monitoring a site from creation to deletion:

<Mermaid value={`flowchart TD
    Start([User Wants to Monitor Site]) --> Input[Enter Site Details]
    Input --> Validate{Validate Input}
    Validate -->|Invalid| Error[Show Error Message]
    Error --> Input
    Validate -->|Valid| Create[Create Site Record]
    Create --> Configure[Configure Monitor Settings]
    Configure --> Schedule[Schedule Monitoring]

    Schedule --> Monitor{Monitor Site}
    Monitor -->|Success| LogSuccess[Log Success Result]
    Monitor -->|Failure| LogFailure[Log Failure Result]
    Monitor -->|Timeout| LogTimeout[Log Timeout Result]

    LogSuccess --> Store[Store in Database]
    LogFailure --> Store
    LogTimeout --> Store

    Store --> Notify{Send Notifications?}
    Notify -->|Yes| SendNotification[Send Alert/Email]
    Notify -->|No| Wait[Wait for Next Interval]
    SendNotification --> Wait

    Wait --> Check{Site Still Active?}
    Check -->|Yes| Monitor
    Check -->|No| Cleanup[Cleanup Resources]
    Cleanup --> End([Monitoring Stopped])

    %% Styling
    classDef startEnd fill:#e1f5fe,stroke:#0277bd,color:#000000
    classDef process fill:#e8f5e8,stroke:#2e7d32,color:#000000
    classDef decision fill:#fff3e0,stroke:#ef6c00,color:#000000
    classDef error fill:#ffebee,stroke:#c62828,color:#000000
    classDef data fill:#f3e5f5,stroke:#7b1fa2,color:#000000

    class Start,End startEnd
    class Input,Create,Configure,Schedule,LogSuccess,LogFailure,LogTimeout,SendNotification,Wait,Cleanup process
    class Validate,Monitor,Notify,Check decision
    class Error error
    class Store data`} />

## Monitor Type Decision Tree

This diagram helps users choose the appropriate monitor type for their needs:

<Mermaid value={`flowchart TD
    Start([What do you want to monitor?]) --> Target{Primary target}

    Target -->|Website or API| Web[Web Property]
    Target -->|Network / Infrastructure| Infra[Infrastructure Service]
    Target -->|Domains & Edge| Domain[Domain / CDN]
    Target -->|Data Pipelines| Data[Data Pipeline]
    Target -->|Realtime Channel| Realtime[Realtime Channel]

    Web --> WebAspect{Key signal}
    WebAspect -->|Availability & latency| HttpGeneral[HTTP (Website/API)]
    WebAspect -->|Exact status code| HttpStatus[HTTP Status Code]
    WebAspect -->|Header value| HttpHeader[HTTP Header Match]
    WebAspect -->|Body keyword| HttpKeyword[HTTP Keyword Match]
    WebAspect -->|JSON field| HttpJson[HTTP JSON Match]
    WebAspect -->|Latency budget| HttpLatency[HTTP Latency Threshold]
    WebAspect -->|Heartbeat payload| Heartbeat[Server Heartbeat]

    Infra --> InfraAspect{Protocol}
    InfraAspect -->|ICMP reachability| Ping[Ping (Host)]
    InfraAspect -->|TCP connectivity| Port[Port (Host/Port)]
    InfraAspect -->|TLS certificate| Ssl[SSL Certificate]

    Domain --> DomainAspect{Focus}
    DomainAspect -->|DNS resolution| Dns[DNS (Domain Resolution)]
    DomainAspect -->|Edge drift| Cdn[CDN Edge Consistency]

    Data --> DataAspect{Concern}
    DataAspect -->|Replication freshness| Replication[Replication Lag]

    Realtime --> RealtimeAspect{Channel}
    RealtimeAspect -->|WebSocket keepalive| Websocket[WebSocket Keepalive]

    HttpGeneral --> HttpGeneralConfig[Configure:<br/>• URL<br/>• Method<br/>• Retry policy]
    HttpStatus --> HttpStatusConfig[Configure:<br/>• URL<br/>• Expected status]
    HttpHeader --> HttpHeaderConfig[Configure:<br/>• URL<br/>• Header name<br/>• Expected value]
    HttpKeyword --> HttpKeywordConfig[Configure:<br/>• URL<br/>• Keyword]
    HttpJson --> HttpJsonConfig[Configure:<br/>• URL<br/>• JSON path<br/>• Expected value]
    HttpLatency --> HttpLatencyConfig[Configure:<br/>• URL<br/>• Max response time]
    Heartbeat --> HeartbeatConfig[Configure:<br/>• URL<br/>• Status path<br/>• Timestamp path<br/>• Expected status]
    Ping --> PingConfig[Configure:<br/>• Host/IP<br/>• Packet count<br/>• Thresholds]
    Port --> PortConfig[Configure:<br/>• Host/IP<br/>• Port<br/>• TLS option]
    Ssl --> SslConfig[Configure:<br/>• Host<br/>• Port<br/>• Warning window]
    Dns --> DnsConfig[Configure:<br/>• Domain<br/>• Record type<br/>• Expected value]
    Cdn --> CdnConfig[Configure:<br/>• Baseline URL<br/>• Edge URLs]
    Replication --> ReplicationConfig[Configure:<br/>• Primary URL<br/>• Replica URL<br/>• Timestamp field<br/>• Max lag]
    Websocket --> WebsocketConfig[Configure:<br/>• ws:// or wss:// URL<br/>• Max pong delay]

    %% Styling
    classDef startNode fill:#e1f5fe,stroke:#0277bd,color:#000000
    classDef decision fill:#fff3e0,stroke:#ef6c00,color:#000000
    classDef monitorType fill:#e8f5e8,stroke:#2e7d32,color:#000000
    classDef config fill:#f3e5f5,stroke:#7b1fa2,color:#000000

    class Start startNode
    class Target,WebAspect,InfraAspect,DomainAspect,DataAspect,RealtimeAspect decision
    class Web,Infra,Domain,Data,Realtime,HttpGeneral,HttpStatus,HttpHeader,HttpKeyword,HttpJson,HttpLatency,Heartbeat,Ping,Port,Ssl,Dns,Cdn,Replication,Websocket monitorType
    class HttpGeneralConfig,HttpStatusConfig,HttpHeaderConfig,HttpKeywordConfig,HttpJsonConfig,HttpLatencyConfig,HeartbeatConfig,PingConfig,PortConfig,SslConfig,DnsConfig,CdnConfig,ReplicationConfig,WebsocketConfig config`} />

## Error Handling and Recovery Flow

This diagram shows how the system handles errors and implements recovery strategies:

<Mermaid value={`stateDiagram-v2
    [*] --> Monitoring : Start Monitor

    Monitoring --> Success : Check Passed
    Monitoring --> Warning : Partial Failure
    Monitoring --> Critical : Total Failure
    Monitoring --> Timeout : Request Timeout

    Success --> Monitoring : Continue Monitoring
    Success --> AlertResolved : Send Resolution Alert
    AlertResolved --> Monitoring

    Warning --> RetryLogic : Implement Retry
    RetryLogic --> Success : Retry Successful
    RetryLogic --> Critical : Retry Failed
    RetryLogic --> Warning : Partial Recovery

    Critical --> ErrorAnalysis : Analyze Error
    ErrorAnalysis --> NetworkIssue : Network Problem
    ErrorAnalysis --> ServiceDown : Service Unavailable
    ErrorAnalysis --> ConfigError : Configuration Issue

    NetworkIssue --> RetryWithBackoff : Exponential Backoff
    ServiceDown --> AlertCritical : Send Critical Alert
    ConfigError --> AlertConfig : Send Config Alert

    RetryWithBackoff --> Success : Network Recovered
    RetryWithBackoff --> Critical : Network Still Down

    AlertCritical --> Monitoring : Continue Monitoring
    AlertConfig --> ManualIntervention : Requires Admin

    Timeout --> TimeoutRetry : Retry with Longer Timeout
    TimeoutRetry --> Success : Timeout Resolved
    TimeoutRetry --> Critical : Still Timing Out

    ManualIntervention --> Monitoring : Issue Resolved
    ManualIntervention --> [*] : Monitor Disabled

    Critical --> [*] : Max Retries Exceeded
    Success --> [*] : Monitor Stopped`} />

## Data Flow and Caching Strategy

This diagram illustrates how data flows through the system and caching strategies:

<Mermaid value={`graph TB
    subgraph "Frontend Layer"
        UI[User Interface]
        Cache[Browser Cache]
        Store[Zustand Store]
    end

    subgraph "IPC Layer"
        Bridge[Context Bridge]
        Queue[Request Queue]
    end

    subgraph "Backend Layer"
        Router[Request Router]
        Validator[Input Validator]

        subgraph "Service Layer"
            SiteService[Site Service]
            MonitorService[Monitor Service]
            CacheService[Cache Service]
        end

        subgraph "Data Layer"
            Repository[Repository Layer]
            L1Cache[L1 Cache<br/>Memory]
            L2Cache[L2 Cache<br/>Redis-like]
        end

        Database[(SQLite Database)]
    end

    subgraph "External"
        Network[Network Targets]
    end

    %% Data Flow
    UI --> Store
    Store --> Cache
    Store --> Bridge
    Bridge --> Queue
    Queue --> Router
    Router --> Validator

    Validator --> SiteService
    Validator --> MonitorService

    SiteService --> CacheService
    MonitorService --> CacheService

    CacheService --> L1Cache
    L1Cache --> L2Cache
    L2Cache --> Repository
    Repository --> Database

    %% Monitoring Flow
    MonitorService --> Network
    Network --> MonitorService

    %% Cache Hit Paths
    CacheService -.->|Cache Hit| L1Cache
    L1Cache -.->|Cache Miss| L2Cache
    L2Cache -.->|Cache Miss| Repository

    %% Response Flow
    Repository -.-> L2Cache
    L2Cache -.-> L1Cache
    L1Cache -.-> CacheService
    CacheService -.-> MonitorService
    MonitorService -.-> Router
    Router -.-> Queue
    Queue -.-> Bridge
    Bridge -.-> Store
    Store -.-> UI

    %% Cache Invalidation
    MonitorService -.->|Invalidate| CacheService
    SiteService -.->|Invalidate| CacheService

    %% Styling
    classDef frontend fill:#3b82f6,stroke:#1e40af,color:#ffffff
    classDef ipc fill:#ea580c,stroke:#c2410c,color:#ffffff
    classDef backend fill:#059669,stroke:#047857,color:#ffffff
    classDef cache fill:#7c3aed,stroke:#5b21b6,color:#ffffff
    classDef database fill:#dc2626,stroke:#b91c1c,color:#ffffff
    classDef external fill:#f59e0b,stroke:#d97706,color:#ffffff

    class UI,Cache,Store frontend
    class Bridge,Queue ipc
    class Router,Validator,SiteService,MonitorService backend
    class CacheService,L1Cache,L2Cache cache
    class Repository,Database database
    class Network external`} />

## Scheduled Monitor Check Lifecycle

This sequence illustrates how a scheduled monitor run traverses the enhanced monitoring stack, from the interval scheduler, through operation correlation, to the renderer update and desktop notifications.

<Mermaid value={`sequenceDiagram
    autonumber
    participant Sched as MonitorScheduler
    participant Mgr as MonitorManager
    participant Checker as EnhancedMonitorChecker
    participant Ops as MonitorOperationRegistry
    participant Timeout as OperationTimeoutManager
    participant StatusSvc as MonitorStatusUpdateService
    participant HistRepo as HistoryRepository
    participant MonRepo as MonitorRepository
    participant Cache as Sites Cache
    participant Bus as TypedEventBus<UptimeEvents>
    participant AppSvc as ApplicationService
    participant Notify as NotificationService
    participant RendererBridge as RendererEventBridge
    participant Preload as Preload Events API
    participant Renderer as Renderer EventsService
    participant Stores as Zustand Stores & UI

    Sched->>Mgr: handleScheduledCheck(siteIdentifier, monitorId)
    Mgr->>Mgr: Lookup site in cache
    Mgr->>Checker: checkMonitor(site, monitorId, false)

    Checker->>Ops: initiateCheck(monitorId)
    Ops-->>Checker: operationId + AbortSignal
    Checker->>Timeout: scheduleTimeout(operationId, timeoutMs)
    Note right of Checker: Combined AbortSignal protects against hung probes.

    Checker->>Checker: executeMonitorCheck (type-specific service)
    Checker->>HistRepo: saveHistoryEntry(result)
    Checker->>StatusSvc: updateMonitorStatus(result)

    StatusSvc->>Ops: validateOperation(operationId)
    alt Operation cancelled or monitor paused
        StatusSvc-->>Checker: ignore result
    else Operation active
        StatusSvc->>MonRepo: persist status & responseTime
        StatusSvc->>Cache: refresh StandardizedCache
        StatusSvc->>Ops: completeOperation(operationId)
        StatusSvc->>Timeout: clearTimeout(operationId)
        StatusSvc-->>Checker: update applied
    end

    opt Update applied
        Checker->>Bus: emit monitor:status-changed
        alt Result == "down"
            Checker->>Bus: emit monitor:down
        else Result == "up"
            Checker->>Bus: emit monitor:up
        end
    end

    Bus->>AppSvc: typed event handler invoked
    AppSvc->>Notify: notifyMonitorDown/Up(site, monitorId)
    AppSvc->>RendererBridge: sendToRenderers(channel, payload)
    RendererBridge->>Preload: webContents.send(channel, payload)
    Preload->>Renderer: window.electronAPI.events.dispatch(channel, payload)
    Renderer->>Stores: apply typed update & append history
    Stores->>UI: Re-render dashboards
`} />

---

These workflow diagrams provide detailed insights into how Uptime Watcher processes monitoring tasks, handles errors, and manages data flow throughout the system.

          </div>
        </div>
      </div>
    </Layout>
  );
}
